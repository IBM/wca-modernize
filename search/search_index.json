{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"IBM watsonx Code Assistant Modernize Applications i. Introduction The curriculum of IBM watsonx Code Assistant: Modernize Applications is designed to teach IBM technical sellers and business partners on how to best plan, execute on, and deploy IBM watsonx Code Assistant . Level 4 learning plans assume that participants have the technical background and proficiency to demonstrate a product or solution to a client, as well as a deep level of understanding for how it can help the client achieve their business goals. Level 4 learning plans are the next logical learning step that goes beyond the demonstrations covered in the Level 3 learning. In keeping with the offering's hybrid cloud architecture, this will encompass deployments both on-premises and for Software-as-a-Service (SaaS) cloud. The \"Practitioners\" (Deploy) coursework extensively covers deployment of the service for both on-premises and IBM Cloud environments. Before taking this course, those enrolling should have earned the watsonx Code Assistant Sales Foundation badge and the watsonx Code Assistant Technical Sales Intermediate badge, and have the technical background and proficiency at giving hands-on demos to clients. ii. Disclaimer \u00a9 IBM Corporation 2025. All Rights Reserved. IBM\u2019s statements regarding its plans, directions and intent are subject to change or withdrawal without notice at IBM\u2019s sole discretion. Information regarding potential future products is intended to outline our general product direction and it should not be relied on in making a purchasing decision. The information mentioned regarding potential future products is not a commitment, promise, or legal obligation to deliver any material, code or functionality. Information about potential future products may not be incorporated into any contract. The development, release, and timing of any future features or functionality described for our products remains at our sole discretion. References in this documentation to IBM products, programs, or services do not imply that they will be available in all countries in which IBM operates. Product release dates and/or capabilities referenced in this presentation may change at any time at IBM\u2019s sole discretion based on market opportunities or other factors and are not intended to be a commitment to future product or feature availability in any way. Nothing contained in these materials is intended to, nor shall have the effect of, stating or implying that any activities undertaken by you will result in any specific sales, revenue growth, or other results. All client examples described are presented as illustrations of how those clients have used IBM products and the results they may have achieved. Actual environmental costs and performance characteristics may vary by client. iii. Generative AI opportunity Two years ago, it would have been difficult to imagine the tremendous pace of development in domains like large language models (LLMs) and generative AI (gen AI). Ten years ago, these technologies were largely relegated to the areas of academic research and science fiction speculation. Today, they are propelling the next wave of productivity in business and the workforce. Such rapid advances in so short a span of time are fueling ever-increasing excitement. As every industry and enterprise grapples with these changes, it's clear that gen AI brings new opportunities, poses new challenges, and necessitates innovation. Opportunity: 4.4 trillion in productivity: Economic Potential of generative AI, McKinsey, June 2023 : https://www.mckinsey.com/capabilities/mckinsey-digital/our-insights/the-economic-potential-of-generative-ai-the-next-productivity-frontier Challenges: 2.4x annual increase in training costs: Cottier et al, The rising costs of training frontier AI models, May 2024 : https://arxiv.org/abs/2405.21015 Innovation: 1/3 of interactions with Gen AI services will invoke action models or agents by 2028: Gartner press release, March 2024 : https://www.gartner.com/en/newsroom/press-releases/2024-03-11-gartner-predicts-one-third-of-interactions-with-genai-services-will-use-action-models-and-autonomous-agents-for-task-completion-by-2028 In terms of opportunity, McKinsey predicts that gen AI could add up to $4.4 trillion USD in value to global corporate profits annually. Doing so, however, will require business leaders to find the right answers to serious challenges: for example, how to mitigate the ballooning costs for training frontier AI models, which in 2025 is rising at a rate of 2.4X each year? In the face of these opportunities and challenges, humanity's innovative spirit is driving the greatest change: as AI advances from models, to assistants, to autonomous AI agents. In just a few years, Gartner predicts that one-third of all interactions with gen AI will be facilitated through the use of agents. iii. WCA Portfolio IBM watsonx Code Assistant ( WCA ) is the flagship offering in a suite of generative AI (gen AI) code assistant products, which also include offerings for Ansible Automation Platform (via IBM watsonx Code Assistant for Red Hat Ansible Lightspeed) and IBM Z modernization (via IBM watsonx Code Assistant for Z). The WCA portfolio accelerates Software Development Lifecycle (SDLC) tasks with AI-powered capabilities including context-aware code generation, explanation, documentation, translation, and unit test generation. It does so while maintaining the principles of trust, security, and compliance with regards to IBM client's data and intellectual property (IP). WCA offerings are powered by IBM Granite foundation models that include state-of-the-art large language models (LLMs) designed for code. For offerings such as WCA for Ansible Lightspeed and WCA for Z, bespoke code models\u2014 tailored to working with Ansible Automation Platform and COBOL-to-Z use cases, respectively \u2014are invoked. Universally true for all of the WCA offerings is that they are geared towards helping IT teams create high-quality code using AI-generated recommendations, based on natural language requests or existing source code. These AI models, and the recommendations they generate, are seamlessly integrated via extensions with the world's most popular integrated development environments (IDEs) \u2013 including Visual Studio Code and Eclipse. USE CASES TO PURSUE The flagship offering, IBM watsonx Code Assistant is the premiere IBM technology for generating enterprise-grade code and applications using IBM Granite large language models (LLMs). It has a wide gamut of capabilities which will be covered in subsequent sections of this presentation. When prospecting clients, look out for use cases involving: real-time code recommendations; chat with code capabilities; code explainability; automated generation of code documentation; code testing and validation; as well as modernization of enterprise Java code. IBM watsonx Code Assistant for Red Hat Ansible Lightspeed (or \"WCA for Ansible Lightspeed\" in shorthand) allows clients to write automation jobs faster with AI-generated recommendations, using natural language prompts to instruct the solution on the types of automation jobs that require generation. Look out for use cases and opportunities with clients that involve enterprise organizations deploying (or automating) IT infrastructure with the Red Hat Ansible Automation Platform (AAP), which is a required enterprise license for using WCA for Ansible Lightspeed. IBM watsonx Code Assistant for Z (or \"WCA for Z\" in shorthand) is IBM's solution for selectively modernizing COBOL business services into Java applications running on IBM Z mainframe systems. Look out for client opportunities or use cases that involve integrating refactored COBOL (or Java) code into existing COBOL applications running on IBM Z, where it's critical that the full interoperability is maintained between environments and that quality of service is maintained. The portfolio of solutions under the IBM watsonx Code Assistant family is expansive in terms of capabilities and the types of use cases that can be addressed. Aligning the best-fit solution to the appropriate use cases, languages, applications, and infrastructure is critical. Use the following guidelines to help shape client discussions and opportunities. IBM watsonx Code Assistant supports over 115 different programming languages for code. In particular, languages and formats such as Java, C, JSON, JavaScript, HTML, and PHP are subjects in which WCA \u201cMajors\u201d and excels. Other languages such as Ruby, SQL, and Swift could be considered \u201cMinors\u201d where the generalized code model can work with the language, but has less training data to base those recommendations on. These percentages and training data volumes will continue to evolve as the Granite code models mature. WCA is also available via Software-as-a-Service (SaaS) consumption on cloud and deployable on-premises, which is a unique differentiator over other gen AI code solutions in the marketplace. LANGUAGES, APPLICATIONS, AND INFRASTRUCTURE TO PURSUE For those familiar with other WCA offerings\u2014 such as IBM watsonx Code Assistant for Red Hat Ansible Lightspeed and IBM watsonx Code Assistant for Z \u2014the generalized code model approach taken by WCA differs from the specialized code model approach of those two aforementioned offerings. The WCA for Ansible Lightspeed flavor of IBM Granite code models specializes (\u201dMajors\") only in Red Hat Ansible Playbooks and YAML (Yet Another Markup Language) formats. Similarly, the IBM Granite code model used by WCA for Z specializes in transforming COBOL mainframe code into modernized Java code for IBM Z systems. Ansible Playbooks and COBOL are supported (\u201dMinor\") languages for the generalized IBM Granite code models\u2014 and therefore are supported by WCA \u2014but if a client wishes to specialize in those particular languages and frameworks, they would be well advised to utilize the bespoke WCA for Ansible Lightspeed and WCA for Z offerings to do so. For WCA for Ansible Lightspeed , hone in on opportunities involving: Ansible Playbooks, AAP environments, YAML-based automation scripts, and containerized applications running atop of Red Hat OpenShift. For WCA for Z , focus on opportunities involving: z/OS application modernization, COBOL to modernized Java transformations, and COBOL to IBM Z mainframe use cases. iv. Curriculum The curriculum for the Level 4 hands-on labs is segmented across 3 chapters, each containing multiple modules that address topics of on-premises cluster deployments, configuration of Software-as-a-Service (SaaS) deployments on cloud, and modernization of legacy WebSphere Application Server code into WebSphere Liberty. CHAPTER MODULES IBM Cloud (SaaS) Configuration 1. Objectives and requirements 2. Reserve an environment 3. Configure the Java environment 4. Install VS Code extension 5. Install Eclipse plug-in Application Modernization - WebSphere to Liberty 1. Objectives and requirements 2. Basic migration capabilities 3. Configuration management 4. APIs and libraries 5. EJB modernization 6. JMS integration 7. Security modernization 8. Full stack modernization","title":"Introduction"},{"location":"#ibm-watsonx-code-assistantmodernize-applications","text":"","title":"IBM watsonx Code AssistantModernize Applications"},{"location":"#i-introduction","text":"The curriculum of IBM watsonx Code Assistant: Modernize Applications is designed to teach IBM technical sellers and business partners on how to best plan, execute on, and deploy IBM watsonx Code Assistant . Level 4 learning plans assume that participants have the technical background and proficiency to demonstrate a product or solution to a client, as well as a deep level of understanding for how it can help the client achieve their business goals. Level 4 learning plans are the next logical learning step that goes beyond the demonstrations covered in the Level 3 learning. In keeping with the offering's hybrid cloud architecture, this will encompass deployments both on-premises and for Software-as-a-Service (SaaS) cloud. The \"Practitioners\" (Deploy) coursework extensively covers deployment of the service for both on-premises and IBM Cloud environments. Before taking this course, those enrolling should have earned the watsonx Code Assistant Sales Foundation badge and the watsonx Code Assistant Technical Sales Intermediate badge, and have the technical background and proficiency at giving hands-on demos to clients.","title":"i. Introduction"},{"location":"#ii-disclaimer","text":"\u00a9 IBM Corporation 2025. All Rights Reserved. IBM\u2019s statements regarding its plans, directions and intent are subject to change or withdrawal without notice at IBM\u2019s sole discretion. Information regarding potential future products is intended to outline our general product direction and it should not be relied on in making a purchasing decision. The information mentioned regarding potential future products is not a commitment, promise, or legal obligation to deliver any material, code or functionality. Information about potential future products may not be incorporated into any contract. The development, release, and timing of any future features or functionality described for our products remains at our sole discretion. References in this documentation to IBM products, programs, or services do not imply that they will be available in all countries in which IBM operates. Product release dates and/or capabilities referenced in this presentation may change at any time at IBM\u2019s sole discretion based on market opportunities or other factors and are not intended to be a commitment to future product or feature availability in any way. Nothing contained in these materials is intended to, nor shall have the effect of, stating or implying that any activities undertaken by you will result in any specific sales, revenue growth, or other results. All client examples described are presented as illustrations of how those clients have used IBM products and the results they may have achieved. Actual environmental costs and performance characteristics may vary by client.","title":"ii. Disclaimer"},{"location":"#iii-generative-ai-opportunity","text":"Two years ago, it would have been difficult to imagine the tremendous pace of development in domains like large language models (LLMs) and generative AI (gen AI). Ten years ago, these technologies were largely relegated to the areas of academic research and science fiction speculation. Today, they are propelling the next wave of productivity in business and the workforce. Such rapid advances in so short a span of time are fueling ever-increasing excitement. As every industry and enterprise grapples with these changes, it's clear that gen AI brings new opportunities, poses new challenges, and necessitates innovation. Opportunity: 4.4 trillion in productivity: Economic Potential of generative AI, McKinsey, June 2023 : https://www.mckinsey.com/capabilities/mckinsey-digital/our-insights/the-economic-potential-of-generative-ai-the-next-productivity-frontier Challenges: 2.4x annual increase in training costs: Cottier et al, The rising costs of training frontier AI models, May 2024 : https://arxiv.org/abs/2405.21015 Innovation: 1/3 of interactions with Gen AI services will invoke action models or agents by 2028: Gartner press release, March 2024 : https://www.gartner.com/en/newsroom/press-releases/2024-03-11-gartner-predicts-one-third-of-interactions-with-genai-services-will-use-action-models-and-autonomous-agents-for-task-completion-by-2028 In terms of opportunity, McKinsey predicts that gen AI could add up to $4.4 trillion USD in value to global corporate profits annually. Doing so, however, will require business leaders to find the right answers to serious challenges: for example, how to mitigate the ballooning costs for training frontier AI models, which in 2025 is rising at a rate of 2.4X each year? In the face of these opportunities and challenges, humanity's innovative spirit is driving the greatest change: as AI advances from models, to assistants, to autonomous AI agents. In just a few years, Gartner predicts that one-third of all interactions with gen AI will be facilitated through the use of agents.","title":"iii. Generative AI opportunity"},{"location":"#iii-wca-portfolio","text":"IBM watsonx Code Assistant ( WCA ) is the flagship offering in a suite of generative AI (gen AI) code assistant products, which also include offerings for Ansible Automation Platform (via IBM watsonx Code Assistant for Red Hat Ansible Lightspeed) and IBM Z modernization (via IBM watsonx Code Assistant for Z). The WCA portfolio accelerates Software Development Lifecycle (SDLC) tasks with AI-powered capabilities including context-aware code generation, explanation, documentation, translation, and unit test generation. It does so while maintaining the principles of trust, security, and compliance with regards to IBM client's data and intellectual property (IP). WCA offerings are powered by IBM Granite foundation models that include state-of-the-art large language models (LLMs) designed for code. For offerings such as WCA for Ansible Lightspeed and WCA for Z, bespoke code models\u2014 tailored to working with Ansible Automation Platform and COBOL-to-Z use cases, respectively \u2014are invoked. Universally true for all of the WCA offerings is that they are geared towards helping IT teams create high-quality code using AI-generated recommendations, based on natural language requests or existing source code. These AI models, and the recommendations they generate, are seamlessly integrated via extensions with the world's most popular integrated development environments (IDEs) \u2013 including Visual Studio Code and Eclipse. USE CASES TO PURSUE The flagship offering, IBM watsonx Code Assistant is the premiere IBM technology for generating enterprise-grade code and applications using IBM Granite large language models (LLMs). It has a wide gamut of capabilities which will be covered in subsequent sections of this presentation. When prospecting clients, look out for use cases involving: real-time code recommendations; chat with code capabilities; code explainability; automated generation of code documentation; code testing and validation; as well as modernization of enterprise Java code. IBM watsonx Code Assistant for Red Hat Ansible Lightspeed (or \"WCA for Ansible Lightspeed\" in shorthand) allows clients to write automation jobs faster with AI-generated recommendations, using natural language prompts to instruct the solution on the types of automation jobs that require generation. Look out for use cases and opportunities with clients that involve enterprise organizations deploying (or automating) IT infrastructure with the Red Hat Ansible Automation Platform (AAP), which is a required enterprise license for using WCA for Ansible Lightspeed. IBM watsonx Code Assistant for Z (or \"WCA for Z\" in shorthand) is IBM's solution for selectively modernizing COBOL business services into Java applications running on IBM Z mainframe systems. Look out for client opportunities or use cases that involve integrating refactored COBOL (or Java) code into existing COBOL applications running on IBM Z, where it's critical that the full interoperability is maintained between environments and that quality of service is maintained. The portfolio of solutions under the IBM watsonx Code Assistant family is expansive in terms of capabilities and the types of use cases that can be addressed. Aligning the best-fit solution to the appropriate use cases, languages, applications, and infrastructure is critical. Use the following guidelines to help shape client discussions and opportunities. IBM watsonx Code Assistant supports over 115 different programming languages for code. In particular, languages and formats such as Java, C, JSON, JavaScript, HTML, and PHP are subjects in which WCA \u201cMajors\u201d and excels. Other languages such as Ruby, SQL, and Swift could be considered \u201cMinors\u201d where the generalized code model can work with the language, but has less training data to base those recommendations on. These percentages and training data volumes will continue to evolve as the Granite code models mature. WCA is also available via Software-as-a-Service (SaaS) consumption on cloud and deployable on-premises, which is a unique differentiator over other gen AI code solutions in the marketplace. LANGUAGES, APPLICATIONS, AND INFRASTRUCTURE TO PURSUE For those familiar with other WCA offerings\u2014 such as IBM watsonx Code Assistant for Red Hat Ansible Lightspeed and IBM watsonx Code Assistant for Z \u2014the generalized code model approach taken by WCA differs from the specialized code model approach of those two aforementioned offerings. The WCA for Ansible Lightspeed flavor of IBM Granite code models specializes (\u201dMajors\") only in Red Hat Ansible Playbooks and YAML (Yet Another Markup Language) formats. Similarly, the IBM Granite code model used by WCA for Z specializes in transforming COBOL mainframe code into modernized Java code for IBM Z systems. Ansible Playbooks and COBOL are supported (\u201dMinor\") languages for the generalized IBM Granite code models\u2014 and therefore are supported by WCA \u2014but if a client wishes to specialize in those particular languages and frameworks, they would be well advised to utilize the bespoke WCA for Ansible Lightspeed and WCA for Z offerings to do so. For WCA for Ansible Lightspeed , hone in on opportunities involving: Ansible Playbooks, AAP environments, YAML-based automation scripts, and containerized applications running atop of Red Hat OpenShift. For WCA for Z , focus on opportunities involving: z/OS application modernization, COBOL to modernized Java transformations, and COBOL to IBM Z mainframe use cases.","title":"iii. WCA Portfolio"},{"location":"#iv-curriculum","text":"The curriculum for the Level 4 hands-on labs is segmented across 3 chapters, each containing multiple modules that address topics of on-premises cluster deployments, configuration of Software-as-a-Service (SaaS) deployments on cloud, and modernization of legacy WebSphere Application Server code into WebSphere Liberty. CHAPTER MODULES IBM Cloud (SaaS) Configuration 1. Objectives and requirements 2. Reserve an environment 3. Configure the Java environment 4. Install VS Code extension 5. Install Eclipse plug-in Application Modernization - WebSphere to Liberty 1. Objectives and requirements 2. Basic migration capabilities 3. Configuration management 4. APIs and libraries 5. EJB modernization 6. JMS integration 7. Security modernization 8. Full stack modernization","title":"iv. Curriculum"},{"location":"toc/","text":"@media screen { .md-main__inner { display: none !important; } .md-header, .md-footer, .md-sidebar { display: none !important; } } @media print { h2 { page-break-before: auto !important; } } Table of Contents IBM Cloud (SaaS) Configuration 1. Objectives and requirements 2. Reserve an environment 3. Configure for enterprise Java 4. Install WCA extension for Visual Studio Code 5. Install WCA plug-in for Eclipse IDE Application Modernization - WebSphere to Liberty 1. Objectives and requirements 2. Basic migration capabilities 3. Configuration management 4. APIs and libraries 5. EJB modernization 6. JMS integration 7. Security modernization 8. Full stack modernization","title":"Table of Contents"},{"location":"toc/#table-of-contents","text":"","title":"Table of Contents"},{"location":"toc/#ibm-cloud-saas-configuration","text":"1. Objectives and requirements 2. Reserve an environment 3. Configure for enterprise Java 4. Install WCA extension for Visual Studio Code 5. Install WCA plug-in for Eclipse IDE","title":"IBM Cloud (SaaS) Configuration"},{"location":"toc/#application-modernization-websphere-to-liberty","text":"1. Objectives and requirements 2. Basic migration capabilities 3. Configuration management 4. APIs and libraries 5. EJB modernization 6. JMS integration 7. Security modernization 8. Full stack modernization","title":"Application Modernization - WebSphere to Liberty"},{"location":"appmod/1/","text":"Objectives and requirements Application Modernization - WebSphere to Liberty i. About this lab SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". The approach taken with each module of Application Modernization - WebSphere to Liberty , engaging with IBM watsonx Code Assistant's (WCA) Chat functionality in the chapters ahead, is to emulate the experience of collaborating with a trusted colleague on how to best take on the modernization of WebSphere Application Server code: segmented by specific use cases, tackling particular business functions that need to be revitalized for cloud-native, and exploring precise pain points within a client's code base. The WCA Chat experience reflects how you and that trusted colleague might, together, approach a scenario like modernizing usage of Enterprise JavaBeans with WebSphere Liberty, as an example. Thinking about modernization in discrete scenarios such as these, where the aperture is narrowly focused on a specific piece of functionality or use case\u2014 rather than trying to modernize an entire, complex application stack altogether \u2014has immense value. It is far more akin and practical to the real-world scenarios that you will encounter during engagements with clients: as a seller; a business partner; a trusted advisor. Entrusted with bestowing best practices for how that client can modernize specific pain points in their application code; not taking on the task of modernizing the entirety of their application stack \"in one go.\" Crafting complex modernization plans for enterprise-scale applications cannot be approached as explicit \"A, then B, followed by C\" rulebooks or rigid decision trees. It is essential that you understand how to approach modernization as a collaborative, problem-solving oriented, question-and-answer refinement exercise. WCA Chat, which you will use to these ends in the following modules, is an ideal mechanism for refining the correct modernization approach. ii. Prerequisites This lab requires that participants have previously completed the IBM Cloud (SaaS) Configuration lab in its entirety. Those conducting the hands-on sections of this lab will require access to a deployed instance of WCA Standard Plan and have successfully integrated with the WCA service via either the Visual Studio Code ( VS Code ) extension or Eclipse IDE plug-ins. iii. Hands-on topics For each module of the Application Modernization - WebSphere to Liberty lab, participants will have the opportunity to dissect the contents and purpose of legacy WebSphere Application Server ( WAS ) code, examine its limitations in the context of more up-to-date alternatives, and then compare that to a best-practices implementation of that equivalent codebase written in WebSphere Liberty . Afterwards, participants will go hands-on with the IBM watsonx Code Assistant ( WCA ) Standard environment to reproduce the steps of modernizing the WAS legacy code into Liberty code. Differences in the two code bases and the benefits of WCA's approach to code modernization will also be examined. MODERNIZATION TASK WEBSPHERE APPLICATION LIBERTY APPLICATION Basic migration capabilities WebSphere Enterprise Archive (EAR) configuration, at enterprise scale, becomes cumbersome to maintain and can often result in frequent deployment delays (or human-induced configuration errors) each time the modules need to be modified. Liberty Web Archive (WAR) configurations remove the need for multiple external descriptors and consolidate settings into a single, unified file. Configuration and dependency management WebSphere class loader configuration implementation suffers from significant (and unnecessary) complexity owing to bloated class-loader configurations. Liberty server configuration is expected to manage dependencies and simplify the overall process of application configuration. APIs and libraries WebSphere Scheduler APIs may not be immediately portable in their current form, they are potentially more costly to maintain than Liberty counterparts, and have less functionality due to outdated implementations. Liberty's Jakarta EE-templated APIs are more transferable across vendors and platforms, are built to cloud-native architecture by design, and are portable to containers. Enterprise JavaBeans (EJB) modernization WebSphere EJB with XML represent server-side components used by Java Enterprise Edition (Java EE or Jakarta EE) to encapsulate repeatable business logic. They are more challenging to maintain and prone to human-induced errors. Liberty EJBs with annotations use Java instead of XML, applying them directly within Java classes for configuration. In many cases, this reduces the need for external XML files and eases maintainability. Java Message Service integration WebSphere's MQ JMS integration uses complex configurations made up of verbose XML or admin console requirements. They can be difficult to maintain due to their dispersed nature. Liberty's MQ JMS integration provides a more centralized pattern to simplify the process of troubleshooting messaging integrations and maintaining existing policies. Security modernization WebSphere's XML-based security is challenging to understand and maintain due to XML file separation from the supporting Java code, which tends to lower developer productivity due to frequent context-switching. Liberty's annotation-based security reduces the need for external configuration and instead centralizes security declarations closer to the actual code implementation. iv. Troubleshooting If you require assistance or run into issues with the hands-on lab, help is available. Environment issues: The lab environment is managed by IBM Technology Zone. Opening a support case ticket is recommended for issues related to the hands-on environment (provisioning, running, and so on.) Product questions: For questions related to IBM watsonx Code Assistant capabilities, sales opportunities, roadmap, and other such matters, open a thread on the #watsonx-code-assistant Slack channel. v. Next steps In the following section, participants will explore fundamental modernization and migration techniques using legacy WebSphere Enterprise Archive ( EAR ) configuration code \u2014 ultimately producing a modernized Liberty Web Archive ( WAR ) configuration codebase.","title":"1. Objectives and requirements"},{"location":"appmod/1/#objectives-and-requirementsapplication-modernization-websphere-to-liberty","text":"","title":"Objectives and requirementsApplication Modernization - WebSphere to Liberty"},{"location":"appmod/1/#i-about-this-lab","text":"SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". The approach taken with each module of Application Modernization - WebSphere to Liberty , engaging with IBM watsonx Code Assistant's (WCA) Chat functionality in the chapters ahead, is to emulate the experience of collaborating with a trusted colleague on how to best take on the modernization of WebSphere Application Server code: segmented by specific use cases, tackling particular business functions that need to be revitalized for cloud-native, and exploring precise pain points within a client's code base. The WCA Chat experience reflects how you and that trusted colleague might, together, approach a scenario like modernizing usage of Enterprise JavaBeans with WebSphere Liberty, as an example. Thinking about modernization in discrete scenarios such as these, where the aperture is narrowly focused on a specific piece of functionality or use case\u2014 rather than trying to modernize an entire, complex application stack altogether \u2014has immense value. It is far more akin and practical to the real-world scenarios that you will encounter during engagements with clients: as a seller; a business partner; a trusted advisor. Entrusted with bestowing best practices for how that client can modernize specific pain points in their application code; not taking on the task of modernizing the entirety of their application stack \"in one go.\" Crafting complex modernization plans for enterprise-scale applications cannot be approached as explicit \"A, then B, followed by C\" rulebooks or rigid decision trees. It is essential that you understand how to approach modernization as a collaborative, problem-solving oriented, question-and-answer refinement exercise. WCA Chat, which you will use to these ends in the following modules, is an ideal mechanism for refining the correct modernization approach.","title":"i. About this lab"},{"location":"appmod/1/#ii-prerequisites","text":"This lab requires that participants have previously completed the IBM Cloud (SaaS) Configuration lab in its entirety. Those conducting the hands-on sections of this lab will require access to a deployed instance of WCA Standard Plan and have successfully integrated with the WCA service via either the Visual Studio Code ( VS Code ) extension or Eclipse IDE plug-ins.","title":"ii. Prerequisites"},{"location":"appmod/1/#iii-hands-on-topics","text":"For each module of the Application Modernization - WebSphere to Liberty lab, participants will have the opportunity to dissect the contents and purpose of legacy WebSphere Application Server ( WAS ) code, examine its limitations in the context of more up-to-date alternatives, and then compare that to a best-practices implementation of that equivalent codebase written in WebSphere Liberty . Afterwards, participants will go hands-on with the IBM watsonx Code Assistant ( WCA ) Standard environment to reproduce the steps of modernizing the WAS legacy code into Liberty code. Differences in the two code bases and the benefits of WCA's approach to code modernization will also be examined. MODERNIZATION TASK WEBSPHERE APPLICATION LIBERTY APPLICATION Basic migration capabilities WebSphere Enterprise Archive (EAR) configuration, at enterprise scale, becomes cumbersome to maintain and can often result in frequent deployment delays (or human-induced configuration errors) each time the modules need to be modified. Liberty Web Archive (WAR) configurations remove the need for multiple external descriptors and consolidate settings into a single, unified file. Configuration and dependency management WebSphere class loader configuration implementation suffers from significant (and unnecessary) complexity owing to bloated class-loader configurations. Liberty server configuration is expected to manage dependencies and simplify the overall process of application configuration. APIs and libraries WebSphere Scheduler APIs may not be immediately portable in their current form, they are potentially more costly to maintain than Liberty counterparts, and have less functionality due to outdated implementations. Liberty's Jakarta EE-templated APIs are more transferable across vendors and platforms, are built to cloud-native architecture by design, and are portable to containers. Enterprise JavaBeans (EJB) modernization WebSphere EJB with XML represent server-side components used by Java Enterprise Edition (Java EE or Jakarta EE) to encapsulate repeatable business logic. They are more challenging to maintain and prone to human-induced errors. Liberty EJBs with annotations use Java instead of XML, applying them directly within Java classes for configuration. In many cases, this reduces the need for external XML files and eases maintainability. Java Message Service integration WebSphere's MQ JMS integration uses complex configurations made up of verbose XML or admin console requirements. They can be difficult to maintain due to their dispersed nature. Liberty's MQ JMS integration provides a more centralized pattern to simplify the process of troubleshooting messaging integrations and maintaining existing policies. Security modernization WebSphere's XML-based security is challenging to understand and maintain due to XML file separation from the supporting Java code, which tends to lower developer productivity due to frequent context-switching. Liberty's annotation-based security reduces the need for external configuration and instead centralizes security declarations closer to the actual code implementation.","title":"iii. Hands-on topics"},{"location":"appmod/1/#iv-troubleshooting","text":"If you require assistance or run into issues with the hands-on lab, help is available. Environment issues: The lab environment is managed by IBM Technology Zone. Opening a support case ticket is recommended for issues related to the hands-on environment (provisioning, running, and so on.) Product questions: For questions related to IBM watsonx Code Assistant capabilities, sales opportunities, roadmap, and other such matters, open a thread on the #watsonx-code-assistant Slack channel.","title":"iv. Troubleshooting"},{"location":"appmod/1/#v-next-steps","text":"In the following section, participants will explore fundamental modernization and migration techniques using legacy WebSphere Enterprise Archive ( EAR ) configuration code \u2014 ultimately producing a modernized Liberty Web Archive ( WAR ) configuration codebase.","title":"v. Next steps"},{"location":"appmod/2/","text":"Basic migration capabilities Application Modernization - WebSphere to Liberty i. Incentives to modernize SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". Lariat Corporation has a large collection of WebSphere Enterprise Archive (EAR) applications designed specifically for deployments using WAS . These are packaged archive files that bundle together multiple Java Enterprise Edition (Java EE shorthand, or more recently referred to by Jakarta EE) components: web modules, Enterprise JavaBeans (EJB) files, resource adapters, libraries, and so on. Collectively, all of these components allow for Lariat's engineers and developers to manage complex enterprise applications \"efficiently\" (as the theory goes) by encapsulating all of the necessary components into a single, structured archive. Liberty , however, supports comparatively simple and standardized configurations that greatly reduce the complexities found with WebSphere applications. Liberty Web Archive ( WAR ) configurations remove the need for multiple external descriptors and consolidate settings into one unified file ( server.xml ). Overall, this approach improves the maintainability of the code base in the long term and improves the deployment speed for new instances (or versions) of the Liberty-based application. Feature WebSphere EAR configuration Liberty WAR configuration Deployment Complexity High: multiple modules and files to manage. Low: single deployable artifact. Speed Slow deployments due to heightened complexity. Faster deployments owing to simplicity and lightweight design. Maintainability Challenging due multiple configuration files need to managed and changes reconciled across multiple locations. Streamlined and less complex. Scalability Difficult to scale due to potential for complex sets of dependencies. Rapidly scaled due to cloud-native design. As part of the modernization efforts, the new Liberty application will need to support the functionality of the legacy WebSphere application, such as: Deployment of complex, modular Java EE applications onto WebSphere servers Encapsulation of web applications, EJB modules, and dependencies in a structured format Facilitate version control, deployment, and existing rollback strategies to guarantee consistent and reliable production environments In general, the team supporting the modernization anticipate that Liberty will enable greatly simplified, more modular deployment structures \u2014 which in turn will reduce the overhead, complexity, and maintenance burden of these applications. ii. WebSphere legacy code First, examine the legacy code (below), which as mentioned previously is a snapshot of a larger application using WebSphere EAR configuration : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <!-- application.xml --> <application> <module> <web> <web-uri> legacyapp.war </web-uri> <context-root> /legacyapp </context-root> </web> </module> <module> <ejb> legacyEJB.jar </ejb> </module> <security-role> <role-name> user </role-name> </security-role> </application> <!-- ibm-web-bnd.xml --> <web-bnd> <virtual-host name= \"default_host\" /> <resource-ref name= \"jdbc/LegacyDS\" binding-name= \"jdbc/LegacyDS\" /> </web-bnd> The application defines two modules\u2014 legacyapp.war and legacyEJB.jar \u2014which denote the web and EJB components of the application, respectively ( lines 5 and 10 ). The code sets a specific context root to access the legacyapp.war web module. It also introduces WebSphere-specific bindings such as ibm-web-bnd.xml ( line 17 ), which are employed for virtual hosting and resource references. Security roles and resource bindings are managed externally through the use of XML. The legacy code showcased above has a particular structural element that makes it a prime candidate for this type of Liberty modernization. Chiefly, the EAR application uses separate XML descriptors like application.xml ( line 1 ) and ibm-web-bnd.xml ( line 17 ) to define distinct modules. This setup, at enterprise scale, becomes cumbersome to maintain and can often result in frequent deployment delays (or human-induced configuration errors) each time the modules need to be modified. The maintenance burden of this more intricate structural design can be reduced with a more simplified, Liberty-based approach. iii. Liberty modernized code Consider the modernized (functionally equivalent) code using Liberty WAR configuration : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 <!-- server.xml --> <server> <featureManager> <feature> webProfile-8.0 </feature> <feature> jdbc-4.2 </feature> </featureManager> <httpEndpoint host= \"*\" httpPort= \"9080\" httpsPort= \"9443\" /> <application id= \"modernapp\" location= \"modernapp.war\" context-root= \"/modernapp\" > <classloader delegation= \"parentLast\" /> </application> <dataSource id= \"jdbc/ModernDS\" jndiName= \"jdbc/ModernDS\" > <jdbcDriver libraryRef= \"jdbcLib\" /> <connectionManager maxPoolSize= \"50\" /> </dataSource> <library id= \"jdbcLib\" > <fileset dir= \"${server.config.dir}/jdbc\" includes= \"*.jar\" /> </library> </server> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <!-- application.xml --> <application> <module> <web> <web-uri> legacyapp.war </web-uri> <context-root> /legacyapp </context-root> </web> </module> <module> <ejb> legacyEJB.jar </ejb> </module> <security-role> <role-name> user </role-name> </security-role> </application> <!-- ibm-web-bnd.xml --> <web-bnd> <virtual-host name= \"default_host\" /> <resource-ref name= \"jdbc/LegacyDS\" binding-name= \"jdbc/LegacyDS\" /> </web-bnd> BREVITY: DISPELLING MODERNIZATION MISCONCEPTIONS The Liberty application code snippet is in fact \"longer\", in terms of lines of code, than the legacy WAS predecessor application. This raises an important point about modernized application code: the brevity and terseness of an application's code does not always reflect more efficient or practical code. What is important to the success and value of modernization efforts is that the new code is more appropriate to the tasks to be performed, has greater efficacy than before, and is more easily maintained \u2014 or a combination of these factors. Whether that is achieved in fewer lines of code than before is ultimately far less important. The modernized Liberty application code streamlines the original WebSphere configuration details into a single WAR file ( server.xml ) with clear, unified definitions. JDBC configurations are directly defined alongside the application deployment, removing the need for external bindings. Legacy EAR files have been consolidated into lightweight Web Archive (WAR) structures. WebSphere-specific descriptors like ibm-web-bnd.xml have been converted into modern Liberty features ( webProfile-8.0 , jdbc-4.2 ). WebSphere-specific APIs and deprecated components, like AdminClient APIs or Java Naming and Directory Interface (JDNI) look-ups, have been replaced. Liberty WAR configuration file uses parentLast ( line 11 ) class loading to ensure that the application's resources take precedence. <application id= \"modernapp\" location= \"modernapp.war\" context-root= \"/modernapp\" > <classloader delegation= \"parentLast\" /> </application> Ultimately, the modernized Liberty application code supports Lariat's objectives of simplified, modular deployment structures that reduce the overhead and technical burdens placed on developers maintaining the legacy WebSphere code base. iv. Hands-on with WCA SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <!-- application.xml --> <application> <module> <web> <web-uri> legacyapp.war </web-uri> <context-root> /legacyapp </context-root> </web> </module> <module> <ejb> legacyEJB.jar </ejb> </module> <security-role> <role-name> user </role-name> </security-role> </application> <!-- ibm-web-bnd.xml --> <web-bnd> <virtual-host name= \"default_host\" /> <resource-ref name= \"jdbc/LegacyDS\" binding-name= \"jdbc/LegacyDS\" /> </web-bnd> After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY server.xml WCA LIBERTY web.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 <server description= \"new server\" > <featureManager> <feature> jsp-2.3 </feature> <feature> servlet-3.1 </feature> <feature> ejbLite-3.2 </feature> </featureManager> <httpEndpoint id= \"defaultHttpEndpoint\" host= \"*\" httpPort= \"9080\" httpsPort= \"9443\" /> <webApplication location= \"path/to/legacyapp.war\" name= \"legacyapp\" > <context-root> /legacyapp </context-root> <classLoader commonLibraryRef= \"LibertyBasicCL\" /> </webApplication> <basicRegistry id= \"LibertyBasicCL\" realm= \"LibertyBasicRealm\" > <user name= \"admin\" password= \"adminPassword\" /> </basicRegistry> <login-config> <auth-method> BASIC </auth-method> </login-config> <realm name= \"LibertyBasicRealm\" realm-name= \"LibertyBasicRealm\" > <users file= \"path/to/users.properties\" /> <groups file= \"path/to/groups.properties\" /> </realm> <jdbcDriver libraryRef= \"DefaultDataSource\" /> <dataSource jndiName= \"jdbc/LegacyDS\" id= \"DefaultDataSource\" > <jdbcDriver libraryRef= \"XADatabase\" /> <properties.db2.jcc databaseName= \"yourDatabaseName\" serverName= \"yourServerName\" portNumber= \"yourPortNumber\" /> </dataSource> </server> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <web-app xmlns= \"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version= \"3.1\" > <resource-ref> <description> Legacy Data Source </description> <res-ref-name> jdbc/LegacyDS </res-ref-name> <res-type> javax.sql.DataSource </res-type> <res-auth> Container </res-auth> </resource-ref> <security-role> <role-name> user </role-name> </security-role> </web-app> Let's first examine the use of WebSphere and Liberty-specific features . Lariat makes use of the webProfile-8.0 bundle set for servlets and Enterprise JavaBeans: <featureManager> <feature> webProfile-8.0 </feature> <feature> jdbc-4.2 </feature> </featureManager> By contrast, WCA has explicitly pulled in individual features like jsp-2.3 , servlet-3.1 , and ejbLite-3.2 which provides finer control over imports - avoiding unnecessary bloat. <featureManager> <feature> jsp-2.3 </feature> <feature> servlet-3.1 </feature> <feature> ejbLite-3.2 </feature> </featureManager> Security configuration is another area in which WCA has outperformed Lariat's modernization efforts. For Lariat, no authentication or user realm is configured. By contrast, WCA implements BASIC authentication, user and group registries, login, and custom realm with external property files. Security best-practices have been tuned and baked directly into the AI-generated code recommendations produced by WCA. <basicRegistry id= \"LibertyBasicCL\" realm= \"LibertyBasicRealm\" > <user name= \"admin\" password= \"adminPassword\" /> </basicRegistry> <login-config> <auth-method> BASIC </auth-method> </login-config> <realm name= \"LibertyBasicRealm\" realm-name= \"LibertyBasicRealm\" > <users file= \"path/to/users.properties\" /> <groups file= \"path/to/groups.properties\" /> </realm> DataSource configuration is arguably a toss-up between either version, depending on an organization's goals. Lariat's code has been structured for portability and is decoupled from any specific database: <dataSource id= \"jdbc/ModernDS\" jndiName= \"jdbc/ModernDS\" > <jdbcDriver libraryRef= \"jdbcLib\" /> <connectionManager maxPoolSize= \"50\" /> </dataSource> WCA's recommendation utilizes an IBM Db2-specific set of JDBC drivers. For clients with a highly-regulated, Db2-heavy enterprise environment, this code recommendation has much more utility to the requirements of their business: <dataSource jndiName= \"jdbc/LegacyDS\" id= \"DefaultDataSource\" > <jdbcDriver libraryRef= \"XADatabase\" /> <properties.db2.jcc ... /> </dataSource> v. Next steps In the following module, participants will examine how to modernize legacy WebSphere Application Server code for configuration and dependency management.","title":"2. Basic migration capabilities"},{"location":"appmod/2/#basic-migration-capabilitiesapplication-modernization-websphere-to-liberty","text":"","title":"Basic migration capabilitiesApplication Modernization - WebSphere to Liberty"},{"location":"appmod/2/#i-incentives-to-modernize","text":"SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". Lariat Corporation has a large collection of WebSphere Enterprise Archive (EAR) applications designed specifically for deployments using WAS . These are packaged archive files that bundle together multiple Java Enterprise Edition (Java EE shorthand, or more recently referred to by Jakarta EE) components: web modules, Enterprise JavaBeans (EJB) files, resource adapters, libraries, and so on. Collectively, all of these components allow for Lariat's engineers and developers to manage complex enterprise applications \"efficiently\" (as the theory goes) by encapsulating all of the necessary components into a single, structured archive. Liberty , however, supports comparatively simple and standardized configurations that greatly reduce the complexities found with WebSphere applications. Liberty Web Archive ( WAR ) configurations remove the need for multiple external descriptors and consolidate settings into one unified file ( server.xml ). Overall, this approach improves the maintainability of the code base in the long term and improves the deployment speed for new instances (or versions) of the Liberty-based application. Feature WebSphere EAR configuration Liberty WAR configuration Deployment Complexity High: multiple modules and files to manage. Low: single deployable artifact. Speed Slow deployments due to heightened complexity. Faster deployments owing to simplicity and lightweight design. Maintainability Challenging due multiple configuration files need to managed and changes reconciled across multiple locations. Streamlined and less complex. Scalability Difficult to scale due to potential for complex sets of dependencies. Rapidly scaled due to cloud-native design. As part of the modernization efforts, the new Liberty application will need to support the functionality of the legacy WebSphere application, such as: Deployment of complex, modular Java EE applications onto WebSphere servers Encapsulation of web applications, EJB modules, and dependencies in a structured format Facilitate version control, deployment, and existing rollback strategies to guarantee consistent and reliable production environments In general, the team supporting the modernization anticipate that Liberty will enable greatly simplified, more modular deployment structures \u2014 which in turn will reduce the overhead, complexity, and maintenance burden of these applications.","title":"i. Incentives to modernize"},{"location":"appmod/2/#ii-websphere-legacy-code","text":"First, examine the legacy code (below), which as mentioned previously is a snapshot of a larger application using WebSphere EAR configuration : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <!-- application.xml --> <application> <module> <web> <web-uri> legacyapp.war </web-uri> <context-root> /legacyapp </context-root> </web> </module> <module> <ejb> legacyEJB.jar </ejb> </module> <security-role> <role-name> user </role-name> </security-role> </application> <!-- ibm-web-bnd.xml --> <web-bnd> <virtual-host name= \"default_host\" /> <resource-ref name= \"jdbc/LegacyDS\" binding-name= \"jdbc/LegacyDS\" /> </web-bnd> The application defines two modules\u2014 legacyapp.war and legacyEJB.jar \u2014which denote the web and EJB components of the application, respectively ( lines 5 and 10 ). The code sets a specific context root to access the legacyapp.war web module. It also introduces WebSphere-specific bindings such as ibm-web-bnd.xml ( line 17 ), which are employed for virtual hosting and resource references. Security roles and resource bindings are managed externally through the use of XML. The legacy code showcased above has a particular structural element that makes it a prime candidate for this type of Liberty modernization. Chiefly, the EAR application uses separate XML descriptors like application.xml ( line 1 ) and ibm-web-bnd.xml ( line 17 ) to define distinct modules. This setup, at enterprise scale, becomes cumbersome to maintain and can often result in frequent deployment delays (or human-induced configuration errors) each time the modules need to be modified. The maintenance burden of this more intricate structural design can be reduced with a more simplified, Liberty-based approach.","title":"ii. WebSphere legacy code"},{"location":"appmod/2/#iii-liberty-modernized-code","text":"Consider the modernized (functionally equivalent) code using Liberty WAR configuration : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 <!-- server.xml --> <server> <featureManager> <feature> webProfile-8.0 </feature> <feature> jdbc-4.2 </feature> </featureManager> <httpEndpoint host= \"*\" httpPort= \"9080\" httpsPort= \"9443\" /> <application id= \"modernapp\" location= \"modernapp.war\" context-root= \"/modernapp\" > <classloader delegation= \"parentLast\" /> </application> <dataSource id= \"jdbc/ModernDS\" jndiName= \"jdbc/ModernDS\" > <jdbcDriver libraryRef= \"jdbcLib\" /> <connectionManager maxPoolSize= \"50\" /> </dataSource> <library id= \"jdbcLib\" > <fileset dir= \"${server.config.dir}/jdbc\" includes= \"*.jar\" /> </library> </server> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <!-- application.xml --> <application> <module> <web> <web-uri> legacyapp.war </web-uri> <context-root> /legacyapp </context-root> </web> </module> <module> <ejb> legacyEJB.jar </ejb> </module> <security-role> <role-name> user </role-name> </security-role> </application> <!-- ibm-web-bnd.xml --> <web-bnd> <virtual-host name= \"default_host\" /> <resource-ref name= \"jdbc/LegacyDS\" binding-name= \"jdbc/LegacyDS\" /> </web-bnd> BREVITY: DISPELLING MODERNIZATION MISCONCEPTIONS The Liberty application code snippet is in fact \"longer\", in terms of lines of code, than the legacy WAS predecessor application. This raises an important point about modernized application code: the brevity and terseness of an application's code does not always reflect more efficient or practical code. What is important to the success and value of modernization efforts is that the new code is more appropriate to the tasks to be performed, has greater efficacy than before, and is more easily maintained \u2014 or a combination of these factors. Whether that is achieved in fewer lines of code than before is ultimately far less important. The modernized Liberty application code streamlines the original WebSphere configuration details into a single WAR file ( server.xml ) with clear, unified definitions. JDBC configurations are directly defined alongside the application deployment, removing the need for external bindings. Legacy EAR files have been consolidated into lightweight Web Archive (WAR) structures. WebSphere-specific descriptors like ibm-web-bnd.xml have been converted into modern Liberty features ( webProfile-8.0 , jdbc-4.2 ). WebSphere-specific APIs and deprecated components, like AdminClient APIs or Java Naming and Directory Interface (JDNI) look-ups, have been replaced. Liberty WAR configuration file uses parentLast ( line 11 ) class loading to ensure that the application's resources take precedence. <application id= \"modernapp\" location= \"modernapp.war\" context-root= \"/modernapp\" > <classloader delegation= \"parentLast\" /> </application> Ultimately, the modernized Liberty application code supports Lariat's objectives of simplified, modular deployment structures that reduce the overhead and technical burdens placed on developers maintaining the legacy WebSphere code base.","title":"iii. Liberty modernized code"},{"location":"appmod/2/#iv-hands-on-with-wca","text":"SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <!-- application.xml --> <application> <module> <web> <web-uri> legacyapp.war </web-uri> <context-root> /legacyapp </context-root> </web> </module> <module> <ejb> legacyEJB.jar </ejb> </module> <security-role> <role-name> user </role-name> </security-role> </application> <!-- ibm-web-bnd.xml --> <web-bnd> <virtual-host name= \"default_host\" /> <resource-ref name= \"jdbc/LegacyDS\" binding-name= \"jdbc/LegacyDS\" /> </web-bnd> After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY server.xml WCA LIBERTY web.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 <server description= \"new server\" > <featureManager> <feature> jsp-2.3 </feature> <feature> servlet-3.1 </feature> <feature> ejbLite-3.2 </feature> </featureManager> <httpEndpoint id= \"defaultHttpEndpoint\" host= \"*\" httpPort= \"9080\" httpsPort= \"9443\" /> <webApplication location= \"path/to/legacyapp.war\" name= \"legacyapp\" > <context-root> /legacyapp </context-root> <classLoader commonLibraryRef= \"LibertyBasicCL\" /> </webApplication> <basicRegistry id= \"LibertyBasicCL\" realm= \"LibertyBasicRealm\" > <user name= \"admin\" password= \"adminPassword\" /> </basicRegistry> <login-config> <auth-method> BASIC </auth-method> </login-config> <realm name= \"LibertyBasicRealm\" realm-name= \"LibertyBasicRealm\" > <users file= \"path/to/users.properties\" /> <groups file= \"path/to/groups.properties\" /> </realm> <jdbcDriver libraryRef= \"DefaultDataSource\" /> <dataSource jndiName= \"jdbc/LegacyDS\" id= \"DefaultDataSource\" > <jdbcDriver libraryRef= \"XADatabase\" /> <properties.db2.jcc databaseName= \"yourDatabaseName\" serverName= \"yourServerName\" portNumber= \"yourPortNumber\" /> </dataSource> </server> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <web-app xmlns= \"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version= \"3.1\" > <resource-ref> <description> Legacy Data Source </description> <res-ref-name> jdbc/LegacyDS </res-ref-name> <res-type> javax.sql.DataSource </res-type> <res-auth> Container </res-auth> </resource-ref> <security-role> <role-name> user </role-name> </security-role> </web-app> Let's first examine the use of WebSphere and Liberty-specific features . Lariat makes use of the webProfile-8.0 bundle set for servlets and Enterprise JavaBeans: <featureManager> <feature> webProfile-8.0 </feature> <feature> jdbc-4.2 </feature> </featureManager> By contrast, WCA has explicitly pulled in individual features like jsp-2.3 , servlet-3.1 , and ejbLite-3.2 which provides finer control over imports - avoiding unnecessary bloat. <featureManager> <feature> jsp-2.3 </feature> <feature> servlet-3.1 </feature> <feature> ejbLite-3.2 </feature> </featureManager> Security configuration is another area in which WCA has outperformed Lariat's modernization efforts. For Lariat, no authentication or user realm is configured. By contrast, WCA implements BASIC authentication, user and group registries, login, and custom realm with external property files. Security best-practices have been tuned and baked directly into the AI-generated code recommendations produced by WCA. <basicRegistry id= \"LibertyBasicCL\" realm= \"LibertyBasicRealm\" > <user name= \"admin\" password= \"adminPassword\" /> </basicRegistry> <login-config> <auth-method> BASIC </auth-method> </login-config> <realm name= \"LibertyBasicRealm\" realm-name= \"LibertyBasicRealm\" > <users file= \"path/to/users.properties\" /> <groups file= \"path/to/groups.properties\" /> </realm> DataSource configuration is arguably a toss-up between either version, depending on an organization's goals. Lariat's code has been structured for portability and is decoupled from any specific database: <dataSource id= \"jdbc/ModernDS\" jndiName= \"jdbc/ModernDS\" > <jdbcDriver libraryRef= \"jdbcLib\" /> <connectionManager maxPoolSize= \"50\" /> </dataSource> WCA's recommendation utilizes an IBM Db2-specific set of JDBC drivers. For clients with a highly-regulated, Db2-heavy enterprise environment, this code recommendation has much more utility to the requirements of their business: <dataSource jndiName= \"jdbc/LegacyDS\" id= \"DefaultDataSource\" > <jdbcDriver libraryRef= \"XADatabase\" /> <properties.db2.jcc ... /> </dataSource>","title":"iv. Hands-on with WCA"},{"location":"appmod/2/#v-next-steps","text":"In the following module, participants will examine how to modernize legacy WebSphere Application Server code for configuration and dependency management.","title":"v. Next steps"},{"location":"appmod/3/","text":"Configuration and dependency management Application Modernization - WebSphere to Liberty i. Incentives to modernize SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". In order to perform configuration and dependency management, Lariat Corporation employs various WebSphere class loader configurations to exert control over how Java classes and libraries are accessed by applications. In essence, these class loaders help define the scope and visibility of Java classes, resources, and libraries that are available for use by those applications. Legacy applications built for WAS can use class loader configurations in a variety of ways, including: Isolation of application dependencies: provide assurances that applications avoid conflicts or unintended interactions that might arise from using shared libraries Application module management: for WebSphere Enterprise Archive (EAR) applications, like those covered in the previous section, class loader configurations can manage the visibility of classes across different modules of the same EAR file In addition, the ability to selectively control class loading can reduce the overall memory footprint and resource overhead of an application. The result is that class loader configurations play an important part for managing dependency conflicts and application stability across Lariat's WAS services and environments. Feature WebSphere class loader configuration Liberty server configuration Configuration Complexity High: hierarchical and administration-intensive. Low: concise and self-contained. Maintainability Configuration tends to be dispersed, raising difficulties with maintenance. Clear and concise, only need to maintain a single configuration file. Developer Productivity Lowered due to administrative overhead, high probability of class-loading conflicts. Raised due to minimal overhead and reduced likelihood of human-introduced errors from single source of truth. Scalability Difficult to scale due to potential for complex sets of dependencies. Rapidly scaled due to cloud-native design. Lariat's legacy WebSphere class loader configuration implementation suffers from significant (and unnecessary) complexity owing to bloated class-loader configurations. Multiple shared libraries need to be configured and adjusted via an admin console, resulting in redundant use of dependencies and libraries that could otherwise be shared with better design. Through modernization of the code to Liberty server configuration , the expectation is that the process of managing dependencies and application configuration can be simplified and more easily maintained. ii. WebSphere legacy code First, examine the legacy code (below), which as mentioned previously is a snapshot of a larger application using WebSphere class loader configuration : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <!-- deployment.xml --> <deployment> <classloader mode= \"PARENT_LAST\" > <library> <file path= \"/shared/libs/customlib.jar\" /> </library> <shared-library name= \"LegacySharedLib\" /> </classloader> </deployment> <!-- shared-libraries.xml --> <shared-libraries> <library name= \"LegacySharedLib\" > <files> <file> /opt/was/shared/lib/shared-legacy.jar </file> </files> </library> </shared-libraries> The legacy implementation utilizes separate, detailed descriptor files like deployment.xml ( lines 1-9 ) and shared-libraries.xml ( lines 11-18 ) to handle complex dependency and class-loading configurations. Lariat administrators who manage this code base must explicitly set class loader modes to control resource loading order \u2014 an inefficient, manual process achieved using the PARENT_LAST option. As a consequence, libraries that should ideally be shared by multiple applications instead need to be managed separately by each application in turn. This is terribly inefficient and produces needlessly complex classloader configurations. For Lariat's administrators, this approach to configuration and dependency management has frequently resulted in version conflicts for applications and complex debugging work for developers. iii. Liberty modernized code Consider below the modernized (but functionally equivalent) application code using Liberty server configuration : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <!-- server.xml --> <server> <featureManager> <feature> webProfile-8.0 </feature> </featureManager> <library id= \"customLib\" > <fileset dir= \"${server.config.dir}/shared/libs\" includes= \"*.jar\" /> </library> <application location= \"modernized.war\" > <classloader delegation= \"parentLast\" > <commonLibrary> <library ref= \"customLib\" /> </commonLibrary> </classloader> </application> </server> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <!-- deployment.xml --> <deployment> <classloader mode= \"PARENT_LAST\" > <library> <file path= \"/shared/libs/customlib.jar\" /> </library> <shared-library name= \"LegacySharedLib\" /> </classloader> </deployment> <!-- shared-libraries.xml --> <shared-libraries> <library name= \"LegacySharedLib\" > <files> <file> /opt/was/shared/lib/shared-legacy.jar </file> </files> </library> </shared-libraries> The modernized Liberty code implementation simplifies the management of dependencies by removing the discrete (separate) descriptors like deployment.xml and shared-libraries.xml from the WAS implementation. Instead, configuration and dependency management has been consolidated into a single server.xml descriptor, which more clearly defines the permitted libraries and their associated paths. Other benefits from the modernization work also include: Class loading policies (such as 'parentLast' on line 12 ) are now explicitly stated, helping to simplify the process of resource management for developers drawing from these resources. <classloader delegation= \"parentLast\" > <commonLibrary> <library ref= \"customLib\" /> </commonLibrary> </classloader> Dependencies are now directly tied and associated to applications, creating relationships between the two that are more transparent and easier to maintain. Ultimately, the modernization process into Liberty has resulted in configuration and dependency management that reduces dependency conflicts, simplifies resource management, and improves the overall clarity and maintainability of these assets going forward. iv. Hands-on with WCA SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <!-- deployment.xml --> <deployment> <classloader mode= \"PARENT_LAST\" > <library> <file path= \"/shared/libs/customlib.jar\" /> </library> <shared-library name= \"LegacySharedLib\" /> </classloader> </deployment> <!-- shared-libraries.xml --> <shared-libraries> <library name= \"LegacySharedLib\" > <files> <file> /opt/was/shared/lib/shared-legacy.jar </file> </files> </library> </shared-libraries> After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY server.xml WCA LIBERTY shared-library.xml 1 2 3 4 5 6 7 8 9 <server description= \"new server\" > <featureManager> <feature> jsp-2.3 </feature> <feature> servlet-3.1 </feature> </featureManager> <httpEndpoint id= \"defaultHttpEndpoint\" host= \"*\" httpPort= \"9080\" httpsPort= \"9443\" /> <sharedLibrary id= \"LegacySharedLib\" location= \"path/to/shared-legacy.jar\" /> <classLoader commonLibraryRef= \"LegacySharedLib\" /> </server> 1 2 3 4 5 6 7 <sharedLibraries> <library id= \"LegacySharedLib\" > <files> <file> path/to/customlib.jar </file> </files> </library> </sharedLibraries> At a glance, the newly-generated WCA code appears to be significantly more complex: splitting configuration organization across server.xml and shared-library.xml , rather than Lariat's consolidated server.xml approach. Not an encouraging start, but let's drill down into specific elements before making a final critique. In terms of encapsulation of necessary classes and libraries, Lariat's best-practices Liberty code outshines WCA's Liberty recommendations. Consider the following slice of Lariat's modernized code: <library id= \"customLib\" > <fileset dir= \"${server.config.dir}/shared/libs\" includes= \"*.jar\" /> </library> <classloader delegation= \"parentLast\" > <commonLibrary> <library ref= \"customLib\" /> </commonLibrary> </classloader> The code's Classloader has been limited in scope only to the deployed WAR: parentLast ensures that the application's classes override any shared ones, which is generally the \"safer\" approach to take for modernization of legacy applications. Contrast that to WCA's approach: <sharedLibrary id= \"LegacySharedLib\" location= \"path/to/shared-legacy.jar\" /> <classLoader commonLibraryRef= \"LegacySharedLib\" /> ... <sharedLibraries> <library id= \"LegacySharedLib\" > <files> <file> path/to/customlib.jar </file> </files> </library> </sharedLibraries> WCA uses a global scoped Classloader which will impact all applications in the environment PATH. The implementation is also slightly confusing to look at and redundant in design \u2014 LegacySharedLib has been declared twice in the highlighted code. Lastly, on the topic of application deployments , Lariat's code base has explicit WAR deployment instructions built into the server.xml configuration file: <application location= \"modernized.war\" > <classloader delegation= \"parentLast\" > <commonLibrary> <library ref= \"customLib\" /> </commonLibrary> </classloader> </application> Conversely, WCA's modernized Liberty code recommendations do not include a WAR deployment instruction set. This may be an artifact of the original WAS script (submitted in Step 4) that was only a snippet of the larger application \u2014 and therefore not indicative of a full-fledged, end to end application. As a result, WCA's recommendation does not include WAR deployment definitions which would be needed to actually load an application. v. Next steps In the following module, participants will examine how to modernize legacy WebSphere Application Server APIs and libraries.","title":"3. Configuration management"},{"location":"appmod/3/#configuration-and-dependency-managementapplication-modernization-websphere-to-liberty","text":"","title":"Configuration and dependency managementApplication Modernization - WebSphere to Liberty"},{"location":"appmod/3/#i-incentives-to-modernize","text":"SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". In order to perform configuration and dependency management, Lariat Corporation employs various WebSphere class loader configurations to exert control over how Java classes and libraries are accessed by applications. In essence, these class loaders help define the scope and visibility of Java classes, resources, and libraries that are available for use by those applications. Legacy applications built for WAS can use class loader configurations in a variety of ways, including: Isolation of application dependencies: provide assurances that applications avoid conflicts or unintended interactions that might arise from using shared libraries Application module management: for WebSphere Enterprise Archive (EAR) applications, like those covered in the previous section, class loader configurations can manage the visibility of classes across different modules of the same EAR file In addition, the ability to selectively control class loading can reduce the overall memory footprint and resource overhead of an application. The result is that class loader configurations play an important part for managing dependency conflicts and application stability across Lariat's WAS services and environments. Feature WebSphere class loader configuration Liberty server configuration Configuration Complexity High: hierarchical and administration-intensive. Low: concise and self-contained. Maintainability Configuration tends to be dispersed, raising difficulties with maintenance. Clear and concise, only need to maintain a single configuration file. Developer Productivity Lowered due to administrative overhead, high probability of class-loading conflicts. Raised due to minimal overhead and reduced likelihood of human-introduced errors from single source of truth. Scalability Difficult to scale due to potential for complex sets of dependencies. Rapidly scaled due to cloud-native design. Lariat's legacy WebSphere class loader configuration implementation suffers from significant (and unnecessary) complexity owing to bloated class-loader configurations. Multiple shared libraries need to be configured and adjusted via an admin console, resulting in redundant use of dependencies and libraries that could otherwise be shared with better design. Through modernization of the code to Liberty server configuration , the expectation is that the process of managing dependencies and application configuration can be simplified and more easily maintained.","title":"i. Incentives to modernize"},{"location":"appmod/3/#ii-websphere-legacy-code","text":"First, examine the legacy code (below), which as mentioned previously is a snapshot of a larger application using WebSphere class loader configuration : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <!-- deployment.xml --> <deployment> <classloader mode= \"PARENT_LAST\" > <library> <file path= \"/shared/libs/customlib.jar\" /> </library> <shared-library name= \"LegacySharedLib\" /> </classloader> </deployment> <!-- shared-libraries.xml --> <shared-libraries> <library name= \"LegacySharedLib\" > <files> <file> /opt/was/shared/lib/shared-legacy.jar </file> </files> </library> </shared-libraries> The legacy implementation utilizes separate, detailed descriptor files like deployment.xml ( lines 1-9 ) and shared-libraries.xml ( lines 11-18 ) to handle complex dependency and class-loading configurations. Lariat administrators who manage this code base must explicitly set class loader modes to control resource loading order \u2014 an inefficient, manual process achieved using the PARENT_LAST option. As a consequence, libraries that should ideally be shared by multiple applications instead need to be managed separately by each application in turn. This is terribly inefficient and produces needlessly complex classloader configurations. For Lariat's administrators, this approach to configuration and dependency management has frequently resulted in version conflicts for applications and complex debugging work for developers.","title":"ii. WebSphere legacy code"},{"location":"appmod/3/#iii-liberty-modernized-code","text":"Consider below the modernized (but functionally equivalent) application code using Liberty server configuration : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <!-- server.xml --> <server> <featureManager> <feature> webProfile-8.0 </feature> </featureManager> <library id= \"customLib\" > <fileset dir= \"${server.config.dir}/shared/libs\" includes= \"*.jar\" /> </library> <application location= \"modernized.war\" > <classloader delegation= \"parentLast\" > <commonLibrary> <library ref= \"customLib\" /> </commonLibrary> </classloader> </application> </server> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <!-- deployment.xml --> <deployment> <classloader mode= \"PARENT_LAST\" > <library> <file path= \"/shared/libs/customlib.jar\" /> </library> <shared-library name= \"LegacySharedLib\" /> </classloader> </deployment> <!-- shared-libraries.xml --> <shared-libraries> <library name= \"LegacySharedLib\" > <files> <file> /opt/was/shared/lib/shared-legacy.jar </file> </files> </library> </shared-libraries> The modernized Liberty code implementation simplifies the management of dependencies by removing the discrete (separate) descriptors like deployment.xml and shared-libraries.xml from the WAS implementation. Instead, configuration and dependency management has been consolidated into a single server.xml descriptor, which more clearly defines the permitted libraries and their associated paths. Other benefits from the modernization work also include: Class loading policies (such as 'parentLast' on line 12 ) are now explicitly stated, helping to simplify the process of resource management for developers drawing from these resources. <classloader delegation= \"parentLast\" > <commonLibrary> <library ref= \"customLib\" /> </commonLibrary> </classloader> Dependencies are now directly tied and associated to applications, creating relationships between the two that are more transparent and easier to maintain. Ultimately, the modernization process into Liberty has resulted in configuration and dependency management that reduces dependency conflicts, simplifies resource management, and improves the overall clarity and maintainability of these assets going forward.","title":"iii. Liberty modernized code"},{"location":"appmod/3/#iv-hands-on-with-wca","text":"SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <!-- deployment.xml --> <deployment> <classloader mode= \"PARENT_LAST\" > <library> <file path= \"/shared/libs/customlib.jar\" /> </library> <shared-library name= \"LegacySharedLib\" /> </classloader> </deployment> <!-- shared-libraries.xml --> <shared-libraries> <library name= \"LegacySharedLib\" > <files> <file> /opt/was/shared/lib/shared-legacy.jar </file> </files> </library> </shared-libraries> After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY server.xml WCA LIBERTY shared-library.xml 1 2 3 4 5 6 7 8 9 <server description= \"new server\" > <featureManager> <feature> jsp-2.3 </feature> <feature> servlet-3.1 </feature> </featureManager> <httpEndpoint id= \"defaultHttpEndpoint\" host= \"*\" httpPort= \"9080\" httpsPort= \"9443\" /> <sharedLibrary id= \"LegacySharedLib\" location= \"path/to/shared-legacy.jar\" /> <classLoader commonLibraryRef= \"LegacySharedLib\" /> </server> 1 2 3 4 5 6 7 <sharedLibraries> <library id= \"LegacySharedLib\" > <files> <file> path/to/customlib.jar </file> </files> </library> </sharedLibraries> At a glance, the newly-generated WCA code appears to be significantly more complex: splitting configuration organization across server.xml and shared-library.xml , rather than Lariat's consolidated server.xml approach. Not an encouraging start, but let's drill down into specific elements before making a final critique. In terms of encapsulation of necessary classes and libraries, Lariat's best-practices Liberty code outshines WCA's Liberty recommendations. Consider the following slice of Lariat's modernized code: <library id= \"customLib\" > <fileset dir= \"${server.config.dir}/shared/libs\" includes= \"*.jar\" /> </library> <classloader delegation= \"parentLast\" > <commonLibrary> <library ref= \"customLib\" /> </commonLibrary> </classloader> The code's Classloader has been limited in scope only to the deployed WAR: parentLast ensures that the application's classes override any shared ones, which is generally the \"safer\" approach to take for modernization of legacy applications. Contrast that to WCA's approach: <sharedLibrary id= \"LegacySharedLib\" location= \"path/to/shared-legacy.jar\" /> <classLoader commonLibraryRef= \"LegacySharedLib\" /> ... <sharedLibraries> <library id= \"LegacySharedLib\" > <files> <file> path/to/customlib.jar </file> </files> </library> </sharedLibraries> WCA uses a global scoped Classloader which will impact all applications in the environment PATH. The implementation is also slightly confusing to look at and redundant in design \u2014 LegacySharedLib has been declared twice in the highlighted code. Lastly, on the topic of application deployments , Lariat's code base has explicit WAR deployment instructions built into the server.xml configuration file: <application location= \"modernized.war\" > <classloader delegation= \"parentLast\" > <commonLibrary> <library ref= \"customLib\" /> </commonLibrary> </classloader> </application> Conversely, WCA's modernized Liberty code recommendations do not include a WAR deployment instruction set. This may be an artifact of the original WAS script (submitted in Step 4) that was only a snippet of the larger application \u2014 and therefore not indicative of a full-fledged, end to end application. As a result, WCA's recommendation does not include WAR deployment definitions which would be needed to actually load an application.","title":"iv. Hands-on with WCA"},{"location":"appmod/3/#v-next-steps","text":"In the following module, participants will examine how to modernize legacy WebSphere Application Server APIs and libraries.","title":"v. Next steps"},{"location":"appmod/4/","text":"APIs and libraries Application Modernization - WebSphere to Liberty i. Incentives to modernize SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". Lariat Corporation's application stack utilizes a myriad of WebSphere Application Server APIs \u2014 Work Manager API, Async Beans, Scheduler API, and so on \u2014which will likely be impacted and require remediation as part of the company's overall modernization towards WebSphere Liberty. WAS APIs may not be immediately portable in their current form, they are potentially more costly to maintain than their Liberty counterparts, and may have less functionality given their outdated implementations. Liberty-compatible APIs increase the portability of applications across different Java Enterprise Edition ( Java EE or Jakarta EE ) application servers. The result is that developers can more easily facilitate cloud deployments or migrations to other runtimes. Liberty APIs follow standardized annotations and conventions that simplify the boilerplate code needed for applications to exchange data with these APIs. WAS-specific APIs, by contrast, are potentially locked to specific versions of WebSphere - which in turn \"lock in\" the applications dependent on such APIs. Feature WebSphere Scheduler API Liberty's Jakarta EE-templated APIs Standardization Built on proprietary WebSphere-only APIs. Built on industry-standardized Jakarta EE APIs. More transferable across vendors and platforms. Cloud-Readiness Tied to traditional WebSphere Application Server only. Cloud-native architecture by design and portable to containers. Developer Productivity Complex setup requiring use of admin console and external XML definitions. Declarative and code-driven with Java annotations. Currently, Lariat's WebSphere Scheduler APIs rely upon IBM-specific extensions (such as .com.ibm.websphere packages) that will need to be identified and remediated before modernization with Liberty's Jakarta EE-templated APIs . The shift from proprietary WAS-based APIs to standardized Liberty-based APIs (built to Jakarta EE / Java EE specifications) should improve application portability and align with industry best practices. ii. WebSphere legacy code First, examine the legacy Java code (below), which as mentioned previously is a snapshot of a larger application using WebSphere Scheduler API : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import com.ibm.websphere.scheduler.TaskHandler ; import com.ibm.websphere.scheduler.Scheduler ; import javax.naming.InitialContext ; public class LegacySchedulerTask { public void scheduleTask () throws Exception { InitialContext ctx = new InitialContext (); Scheduler scheduler = ( Scheduler ) ctx . lookup ( \"scheduler/legacyScheduler\" ); TaskHandler handler = scheduler . createTaskHandler ( \"TaskName\" , new LegacyTask (), null , \"0 0/5 * * * ?\" , true , null ); handler . start (); } } The LegacySchedulerTask API describes a WAS-specific scheduler (identifiable by the com.ibm.websphere.scheduler import statements on lines 1 and 2 ), which invokes IBM-proprietary API standards. These API invocations are in turn used to schedule periodic task executions within Lariat's application estate. import com.ibm.websphere.scheduler.TaskHandler ; import com.ibm.websphere.scheduler.Scheduler ; Utilizing WAS-specific API calls requires explicit JNDI (Java Naming and Directory Interface) look-ups. Furthermore, it demands manual intervention on the part of application developers to create and manage scheduled API tasks. The result is that this legacy API code, by placing heavy reliance upon WebSphere platform-specific APIs, has impaired the portability of applications. iii. Liberty modernized code Consider below the modernized (but functionally equivalent) Java code in support of Liberty's Jakarta EE-templated APIs : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import javax.annotation.Resource ; import javax.enterprise.context.ApplicationScoped ; import javax.enterprise.concurrent.ManagedScheduledExecutorService ; import java.util.concurrent.TimeUnit ; @ApplicationScoped public class ModernSchedulerTask { @Resource ManagedScheduledExecutorService executor ; public void scheduleTask () { executor . scheduleAtFixedRate ( () -> { // Modern task logic here System . out . println ( \"Executing scheduled task.\" ); }, 0 , 5 , TimeUnit . MINUTES ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import com.ibm.websphere.scheduler.TaskHandler ; import com.ibm.websphere.scheduler.Scheduler ; import javax.naming.InitialContext ; public class LegacySchedulerTask { public void scheduleTask () throws Exception { InitialContext ctx = new InitialContext (); Scheduler scheduler = ( Scheduler ) ctx . lookup ( \"scheduler/legacyScheduler\" ); TaskHandler handler = scheduler . createTaskHandler ( \"TaskName\" , new LegacyTask (), null , \"0 0/5 * * * ?\" , true , null ); handler . start (); } } In contrast to the legacy WAS-based Java API, the modernized Liberty approach (templated using Jakarta EE's API conventions) significantly simplifies the scheduling logic. The standardized ManagedScheduledExecutorService API for concurrency simplifies the scheduling of tasks using direct resource injection, as indicated by @Resource beginning on line 9 . @Resource ManagedScheduledExecutorService executor ; The previous (legacy) requirement of forcing JNDI look-ups, therefore, has been remediated through the use of direct resource injection. The Jakarta EE standard also follows an annotation-driven model for scheduling tasks to reduce the overall complexity of the code and improve its \"readability\" for human developers. Ultimately, the modernization efforts have significantly increased the portability and extensibility of Lariat's API-driven application estate. The structure of the API code has been simplified and made much more portable by breaking away from propriety API standards. iv. Hands-on with WCA SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import com.ibm.websphere.scheduler.TaskHandler ; import com.ibm.websphere.scheduler.Scheduler ; import javax.naming.InitialContext ; public class LegacySchedulerTask { public void scheduleTask () throws Exception { InitialContext ctx = new InitialContext (); Scheduler scheduler = ( Scheduler ) ctx . lookup ( \"scheduler/legacyScheduler\" ); TaskHandler handler = scheduler . createTaskHandler ( \"TaskName\" , new LegacyTask (), null , \"0 0/5 * * * ?\" , true , null ); handler . start (); } } After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY server.xml Part 1 WCA LIBERTY server.xml Part 2 WCA LIBERTY server.xml Part 3 1 2 3 4 5 6 7 // Enable the Scheduler feature: // In your server.xml file, add the scheduler-1.0 feature to the featureManager section. < featureManager > < feature > jsp - 2.3 </ feature > < feature > servlet - 3.1 </ feature > < feature > scheduler - 1.0 </ feature > </ featureManager > 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Update the task class: // Create a new class that implements the com.ibm.websphere.scheduler.Task interface. import com.ibm.websphere.scheduler.Task ; import javax.naming.InitialContext ; import javax.naming.NamingException ; public class LegacyTask implements Task { private static final String TASK_NAME = \"TaskName\" ; private static final String CRON_EXPRESSION = \"0 0/5 * * * ?\" ; @Override public void execute () throws Exception { // Your task logic here } @Override public String getName () { return TASK_NAME ; } @Override public String getCronExpression () { return CRON_EXPRESSION ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Update the scheduler configuration: // In your server.xml file, add a scheduler element to configure the scheduler. < scheduler id = \"legacyScheduler\" > < property name = \"cronExpression\" value = \"0 0/5 * * * ?\" /> < property name = \"initialDelay\" value = \"0\" /> < property name = \"period\" value = \"0\" /> < property name = \"timeZone\" value = \"UTC\" /> </ scheduler > Update the task scheduling code : Modify the scheduleTask method to use the Liberty Scheduler API . // Update the task scheduling code: // Modify the scheduleTask method to use the Liberty Scheduler API. import com.ibm.websphere.scheduler.Scheduler ; import javax.naming.InitialContext ; import javax.naming.NamingException ; public class LegacySchedulerTask { public void scheduleTask () throws Exception { InitialContext ctx = new InitialContext (); Scheduler scheduler = ( Scheduler ) ctx . lookup ( \"scheduler/legacyScheduler\" ); scheduler . schedule ( new LegacyTask (), null ); } } The first thing to note is that Lariat and WCA have taken two fundamentally different scheduling approaches on their respective WebSphere Liberty codebases. In the case of Lariat, the team implemented the standardized Jakarta EE API with the intent of keeping the code as portable as possible: @Resource ManagedScheduledExecutorService executor ; WCA recommended the use of com.ibm.websphere.scheduler.Scheduler and Task interfaces, which require a CRON expression in the XML descriptor and additional code lookups for Scheduler : <scheduler id= \"legacyScheduler\" > <property name= \"cronExpression\" value= \"0 0/5 * * * ?\" /> <property name= \"initialDelay\" value= \"0\" /> <property name= \"period\" value= \"0\" /> <property name= \"timeZone\" value= \"UTC\" /> </scheduler> The WCA solution is arguably stronger in scenarios where complex scheduling tasks are anticipated, given the granularity of control that CRON offers with regular expression matching. The Lariat solution is simpler, but limited in terms of customizability. In terms of portability of the Liberty codebase, Lariat's implementation has been designed around Jakarta EE 's API which provides simple mobility across nearly every Java EE-compliant runtime. WCA's recommendation to use the Scheduler API (a proprietary Liberty) format ensures full compatibility with WebSphere Liberty endpoints \u2014 which, as you will recall, the request to WCA was explicitly to modernize to Liberty . But the use of Scheduler also poses a potential lock-in risk for that particular distribution, to the exclusion of others. v. Next steps In the following module, participants will examine how to modernize legacy WebSphere Application Server code for Enterprise JavaBeans.","title":"4. APIs and libraries"},{"location":"appmod/4/#apis-and-librariesapplication-modernization-websphere-to-liberty","text":"","title":"APIs and librariesApplication Modernization - WebSphere to Liberty"},{"location":"appmod/4/#i-incentives-to-modernize","text":"SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". Lariat Corporation's application stack utilizes a myriad of WebSphere Application Server APIs \u2014 Work Manager API, Async Beans, Scheduler API, and so on \u2014which will likely be impacted and require remediation as part of the company's overall modernization towards WebSphere Liberty. WAS APIs may not be immediately portable in their current form, they are potentially more costly to maintain than their Liberty counterparts, and may have less functionality given their outdated implementations. Liberty-compatible APIs increase the portability of applications across different Java Enterprise Edition ( Java EE or Jakarta EE ) application servers. The result is that developers can more easily facilitate cloud deployments or migrations to other runtimes. Liberty APIs follow standardized annotations and conventions that simplify the boilerplate code needed for applications to exchange data with these APIs. WAS-specific APIs, by contrast, are potentially locked to specific versions of WebSphere - which in turn \"lock in\" the applications dependent on such APIs. Feature WebSphere Scheduler API Liberty's Jakarta EE-templated APIs Standardization Built on proprietary WebSphere-only APIs. Built on industry-standardized Jakarta EE APIs. More transferable across vendors and platforms. Cloud-Readiness Tied to traditional WebSphere Application Server only. Cloud-native architecture by design and portable to containers. Developer Productivity Complex setup requiring use of admin console and external XML definitions. Declarative and code-driven with Java annotations. Currently, Lariat's WebSphere Scheduler APIs rely upon IBM-specific extensions (such as .com.ibm.websphere packages) that will need to be identified and remediated before modernization with Liberty's Jakarta EE-templated APIs . The shift from proprietary WAS-based APIs to standardized Liberty-based APIs (built to Jakarta EE / Java EE specifications) should improve application portability and align with industry best practices.","title":"i. Incentives to modernize"},{"location":"appmod/4/#ii-websphere-legacy-code","text":"First, examine the legacy Java code (below), which as mentioned previously is a snapshot of a larger application using WebSphere Scheduler API : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import com.ibm.websphere.scheduler.TaskHandler ; import com.ibm.websphere.scheduler.Scheduler ; import javax.naming.InitialContext ; public class LegacySchedulerTask { public void scheduleTask () throws Exception { InitialContext ctx = new InitialContext (); Scheduler scheduler = ( Scheduler ) ctx . lookup ( \"scheduler/legacyScheduler\" ); TaskHandler handler = scheduler . createTaskHandler ( \"TaskName\" , new LegacyTask (), null , \"0 0/5 * * * ?\" , true , null ); handler . start (); } } The LegacySchedulerTask API describes a WAS-specific scheduler (identifiable by the com.ibm.websphere.scheduler import statements on lines 1 and 2 ), which invokes IBM-proprietary API standards. These API invocations are in turn used to schedule periodic task executions within Lariat's application estate. import com.ibm.websphere.scheduler.TaskHandler ; import com.ibm.websphere.scheduler.Scheduler ; Utilizing WAS-specific API calls requires explicit JNDI (Java Naming and Directory Interface) look-ups. Furthermore, it demands manual intervention on the part of application developers to create and manage scheduled API tasks. The result is that this legacy API code, by placing heavy reliance upon WebSphere platform-specific APIs, has impaired the portability of applications.","title":"ii. WebSphere legacy code"},{"location":"appmod/4/#iii-liberty-modernized-code","text":"Consider below the modernized (but functionally equivalent) Java code in support of Liberty's Jakarta EE-templated APIs : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import javax.annotation.Resource ; import javax.enterprise.context.ApplicationScoped ; import javax.enterprise.concurrent.ManagedScheduledExecutorService ; import java.util.concurrent.TimeUnit ; @ApplicationScoped public class ModernSchedulerTask { @Resource ManagedScheduledExecutorService executor ; public void scheduleTask () { executor . scheduleAtFixedRate ( () -> { // Modern task logic here System . out . println ( \"Executing scheduled task.\" ); }, 0 , 5 , TimeUnit . MINUTES ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import com.ibm.websphere.scheduler.TaskHandler ; import com.ibm.websphere.scheduler.Scheduler ; import javax.naming.InitialContext ; public class LegacySchedulerTask { public void scheduleTask () throws Exception { InitialContext ctx = new InitialContext (); Scheduler scheduler = ( Scheduler ) ctx . lookup ( \"scheduler/legacyScheduler\" ); TaskHandler handler = scheduler . createTaskHandler ( \"TaskName\" , new LegacyTask (), null , \"0 0/5 * * * ?\" , true , null ); handler . start (); } } In contrast to the legacy WAS-based Java API, the modernized Liberty approach (templated using Jakarta EE's API conventions) significantly simplifies the scheduling logic. The standardized ManagedScheduledExecutorService API for concurrency simplifies the scheduling of tasks using direct resource injection, as indicated by @Resource beginning on line 9 . @Resource ManagedScheduledExecutorService executor ; The previous (legacy) requirement of forcing JNDI look-ups, therefore, has been remediated through the use of direct resource injection. The Jakarta EE standard also follows an annotation-driven model for scheduling tasks to reduce the overall complexity of the code and improve its \"readability\" for human developers. Ultimately, the modernization efforts have significantly increased the portability and extensibility of Lariat's API-driven application estate. The structure of the API code has been simplified and made much more portable by breaking away from propriety API standards.","title":"iii. Liberty modernized code"},{"location":"appmod/4/#iv-hands-on-with-wca","text":"SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import com.ibm.websphere.scheduler.TaskHandler ; import com.ibm.websphere.scheduler.Scheduler ; import javax.naming.InitialContext ; public class LegacySchedulerTask { public void scheduleTask () throws Exception { InitialContext ctx = new InitialContext (); Scheduler scheduler = ( Scheduler ) ctx . lookup ( \"scheduler/legacyScheduler\" ); TaskHandler handler = scheduler . createTaskHandler ( \"TaskName\" , new LegacyTask (), null , \"0 0/5 * * * ?\" , true , null ); handler . start (); } } After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY server.xml Part 1 WCA LIBERTY server.xml Part 2 WCA LIBERTY server.xml Part 3 1 2 3 4 5 6 7 // Enable the Scheduler feature: // In your server.xml file, add the scheduler-1.0 feature to the featureManager section. < featureManager > < feature > jsp - 2.3 </ feature > < feature > servlet - 3.1 </ feature > < feature > scheduler - 1.0 </ feature > </ featureManager > 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Update the task class: // Create a new class that implements the com.ibm.websphere.scheduler.Task interface. import com.ibm.websphere.scheduler.Task ; import javax.naming.InitialContext ; import javax.naming.NamingException ; public class LegacyTask implements Task { private static final String TASK_NAME = \"TaskName\" ; private static final String CRON_EXPRESSION = \"0 0/5 * * * ?\" ; @Override public void execute () throws Exception { // Your task logic here } @Override public String getName () { return TASK_NAME ; } @Override public String getCronExpression () { return CRON_EXPRESSION ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Update the scheduler configuration: // In your server.xml file, add a scheduler element to configure the scheduler. < scheduler id = \"legacyScheduler\" > < property name = \"cronExpression\" value = \"0 0/5 * * * ?\" /> < property name = \"initialDelay\" value = \"0\" /> < property name = \"period\" value = \"0\" /> < property name = \"timeZone\" value = \"UTC\" /> </ scheduler > Update the task scheduling code : Modify the scheduleTask method to use the Liberty Scheduler API . // Update the task scheduling code: // Modify the scheduleTask method to use the Liberty Scheduler API. import com.ibm.websphere.scheduler.Scheduler ; import javax.naming.InitialContext ; import javax.naming.NamingException ; public class LegacySchedulerTask { public void scheduleTask () throws Exception { InitialContext ctx = new InitialContext (); Scheduler scheduler = ( Scheduler ) ctx . lookup ( \"scheduler/legacyScheduler\" ); scheduler . schedule ( new LegacyTask (), null ); } } The first thing to note is that Lariat and WCA have taken two fundamentally different scheduling approaches on their respective WebSphere Liberty codebases. In the case of Lariat, the team implemented the standardized Jakarta EE API with the intent of keeping the code as portable as possible: @Resource ManagedScheduledExecutorService executor ; WCA recommended the use of com.ibm.websphere.scheduler.Scheduler and Task interfaces, which require a CRON expression in the XML descriptor and additional code lookups for Scheduler : <scheduler id= \"legacyScheduler\" > <property name= \"cronExpression\" value= \"0 0/5 * * * ?\" /> <property name= \"initialDelay\" value= \"0\" /> <property name= \"period\" value= \"0\" /> <property name= \"timeZone\" value= \"UTC\" /> </scheduler> The WCA solution is arguably stronger in scenarios where complex scheduling tasks are anticipated, given the granularity of control that CRON offers with regular expression matching. The Lariat solution is simpler, but limited in terms of customizability. In terms of portability of the Liberty codebase, Lariat's implementation has been designed around Jakarta EE 's API which provides simple mobility across nearly every Java EE-compliant runtime. WCA's recommendation to use the Scheduler API (a proprietary Liberty) format ensures full compatibility with WebSphere Liberty endpoints \u2014 which, as you will recall, the request to WCA was explicitly to modernize to Liberty . But the use of Scheduler also poses a potential lock-in risk for that particular distribution, to the exclusion of others.","title":"iv. Hands-on with WCA"},{"location":"appmod/4/#v-next-steps","text":"In the following module, participants will examine how to modernize legacy WebSphere Application Server code for Enterprise JavaBeans.","title":"v. Next steps"},{"location":"appmod/5/","text":"Enterprise JavaBeans (EJB) modernization Application Modernization - WebSphere to Liberty i. Incentives to modernize SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". WebSphere Enterprise JavaBeans ( EJB ) represent server-side components used by Java Enterprise Edition ( Java EE or Jakarta EE ) to encapsulate repeatable business logic. In turn, EJB can be used to provide scalable and highly performant handling for requests made by Lariat Corporation's web application estate. EJBs provide the resource access management for the databases, messaging services, and external APIs these such application require to power their business functions. WebSphere's EJBs make extensive use of XML deployment descriptors to configure their behavior. Liberty EJBs use Java annotations instead of XML , applying them directly within Java classes for configuration. In many cases, this eliminates the need for external XML files completely (or at least significantly reduces their size and number). Feature WebSphere EJB with XML Liberty EJB with annotations Maintainability Difficult due to scattered XML configs. Improved due to cohesive annotations. Readability Lower due to switching between Java and XML. Higher due to configuration directly in Java code. Productivity Lower due to manual XML edits. Higher due to rapid development through annotations. Error Propensity Higher chance of manual XML errors. Lower due to clear annotations and IDE checks. Modernizing WebSphere's EJB's stateless session beans into Liberty's standard-compliant EJB will provide Lariat with the net benefit of code that's easier to maintain, more portable, and extensible for modern cloud-native endpoints. Ultimately, this should yield a simplified developer experience and better resource management. ii. WebSphere legacy code First, examine the legacy code (below), which as mentioned previously is a snapshot of a larger application using WebSphere's EJB Stateful Session Bean with XML : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 <!-- ejb-jar.xml --> <ejb-jar> <enterprise-beans> <session> <ejb-name> LegacySessionBean </ejb-name> <home> com.lariat.ejb.LegacyHome </home> <remote> com.lariat.ejb.LegacyRemote </remote> <ejb-class> com.lariat.ejb.LegacySessionBean </ejb-class> <session-type> Stateless </session-type> <transaction-type> Container </transaction-type> </session> </enterprise-beans> </ejb-jar> The legacy EJB implementation uses XML ( ejb-jar.xml beginning on line 1 ) to explicitly define the contents of the stateful session bean. This requires that the <home> and <remote> interfaces be explicitly defined, along with the bean class. Transaction types and security are also configured externally via descriptors within the XML. iii. Liberty modernized code Consider below the modernized (but functionally equivalent) application code using Liberty's EJB Stateless Session Bean with annotations : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package com.lariat.ejb ; import javax.ejb.Stateless ; import javax.ejb.Remote ; @Stateless @Remote ( ModernRemote . class ) public class ModernSessionBean implements ModernRemote { @Override public String getGreeting ( String name ) { return \"Hello, \" + name + \"!\" ; } } package com.lariat.ejb ; import javax.ejb.Remote ; @Remote public interface ModernRemote { String getGreeting ( String name ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 <!-- ejb-jar.xml --> <ejb-jar> <enterprise-beans> <session> <ejb-name> LegacySessionBean </ejb-name> <home> com.lariat.ejb.LegacyHome </home> <remote> com.lariat.ejb.LegacyRemote </remote> <ejb-class> com.lariat.ejb.LegacySessionBean </ejb-class> <session-type> Stateless </session-type> <transaction-type> Container </transaction-type> </session> </enterprise-beans> </ejb-jar> The modernized Liberty code adopts EJB with Java annotations directly within the bean implementation; for example, utilizing such annotations as @Stateless beginning on line 6 : @Stateless @Remote ( ModernRemote . class ) public class ModernSessionBean implements ModernRemote { @Override public String getGreeting ( String name ) { return \"Hello, \" + name + \"!\" ; } } This approach also eliminates the need for explicit home interfaces, instead allowing Lariat's developers to directly specify remote interfaces within the bean definition. There are also positive side effects to the \"readability\" of the code \u2014 since transaction management and security settings are managed via annotations, the amount of XML overhead is reduced and thus the code can be more easily parsed (and maintained) by humans. Ultimately, Liberty's modernized EJB implementation simplifies the bean declaration significantly and reduces the amount of boilerplate code necessary for the application. In turn, Lariat's code will be easier to maintain, more readable for their developers, and easier to extend with capabilities over time. iv. Hands-on with WCA SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 <!-- ejb-jar.xml --> <ejb-jar> <enterprise-beans> <session> <ejb-name> LegacySessionBean </ejb-name> <home> com.lariat.ejb.LegacyHome </home> <remote> com.lariat.ejb.LegacyRemote </remote> <ejb-class> com.lariat.ejb.LegacySessionBean </ejb-class> <session-type> Stateless </session-type> <transaction-type> Container </transaction-type> </session> </enterprise-beans> </ejb-jar> After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY ejb-jar.xml Part 1 WCA LIBERTY ejb-jar.xml Part 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 <ejb-jar xmlns= \"http://java.sun.com/xml/ns/javaee\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd\" version= \"3.1\" > <enterprise-beans> <session> <ejb-name> LegacySessionBean </ejb-name> <ejb-class> com.lariat.ejb.LegacySessionBean </ejb-class> <session-type> Stateless </session-type> <transaction-type> Container </transaction-type> <concurrency-strategy> OnePerRequest </concurrency-strategy> <resource-ref> <res-ref-name> jdbc/LegacyDS </res-ref-name> <res-type> javax.sql.DataSource </res-type> <res-auth> Container </res-auth> </resource-ref> </session> </enterprise-beans> </ejb-jar> 1 2 3 4 5 6 7 8 9 10 11 import javax.annotation.Resource ; import javax.ejb.Stateless ; import javax.sql.DataSource ; @Stateless public class LegacySessionBean { @Resource ( name = \"jdbc/LegacyDS\" ) private DataSource dataSource ; // Your EJB methods here } In terms of EJB declarations , there is a divergence between the approaches taken by Lariat and favored by WCA. @Stateless @Remote ( ModernRemote . class ) public class ModernSessionBean implements ModernRemote In the case of the Lariat code (above), the declaration is fully annotation-based \u2014 as discussed earlier in this section. This provides a clear contract between the interface and applications, and is a relatively simple pattern for Lariat's developers to build against. <session> <ejb-name> LegacySessionBean </ejb-name> <ejb-class> com.lariat.ejb.LegacySessionBean </ejb-class> <session-type> Stateless </session-type> ... </session> WCA recommends that the EJB metadata remain in XML format, without the use of @Remote or @Local interfaces that were present within the Lariat code. Instead, WCA relies on container parsing of the ejb-jar.xml definition and generating it based on that discovered class. With respect to resource injections , this pattern is absent from the Lariat codebase. By contrast, WCA has configured the injection of a DataSource via @Resource in both Java and ejb-jar.xml . For example: @Resource ( name = \"jdbc/LegacyDS\" ) private DataSource dataSource ; One consideration to keep in mind with this case is that WCA's approach is tailored specifically for dealing with older enterprise systems or in cases where applications need to override behaviors per environment (via resource injection). v. Next steps In the following module, participants will examine how to modernize legacy WebSphere Application Server code for Java Message Service.","title":"5. EJB modernization"},{"location":"appmod/5/#enterprise-javabeans-ejb-modernizationapplication-modernization-websphere-to-liberty","text":"","title":"Enterprise JavaBeans (EJB) modernizationApplication Modernization - WebSphere to Liberty"},{"location":"appmod/5/#i-incentives-to-modernize","text":"SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". WebSphere Enterprise JavaBeans ( EJB ) represent server-side components used by Java Enterprise Edition ( Java EE or Jakarta EE ) to encapsulate repeatable business logic. In turn, EJB can be used to provide scalable and highly performant handling for requests made by Lariat Corporation's web application estate. EJBs provide the resource access management for the databases, messaging services, and external APIs these such application require to power their business functions. WebSphere's EJBs make extensive use of XML deployment descriptors to configure their behavior. Liberty EJBs use Java annotations instead of XML , applying them directly within Java classes for configuration. In many cases, this eliminates the need for external XML files completely (or at least significantly reduces their size and number). Feature WebSphere EJB with XML Liberty EJB with annotations Maintainability Difficult due to scattered XML configs. Improved due to cohesive annotations. Readability Lower due to switching between Java and XML. Higher due to configuration directly in Java code. Productivity Lower due to manual XML edits. Higher due to rapid development through annotations. Error Propensity Higher chance of manual XML errors. Lower due to clear annotations and IDE checks. Modernizing WebSphere's EJB's stateless session beans into Liberty's standard-compliant EJB will provide Lariat with the net benefit of code that's easier to maintain, more portable, and extensible for modern cloud-native endpoints. Ultimately, this should yield a simplified developer experience and better resource management.","title":"i. Incentives to modernize"},{"location":"appmod/5/#ii-websphere-legacy-code","text":"First, examine the legacy code (below), which as mentioned previously is a snapshot of a larger application using WebSphere's EJB Stateful Session Bean with XML : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 <!-- ejb-jar.xml --> <ejb-jar> <enterprise-beans> <session> <ejb-name> LegacySessionBean </ejb-name> <home> com.lariat.ejb.LegacyHome </home> <remote> com.lariat.ejb.LegacyRemote </remote> <ejb-class> com.lariat.ejb.LegacySessionBean </ejb-class> <session-type> Stateless </session-type> <transaction-type> Container </transaction-type> </session> </enterprise-beans> </ejb-jar> The legacy EJB implementation uses XML ( ejb-jar.xml beginning on line 1 ) to explicitly define the contents of the stateful session bean. This requires that the <home> and <remote> interfaces be explicitly defined, along with the bean class. Transaction types and security are also configured externally via descriptors within the XML.","title":"ii. WebSphere legacy code"},{"location":"appmod/5/#iii-liberty-modernized-code","text":"Consider below the modernized (but functionally equivalent) application code using Liberty's EJB Stateless Session Bean with annotations : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package com.lariat.ejb ; import javax.ejb.Stateless ; import javax.ejb.Remote ; @Stateless @Remote ( ModernRemote . class ) public class ModernSessionBean implements ModernRemote { @Override public String getGreeting ( String name ) { return \"Hello, \" + name + \"!\" ; } } package com.lariat.ejb ; import javax.ejb.Remote ; @Remote public interface ModernRemote { String getGreeting ( String name ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 <!-- ejb-jar.xml --> <ejb-jar> <enterprise-beans> <session> <ejb-name> LegacySessionBean </ejb-name> <home> com.lariat.ejb.LegacyHome </home> <remote> com.lariat.ejb.LegacyRemote </remote> <ejb-class> com.lariat.ejb.LegacySessionBean </ejb-class> <session-type> Stateless </session-type> <transaction-type> Container </transaction-type> </session> </enterprise-beans> </ejb-jar> The modernized Liberty code adopts EJB with Java annotations directly within the bean implementation; for example, utilizing such annotations as @Stateless beginning on line 6 : @Stateless @Remote ( ModernRemote . class ) public class ModernSessionBean implements ModernRemote { @Override public String getGreeting ( String name ) { return \"Hello, \" + name + \"!\" ; } } This approach also eliminates the need for explicit home interfaces, instead allowing Lariat's developers to directly specify remote interfaces within the bean definition. There are also positive side effects to the \"readability\" of the code \u2014 since transaction management and security settings are managed via annotations, the amount of XML overhead is reduced and thus the code can be more easily parsed (and maintained) by humans. Ultimately, Liberty's modernized EJB implementation simplifies the bean declaration significantly and reduces the amount of boilerplate code necessary for the application. In turn, Lariat's code will be easier to maintain, more readable for their developers, and easier to extend with capabilities over time.","title":"iii. Liberty modernized code"},{"location":"appmod/5/#iv-hands-on-with-wca","text":"SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 <!-- ejb-jar.xml --> <ejb-jar> <enterprise-beans> <session> <ejb-name> LegacySessionBean </ejb-name> <home> com.lariat.ejb.LegacyHome </home> <remote> com.lariat.ejb.LegacyRemote </remote> <ejb-class> com.lariat.ejb.LegacySessionBean </ejb-class> <session-type> Stateless </session-type> <transaction-type> Container </transaction-type> </session> </enterprise-beans> </ejb-jar> After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY ejb-jar.xml Part 1 WCA LIBERTY ejb-jar.xml Part 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 <ejb-jar xmlns= \"http://java.sun.com/xml/ns/javaee\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd\" version= \"3.1\" > <enterprise-beans> <session> <ejb-name> LegacySessionBean </ejb-name> <ejb-class> com.lariat.ejb.LegacySessionBean </ejb-class> <session-type> Stateless </session-type> <transaction-type> Container </transaction-type> <concurrency-strategy> OnePerRequest </concurrency-strategy> <resource-ref> <res-ref-name> jdbc/LegacyDS </res-ref-name> <res-type> javax.sql.DataSource </res-type> <res-auth> Container </res-auth> </resource-ref> </session> </enterprise-beans> </ejb-jar> 1 2 3 4 5 6 7 8 9 10 11 import javax.annotation.Resource ; import javax.ejb.Stateless ; import javax.sql.DataSource ; @Stateless public class LegacySessionBean { @Resource ( name = \"jdbc/LegacyDS\" ) private DataSource dataSource ; // Your EJB methods here } In terms of EJB declarations , there is a divergence between the approaches taken by Lariat and favored by WCA. @Stateless @Remote ( ModernRemote . class ) public class ModernSessionBean implements ModernRemote In the case of the Lariat code (above), the declaration is fully annotation-based \u2014 as discussed earlier in this section. This provides a clear contract between the interface and applications, and is a relatively simple pattern for Lariat's developers to build against. <session> <ejb-name> LegacySessionBean </ejb-name> <ejb-class> com.lariat.ejb.LegacySessionBean </ejb-class> <session-type> Stateless </session-type> ... </session> WCA recommends that the EJB metadata remain in XML format, without the use of @Remote or @Local interfaces that were present within the Lariat code. Instead, WCA relies on container parsing of the ejb-jar.xml definition and generating it based on that discovered class. With respect to resource injections , this pattern is absent from the Lariat codebase. By contrast, WCA has configured the injection of a DataSource via @Resource in both Java and ejb-jar.xml . For example: @Resource ( name = \"jdbc/LegacyDS\" ) private DataSource dataSource ; One consideration to keep in mind with this case is that WCA's approach is tailored specifically for dealing with older enterprise systems or in cases where applications need to override behaviors per environment (via resource injection).","title":"iv. Hands-on with WCA"},{"location":"appmod/5/#v-next-steps","text":"In the following module, participants will examine how to modernize legacy WebSphere Application Server code for Java Message Service.","title":"v. Next steps"},{"location":"appmod/6/","text":"Java Message Service integration Application Modernization - WebSphere to Liberty i. Incentives to modernize SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". WebSphere traditionally connects Java Enterprise Edition (Java EE) applications to IBM MQ using complex Java Message Service ( JMS ) configurations which depend upon external XML files. JMS is the standard by which Java APIs send, receive, and manage asynchronous messages between distributed Java EE applications. In turn, IBM MQ provides a middleware layer to ensure that such asynchronous messaging are delivered reliably between said applications. Collectively, these components come together to form the WebSphere MQ JMS integration that Lariat Corporation is using in their legacy systems today. Liberty still makes use of JMS and MQ, but replaces the use of external XML file configuration management in favor of declarative configurations directly within Liberty's server.xml resource. The result is that configuration is no longer defined external to the server, which in turn reduces the complexity of managing such configurations for Lariat's developers and improves the maintainability of their messaging integrations. Feature WebSphere MQ JMS Integration Liberty JMS Configuration Complexity High complexity owing to verbose XML or admin console requirements. Significantly simplified and concise. Maintainability Difficult, configuration is dispersed and complex. Easy to maintain, with all resources clearly defined in one place. Productivity Lower developer productivity due to manual configuration and overhead. Improved developer productivity due to straightforward and rapid setup. Integrations Cloud and microservices are harder to scale or adapt. Cloud and microservices are easily adapted due to cloud-native design. By modernizing Lariat's WebSphere-based approach of MQ JMS integration to Liberty's declarative JMS-based configuration, the expectation is that the company's management of asynchronous message delivery between applications can be more easily maintained and better aligned to cloud-native best practices. ii. WebSphere legacy code First, examine the legacy code (below), which as mentioned previously is a snapshot of a larger application using WebSphere's MQ JMS integration : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 <!-- ejb-jar.xml --> <message-driven> <ejb-name> LegacyMDB </ejb-name> <ejb-class> com.lariat.messaging.LegacyMDB </ejb-class> <transaction-type> Container </transaction-type> <message-driven-destination> <destination-type> javax.jms.Queue </destination-type> </message-driven-destination> </message-driven> <!-- ibm-ejb-jar-bnd.xml --> <message-driven name= \"LegacyMDB\" > <activation-config> <activation-config-property> <activation-config-property-name> destination </activation-config-property-name> <activation-config-property-value> jms/legacyQueue </activation-config-property-value> </activation-config-property> </activation-config> </message-driven> Lariat's particular implementation of WebSphere MQ JMS utilizes XML descriptors ( ejb-jar.xml , ibm-ejb-jar-bnd.xml on lines 1 and 11 , respectively) to define message-driven beans (MDB) and their JMS destinations. This is the explicit and manual style of configuring messaging endpoints through separate descriptor (XML) files \u2014 in sharp contrast to the declarative approach you will examine with Liberty momentarily. WebSphere's approach of using separate descriptor files makes the setup of new configurations potentially more complex and prone to human-induced errors within the code. iii. Liberty modernized code Consider below the modernized (but functionally equivalent) application code using Liberty's JMS configuration : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <!-- server.xml --> <server> <featureManager> <feature> jms-2.0 </feature> </featureManager> <jmsQueue id= \"modernQueue\" jndiName= \"jms/modernQueue\" /> <messageDrivenBean id= \"ModernMDB\" > <activationSpec> <activationSpecClass> javax.jms.Queue </activationSpecClass> <activationSpecProperty name= \"destination\" > jms/modernQueue </activationSpecProperty> </activationSpec> <className> com.lariat.messaging.ModernMDB </className> </messageDrivenBean> </server> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 <!-- ejb-jar.xml --> <message-driven> <ejb-name> LegacyMDB </ejb-name> <ejb-class> com.lariat.messaging.LegacyMDB </ejb-class> <transaction-type> Container </transaction-type> <message-driven-destination> <destination-type> javax.jms.Queue </destination-type> </message-driven-destination> </message-driven> <!-- ibm-ejb-jar-bnd.xml --> <message-driven name= \"LegacyMDB\" > <activation-config> <activation-config-property> <activation-config-property-name> destination </activation-config-property-name> <activation-config-property-value> jms/legacyQueue </activation-config-property-value> </activation-config-property> </activation-config> </message-driven> Through the process of modernizing the code, Lariat switched to Liberty's messaging providers using standardized JMS APIs in a single, unified server.xml configuration. All JMS resources, such as queues and MDBs, are defined directly within the server.xml configuration file. The net result is that configurations are simplified compared to the traditional WebSphere approach of separate descriptor files. Clearly named and easily identifiable JMS queues ( line 1 ), as well as activation specifications (beginning on line 3 ), are consolidated within the streamlined server.xml configuration. In summary, consolidation of Lariat's messaging configurations into a simplified and centralized pattern has streamlined future maintenance of these configuration files and simplified the process of troubleshooting messaging integrations for their developers. iv. Hands-on with WCA SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 <!-- ejb-jar.xml --> <message-driven> <ejb-name> LegacyMDB </ejb-name> <ejb-class> com.lariat.messaging.LegacyMDB </ejb-class> <transaction-type> Container </transaction-type> <message-driven-destination> <destination-type> javax.jms.Queue </destination-type> </message-driven-destination> </message-driven> <!-- ibm-ejb-jar-bnd.xml --> <message-driven name= \"LegacyMDB\" > <activation-config> <activation-config-property> <activation-config-property-name> destination </activation-config-property-name> <activation-config-property-value> jms/legacyQueue </activation-config-property-value> </activation-config-property> </activation-config> </message-driven> After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY ejb-jar.xml Part 1 WCA LIBERTY ejb-jar.xml Part 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 <ejb-jar xmlns= \"http://java.sun.com/xml/ns/javaee\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd\" version= \"3.1\" > <enterprise-beans> <message-driven> <ejb-name> LegacyMDB </ejb-name> <ejb-class> com.lariat.messaging.LegacyMDB </ejb-class> <transaction-type> Container </transaction-type> <message-driven-destination> <destination-type> javax.jms.Queue </destination-type> <destination-jndi-name> jms/legacyQueue </destination-jndi-name> </message-driven-destination> </message-driven> </enterprise-beans> </ejb-jar> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import javax.annotation.Resource ; import javax.jms.JMSException ; import javax.jms.Message ; import javax.jms.MessageListener ; import javax.jms.Queue ; import javax.jms.QueueConnection ; import javax.jms.QueueReceiver ; import javax.jms.QueueSender ; import javax.jms.Session ; import javax.naming.InitialContext ; import javax.naming.NamingException ; @MessageDriven ( name = \"LegacyMDB\" , activationConfig = { @ActivationConfigProperty ( propertyName = \"destination\" , propertyValue = \"jms/legacyQueue\" ) } ) public class LegacyMDB implements MessageListener { @Resource ( name = \"jms/legacyQueue\" ) private Queue queue ; @Resource ( name = \"jms/JmsConnectionFactory\" ) private QueueConnectionFactory connectionFactory ; @Resource ( name = \"jms/JmsXA\" ) private InitialContext initialContext ; public void onMessage ( Message message ) { // Your message processing logic here } // Other methods for sending messages, if needed } Explicit transaction control is vital for systems that rely heavily on transactional integrity (such as banking, healthcare, order processing, and so on), so let's compare how Lariat and WCA's modernization efforts performed in this regard. @Resource ( name = \"jms/JmsConnectionFactory\" ) private QueueConnectionFactory connectionFactory ; @Resource ( name = \"jms/JmsXA\" ) private InitialContext initialContext ; By injecting a QueueConnectionFactory and InitialContext , WCA allows developers to exact a high degree of control over the JMS lifecycle. For real-world enterprise operations, redundancy and explicit design can provide safety for production environments (as well as protection against misdeployments.) For many enterprises with continuous integration and continuous delivery ( CI/CD ) requirements, a Liberty codebase that uses an \" application code + server.xml \" approach may hamper those CI/CD pipelines. This is also true for enterprise organizations that might use runtime orchestration tools to override configurations with deployment descriptors. Let's compare the two solutions against this scenario. <ejb-jar xmlns= \"http://java.sun.com/xml/ns/javaee\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd\" version= \"3.1\" > WCA's invocation of ejb-jar.xml enables declarative binding for legacy JMS destinations, providing a degree of backwards compatibility to other legacy applications in the company's estate that isn't as easily achieved with Lariat's code. v. Next steps In the following module, participants will examine how to modernize legacy WebSphere Application Server code for security management.","title":"6. JMS integration"},{"location":"appmod/6/#java-message-service-integrationapplication-modernization-websphere-to-liberty","text":"","title":"Java Message Service integrationApplication Modernization - WebSphere to Liberty"},{"location":"appmod/6/#i-incentives-to-modernize","text":"SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". WebSphere traditionally connects Java Enterprise Edition (Java EE) applications to IBM MQ using complex Java Message Service ( JMS ) configurations which depend upon external XML files. JMS is the standard by which Java APIs send, receive, and manage asynchronous messages between distributed Java EE applications. In turn, IBM MQ provides a middleware layer to ensure that such asynchronous messaging are delivered reliably between said applications. Collectively, these components come together to form the WebSphere MQ JMS integration that Lariat Corporation is using in their legacy systems today. Liberty still makes use of JMS and MQ, but replaces the use of external XML file configuration management in favor of declarative configurations directly within Liberty's server.xml resource. The result is that configuration is no longer defined external to the server, which in turn reduces the complexity of managing such configurations for Lariat's developers and improves the maintainability of their messaging integrations. Feature WebSphere MQ JMS Integration Liberty JMS Configuration Complexity High complexity owing to verbose XML or admin console requirements. Significantly simplified and concise. Maintainability Difficult, configuration is dispersed and complex. Easy to maintain, with all resources clearly defined in one place. Productivity Lower developer productivity due to manual configuration and overhead. Improved developer productivity due to straightforward and rapid setup. Integrations Cloud and microservices are harder to scale or adapt. Cloud and microservices are easily adapted due to cloud-native design. By modernizing Lariat's WebSphere-based approach of MQ JMS integration to Liberty's declarative JMS-based configuration, the expectation is that the company's management of asynchronous message delivery between applications can be more easily maintained and better aligned to cloud-native best practices.","title":"i. Incentives to modernize"},{"location":"appmod/6/#ii-websphere-legacy-code","text":"First, examine the legacy code (below), which as mentioned previously is a snapshot of a larger application using WebSphere's MQ JMS integration : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 <!-- ejb-jar.xml --> <message-driven> <ejb-name> LegacyMDB </ejb-name> <ejb-class> com.lariat.messaging.LegacyMDB </ejb-class> <transaction-type> Container </transaction-type> <message-driven-destination> <destination-type> javax.jms.Queue </destination-type> </message-driven-destination> </message-driven> <!-- ibm-ejb-jar-bnd.xml --> <message-driven name= \"LegacyMDB\" > <activation-config> <activation-config-property> <activation-config-property-name> destination </activation-config-property-name> <activation-config-property-value> jms/legacyQueue </activation-config-property-value> </activation-config-property> </activation-config> </message-driven> Lariat's particular implementation of WebSphere MQ JMS utilizes XML descriptors ( ejb-jar.xml , ibm-ejb-jar-bnd.xml on lines 1 and 11 , respectively) to define message-driven beans (MDB) and their JMS destinations. This is the explicit and manual style of configuring messaging endpoints through separate descriptor (XML) files \u2014 in sharp contrast to the declarative approach you will examine with Liberty momentarily. WebSphere's approach of using separate descriptor files makes the setup of new configurations potentially more complex and prone to human-induced errors within the code.","title":"ii. WebSphere legacy code"},{"location":"appmod/6/#iii-liberty-modernized-code","text":"Consider below the modernized (but functionally equivalent) application code using Liberty's JMS configuration : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <!-- server.xml --> <server> <featureManager> <feature> jms-2.0 </feature> </featureManager> <jmsQueue id= \"modernQueue\" jndiName= \"jms/modernQueue\" /> <messageDrivenBean id= \"ModernMDB\" > <activationSpec> <activationSpecClass> javax.jms.Queue </activationSpecClass> <activationSpecProperty name= \"destination\" > jms/modernQueue </activationSpecProperty> </activationSpec> <className> com.lariat.messaging.ModernMDB </className> </messageDrivenBean> </server> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 <!-- ejb-jar.xml --> <message-driven> <ejb-name> LegacyMDB </ejb-name> <ejb-class> com.lariat.messaging.LegacyMDB </ejb-class> <transaction-type> Container </transaction-type> <message-driven-destination> <destination-type> javax.jms.Queue </destination-type> </message-driven-destination> </message-driven> <!-- ibm-ejb-jar-bnd.xml --> <message-driven name= \"LegacyMDB\" > <activation-config> <activation-config-property> <activation-config-property-name> destination </activation-config-property-name> <activation-config-property-value> jms/legacyQueue </activation-config-property-value> </activation-config-property> </activation-config> </message-driven> Through the process of modernizing the code, Lariat switched to Liberty's messaging providers using standardized JMS APIs in a single, unified server.xml configuration. All JMS resources, such as queues and MDBs, are defined directly within the server.xml configuration file. The net result is that configurations are simplified compared to the traditional WebSphere approach of separate descriptor files. Clearly named and easily identifiable JMS queues ( line 1 ), as well as activation specifications (beginning on line 3 ), are consolidated within the streamlined server.xml configuration. In summary, consolidation of Lariat's messaging configurations into a simplified and centralized pattern has streamlined future maintenance of these configuration files and simplified the process of troubleshooting messaging integrations for their developers.","title":"iii. Liberty modernized code"},{"location":"appmod/6/#iv-hands-on-with-wca","text":"SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 <!-- ejb-jar.xml --> <message-driven> <ejb-name> LegacyMDB </ejb-name> <ejb-class> com.lariat.messaging.LegacyMDB </ejb-class> <transaction-type> Container </transaction-type> <message-driven-destination> <destination-type> javax.jms.Queue </destination-type> </message-driven-destination> </message-driven> <!-- ibm-ejb-jar-bnd.xml --> <message-driven name= \"LegacyMDB\" > <activation-config> <activation-config-property> <activation-config-property-name> destination </activation-config-property-name> <activation-config-property-value> jms/legacyQueue </activation-config-property-value> </activation-config-property> </activation-config> </message-driven> After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY ejb-jar.xml Part 1 WCA LIBERTY ejb-jar.xml Part 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 <ejb-jar xmlns= \"http://java.sun.com/xml/ns/javaee\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd\" version= \"3.1\" > <enterprise-beans> <message-driven> <ejb-name> LegacyMDB </ejb-name> <ejb-class> com.lariat.messaging.LegacyMDB </ejb-class> <transaction-type> Container </transaction-type> <message-driven-destination> <destination-type> javax.jms.Queue </destination-type> <destination-jndi-name> jms/legacyQueue </destination-jndi-name> </message-driven-destination> </message-driven> </enterprise-beans> </ejb-jar> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import javax.annotation.Resource ; import javax.jms.JMSException ; import javax.jms.Message ; import javax.jms.MessageListener ; import javax.jms.Queue ; import javax.jms.QueueConnection ; import javax.jms.QueueReceiver ; import javax.jms.QueueSender ; import javax.jms.Session ; import javax.naming.InitialContext ; import javax.naming.NamingException ; @MessageDriven ( name = \"LegacyMDB\" , activationConfig = { @ActivationConfigProperty ( propertyName = \"destination\" , propertyValue = \"jms/legacyQueue\" ) } ) public class LegacyMDB implements MessageListener { @Resource ( name = \"jms/legacyQueue\" ) private Queue queue ; @Resource ( name = \"jms/JmsConnectionFactory\" ) private QueueConnectionFactory connectionFactory ; @Resource ( name = \"jms/JmsXA\" ) private InitialContext initialContext ; public void onMessage ( Message message ) { // Your message processing logic here } // Other methods for sending messages, if needed } Explicit transaction control is vital for systems that rely heavily on transactional integrity (such as banking, healthcare, order processing, and so on), so let's compare how Lariat and WCA's modernization efforts performed in this regard. @Resource ( name = \"jms/JmsConnectionFactory\" ) private QueueConnectionFactory connectionFactory ; @Resource ( name = \"jms/JmsXA\" ) private InitialContext initialContext ; By injecting a QueueConnectionFactory and InitialContext , WCA allows developers to exact a high degree of control over the JMS lifecycle. For real-world enterprise operations, redundancy and explicit design can provide safety for production environments (as well as protection against misdeployments.) For many enterprises with continuous integration and continuous delivery ( CI/CD ) requirements, a Liberty codebase that uses an \" application code + server.xml \" approach may hamper those CI/CD pipelines. This is also true for enterprise organizations that might use runtime orchestration tools to override configurations with deployment descriptors. Let's compare the two solutions against this scenario. <ejb-jar xmlns= \"http://java.sun.com/xml/ns/javaee\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd\" version= \"3.1\" > WCA's invocation of ejb-jar.xml enables declarative binding for legacy JMS destinations, providing a degree of backwards compatibility to other legacy applications in the company's estate that isn't as easily achieved with Lariat's code.","title":"iv. Hands-on with WCA"},{"location":"appmod/6/#v-next-steps","text":"In the following module, participants will examine how to modernize legacy WebSphere Application Server code for security management.","title":"v. Next steps"},{"location":"appmod/7/","text":"Security modernization Application Modernization - WebSphere to Liberty i. Incentives to modernize SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". Traditionally, Lariat Corporation has leveraged WebSphere's approach to defining application security configurations\u2014 for roles, authentication, authorization, and access constraints \u2014via external, XML-based deployment descriptors. Oftentimes these take the forms of standard deployment descriptors (like web.xml ) or IBM-specific descriptors ( ibm-application-bnd.xml ). Liberty applications, by contrast, utilize Java annotations to embed security rules directly in-line within Java classes or methods. This helps to eliminate (or at least reduce) dependencies on external XML descriptors, creating a more robust security implementation and permitting simple to maintain configurations. Java annotations are patterned using Java Enterprise Edition (Java EE or Jakarta EE) standards which align directly with the best-practices of cloud-native design. Feature WebSphere XML-based security Liberty annotations-based security Maintainability Complex owing to dispersed configuration. Simplified owing to centralized and self-contained design. Readability Challenging due to XML files separated from Java code. Easier due to in-line annotations that provide clarity. Productivity Lower developer productivity due to frequent context-switching. Improved developer productivity due to direct configurations via code annotations. Standardization Considered a legacy practice, less aligned with modern industry standards. Modern standard (Jakarta EE) that aligns with cloud-native practices. Ultimately, Lariat anticipates that modernization of their WebSphere application's security from XML-based descriptors to Java annotation will reduce the complexity of their security configuration management as they move steadily towards cloud-native application design. ii. WebSphere legacy code First, examine the legacy code (below), which as mentioned previously is a snapshot of a larger application using WebSphere's XML-based security : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 <!-- web.xml --> <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> <login-config> <auth-method> FORM </auth-method> <form-login-config> <form-login-page> /login.jsp </form-login-page> <form-error-page> /error.jsp </form-error-page> </form-login-config> </login-config> <security-role> <role-name> admin </role-name> </security-role> The legacy XML-based code defines security constraints explicitly in web.xml using roles and URL pattern-matching, creating conditions where form-based authentication settings are specified through XML. Naturally, this complicates security management for Lariat's developer teams, as external role definitions now need to be declared in a specific manner owing to this architectural choice. In order to modernize this code, Lariat will need to convert the role-based authorization mechanisms and deployment descriptors into Java annotations. iii. Liberty modernized code Consider below the modernized (but functionally equivalent) application code using Liberty's annotation-based security : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import javax.annotation.security.DeclareRoles ; import javax.annotation.security.RolesAllowed ; import javax.ws.rs.GET ; import javax.ws.rs.Path ; import javax.ws.rs.core.Response ; @Path ( \"/secured\" ) @DeclareRoles ({ \"admin\" }) public class SecuredEndpoint { @GET @Path ( \"/data\" ) @RolesAllowed ( \"admin\" ) public Response getSecuredData () { return Response . ok ( \"Sensitive data available only to admins.\" ). build (); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 <!-- web.xml --> <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> <login-config> <auth-method> FORM </auth-method> <form-login-config> <form-login-page> /login.jsp </form-login-page> <form-error-page> /error.jsp </form-error-page> </form-login-config> </login-config> <security-role> <role-name> admin </role-name> </security-role> The modernized, Java annotations-driven security of Liberty defines @DeclareRoles ( line 8 ) and @RolesAllowed ( line 13 ) to clearly create security constraints at the method and class level. @DeclareRoles ({ \"admin\" }) @Path ( \"/secured\" ) public class SecuredEndpoint { @GET @RolesAllowed ( \"admin\" ) public Response getSecuredData () { return Response . ok ( \"Sensitive data available only to admins.\" ). build (); } } This approach simplifies the URL and method-level security mechanisms that were present within the legacy WebSphere code, replacing it via annotations within RESTful (REST API-addressable) endpoints. Ultimately, this reduces the need for external configuration and instead centralizes security declarations closer to the actual code implementation. Lariat, in turn, gains the benefits of improved clarity in how their security constraints are structured. This will enable more straightforward audits in the future and simplify the ongoing maintenance of security policies across their organization. iv. Hands-on with WCA SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 <!-- web.xml --> <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> <login-config> <auth-method> FORM </auth-method> <form-login-config> <form-login-page> /login.jsp </form-login-page> <form-error-page> /error.jsp </form-error-page> </form-login-config> </login-config> <security-role> <role-name> admin </role-name> </security-role> After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY web.xml Part 1 WCA LIBERTY web.xml Part 2 WCA LIBERTY web.xml Part 3 WCA LIBERTY web.xml Part 4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> <security-role> <role-name> admin </role-name> </security-role> <security-role-mapping> <role-name> admin </role-name> <user> adminUser </user> </security-role-mapping> 1 2 3 4 5 6 7 8 9 10 <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> <http-method> POST </http-method> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> 1 2 3 4 <login-config> <auth-method> BASIC </auth-method> <realm-name> MyRealm </realm-name> </login-config> 1 2 3 4 <error-page> <error-code> 401 </error-code> <location> /unauthorized.jsp </location> </error-page> With regards to granular control over security measures, WCA's recommendation provides much finer-grain control over the HTTP methods and URLs that are invoked by the Liberty code. Lariat's approach to modernized Liberty, by contrast, provides simpler endpoint-level restrictions. Examine the explicit security configuration recommended by WCA below: <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> WCA has defined clear security boundaries which align to enterprise standards. XML-based descriptors are often preferred within enterprise environments because those definitions are explicit, centralized, and easily audited. Changes made to Lariat's security policies can be applied quickly without needing to recompile and redeploy the code. Let's examine WCA's recommendations for fine-grained HTTP method control : <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> <http-method> POST </http-method> </web-resource-collection> WCA's Liberty code allows Lariat to restrict specific HTTP methods (like POST , PUT , DELETE ) independently of GET methods. This is essential for scenarios where reading data (with GET ) might be broadly allowed by certain applications or users within the enterprise IT estate, but other restricted operations (like POST ) need to remain tightly controlled. Lastly, consider the explicit role-to-user mapping defined by WCA's recommendation: <security-role-mapping> <role-name> admin </role-name> <user> adminUser </user> </security-role-mapping> Once again, this recommendation has been specifically tailored for enterprise use cases. WCA's defines which set of users belong to which roles \u2014 reflecting the need that Lariat, and many other enterprise organizations, have for transparency in user-role assignments. Explicit definitions such as these ensure that the modernized Liberty code is easily managed and tightly controlled by Lariat's developers. v. Conclusion Full-stack modernization requires access to the entire application code base of libraries, dependencies, compiled assets, and the contents of the application's directory structure \u2014 combined as well with the transformation guidance that is built out using IBM Cloud Transformation Advisor . Out of context fragments of application code cannot convey that level of information and complexity. Techniques for full-stack application modernization will be explored in following section.","title":"7. Security modernization"},{"location":"appmod/7/#security-modernizationapplication-modernization-websphere-to-liberty","text":"","title":"Security modernizationApplication Modernization - WebSphere to Liberty"},{"location":"appmod/7/#i-incentives-to-modernize","text":"SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". Traditionally, Lariat Corporation has leveraged WebSphere's approach to defining application security configurations\u2014 for roles, authentication, authorization, and access constraints \u2014via external, XML-based deployment descriptors. Oftentimes these take the forms of standard deployment descriptors (like web.xml ) or IBM-specific descriptors ( ibm-application-bnd.xml ). Liberty applications, by contrast, utilize Java annotations to embed security rules directly in-line within Java classes or methods. This helps to eliminate (or at least reduce) dependencies on external XML descriptors, creating a more robust security implementation and permitting simple to maintain configurations. Java annotations are patterned using Java Enterprise Edition (Java EE or Jakarta EE) standards which align directly with the best-practices of cloud-native design. Feature WebSphere XML-based security Liberty annotations-based security Maintainability Complex owing to dispersed configuration. Simplified owing to centralized and self-contained design. Readability Challenging due to XML files separated from Java code. Easier due to in-line annotations that provide clarity. Productivity Lower developer productivity due to frequent context-switching. Improved developer productivity due to direct configurations via code annotations. Standardization Considered a legacy practice, less aligned with modern industry standards. Modern standard (Jakarta EE) that aligns with cloud-native practices. Ultimately, Lariat anticipates that modernization of their WebSphere application's security from XML-based descriptors to Java annotation will reduce the complexity of their security configuration management as they move steadily towards cloud-native application design.","title":"i. Incentives to modernize"},{"location":"appmod/7/#ii-websphere-legacy-code","text":"First, examine the legacy code (below), which as mentioned previously is a snapshot of a larger application using WebSphere's XML-based security : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 <!-- web.xml --> <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> <login-config> <auth-method> FORM </auth-method> <form-login-config> <form-login-page> /login.jsp </form-login-page> <form-error-page> /error.jsp </form-error-page> </form-login-config> </login-config> <security-role> <role-name> admin </role-name> </security-role> The legacy XML-based code defines security constraints explicitly in web.xml using roles and URL pattern-matching, creating conditions where form-based authentication settings are specified through XML. Naturally, this complicates security management for Lariat's developer teams, as external role definitions now need to be declared in a specific manner owing to this architectural choice. In order to modernize this code, Lariat will need to convert the role-based authorization mechanisms and deployment descriptors into Java annotations.","title":"ii. WebSphere legacy code"},{"location":"appmod/7/#iii-liberty-modernized-code","text":"Consider below the modernized (but functionally equivalent) application code using Liberty's annotation-based security : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import javax.annotation.security.DeclareRoles ; import javax.annotation.security.RolesAllowed ; import javax.ws.rs.GET ; import javax.ws.rs.Path ; import javax.ws.rs.core.Response ; @Path ( \"/secured\" ) @DeclareRoles ({ \"admin\" }) public class SecuredEndpoint { @GET @Path ( \"/data\" ) @RolesAllowed ( \"admin\" ) public Response getSecuredData () { return Response . ok ( \"Sensitive data available only to admins.\" ). build (); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 <!-- web.xml --> <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> <login-config> <auth-method> FORM </auth-method> <form-login-config> <form-login-page> /login.jsp </form-login-page> <form-error-page> /error.jsp </form-error-page> </form-login-config> </login-config> <security-role> <role-name> admin </role-name> </security-role> The modernized, Java annotations-driven security of Liberty defines @DeclareRoles ( line 8 ) and @RolesAllowed ( line 13 ) to clearly create security constraints at the method and class level. @DeclareRoles ({ \"admin\" }) @Path ( \"/secured\" ) public class SecuredEndpoint { @GET @RolesAllowed ( \"admin\" ) public Response getSecuredData () { return Response . ok ( \"Sensitive data available only to admins.\" ). build (); } } This approach simplifies the URL and method-level security mechanisms that were present within the legacy WebSphere code, replacing it via annotations within RESTful (REST API-addressable) endpoints. Ultimately, this reduces the need for external configuration and instead centralizes security declarations closer to the actual code implementation. Lariat, in turn, gains the benefits of improved clarity in how their security constraints are structured. This will enable more straightforward audits in the future and simplify the ongoing maintenance of security policies across their organization.","title":"iii. Liberty modernized code"},{"location":"appmod/7/#iv-hands-on-with-wca","text":"SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 <!-- web.xml --> <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> <login-config> <auth-method> FORM </auth-method> <form-login-config> <form-login-page> /login.jsp </form-login-page> <form-error-page> /error.jsp </form-error-page> </form-login-config> </login-config> <security-role> <role-name> admin </role-name> </security-role> After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY web.xml Part 1 WCA LIBERTY web.xml Part 2 WCA LIBERTY web.xml Part 3 WCA LIBERTY web.xml Part 4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> <security-role> <role-name> admin </role-name> </security-role> <security-role-mapping> <role-name> admin </role-name> <user> adminUser </user> </security-role-mapping> 1 2 3 4 5 6 7 8 9 10 <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> <http-method> POST </http-method> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> 1 2 3 4 <login-config> <auth-method> BASIC </auth-method> <realm-name> MyRealm </realm-name> </login-config> 1 2 3 4 <error-page> <error-code> 401 </error-code> <location> /unauthorized.jsp </location> </error-page> With regards to granular control over security measures, WCA's recommendation provides much finer-grain control over the HTTP methods and URLs that are invoked by the Liberty code. Lariat's approach to modernized Liberty, by contrast, provides simpler endpoint-level restrictions. Examine the explicit security configuration recommended by WCA below: <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> WCA has defined clear security boundaries which align to enterprise standards. XML-based descriptors are often preferred within enterprise environments because those definitions are explicit, centralized, and easily audited. Changes made to Lariat's security policies can be applied quickly without needing to recompile and redeploy the code. Let's examine WCA's recommendations for fine-grained HTTP method control : <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> <http-method> POST </http-method> </web-resource-collection> WCA's Liberty code allows Lariat to restrict specific HTTP methods (like POST , PUT , DELETE ) independently of GET methods. This is essential for scenarios where reading data (with GET ) might be broadly allowed by certain applications or users within the enterprise IT estate, but other restricted operations (like POST ) need to remain tightly controlled. Lastly, consider the explicit role-to-user mapping defined by WCA's recommendation: <security-role-mapping> <role-name> admin </role-name> <user> adminUser </user> </security-role-mapping> Once again, this recommendation has been specifically tailored for enterprise use cases. WCA's defines which set of users belong to which roles \u2014 reflecting the need that Lariat, and many other enterprise organizations, have for transparency in user-role assignments. Explicit definitions such as these ensure that the modernized Liberty code is easily managed and tightly controlled by Lariat's developers.","title":"iv. Hands-on with WCA"},{"location":"appmod/7/#v-conclusion","text":"Full-stack modernization requires access to the entire application code base of libraries, dependencies, compiled assets, and the contents of the application's directory structure \u2014 combined as well with the transformation guidance that is built out using IBM Cloud Transformation Advisor . Out of context fragments of application code cannot convey that level of information and complexity. Techniques for full-stack application modernization will be explored in following section.","title":"v. Conclusion"},{"location":"appmod/8/","text":"Full stack modernization Application Modernization - WebSphere to Liberty i. Objectives As a capstone to the experimentation and feature-exploration conducted with IBM watsonx Code Assistant ( WCA ) in the previous modules of this lab, participants will conclude the Application Modernization topic with a hands-on opportunity: modernization of a full-stack WebSphere Application Service (WAS) application into WebSphere Liberty. Participants will be tasked with: Explaining the purpose of the legacy WAS code and detailing the necessary transformations Modernizing legacy packages and libraries from WAS to Liberty Upgrading Java versions from Java 8 to Java 21 Code recommendations will be generated using WCA Chat , as in the previous modules, alongside the Modernize and Java Upgrade capabilities built into WCA Standard plans The culmination of this work will be a fully modernized and interactive web application that tangibly demonstrates the benefits of the techniques discussed throughout this lab. ii. Setting up Return to the Visual Studio Code (VS Code) application. It should already be signed in and authenticated with the WCA service on IBM Cloud \u2014 if it's not, follow the instructions in the IBM Cloud (SaaS) Configuration lab. Ensure that the Explorer tab is cleared of any previously-opened folders or files before continuing. With the VS Code Explorer tab selected and open, click File > Close Folder from the top taskbar. Additional software must be prepared within VS Code before continuing with WCA Standard Plan's enterprise capabilities for WebSphere modernization. INCOMPATIBILITY WITH JDK 24 Note that the Full stack modernization module in Application Modernization - WebSphere to Liberty will encounter compatibility errors with JDK 24 drivers when attempting to Explain or Modernize the source application. This is owing to a deprecation of sun.misc.Unsafe method as of March 2025. Additional details may be found here. As a result, participants in this lab should ensure they are running JDK 21 (or as early as JDK 11), but specifically not JDK 24. If you are running JDK 24, you should uninstall the JDK from your machine and reinstall with the links provided in Configure the enterprise Java environment . From the left-hand side of the VS Code interface, click the Extensions tab Within the Extensions: Marketplace search bar , search for Liberty Tools Click the blue Install button to the right of the Liberty Tools tile Dismiss any \"Welcome\" splash screens Once the install is complete, return to the Extensions tab again Within the Extensions: Marketplace search bar , search Extension Pack for Java Click the blue Install to the right of the Extension Pack for Java tile Wait for the install to complete and dismiss any \"Welcome\" splash screens Next, participants must download the WebSphere Application Server (WAS) assets that are to be modernized. The assets will be retrieved from the linked application repository: wca-assets-2025.zip URL: https://ibm.box.com/s/ps65ax6mupmwx3pww2b2ylvc9ed18njp Save the wca-assets-2025.zip file to your local machine and unzip the contents Open the Explorer tab from the VS Code interface Click the blue Open Folder button and select the unzipped wca-assets-2025 directory The wca-assets-2025 contents will automatically open within Explorer iii. Deploy the application Participants now need to build the application Project . Open a Terminal within VS Code (if you haven't already) by clicking Terminal > New Terminal from the top taskbar. Navigate using the Terminal to the folder where wca-assets-2025 was saved in Step 3 and drill down /1-java-modernization/modresorts-twas-j8/was_dependency directory Attention: Substitute the <REPLACE> placeholder with the path to your directory cd <REPLACE>/wca-assets-2025/1-java-modernization/modresorts-twas-j8/was_dependency Source the ~/.zshrc PATH and JAVA_HOME variables (set up previously in the Configure the enterprise Java environment module) by executing the following: source ~/.zshrc The necessary Maven dependencies must be prepared within the was_dependency directory before the application can be deployed. Using a Terminal, execute the following instruction: mvn install:install-file -Dfile = was_public.jar -DpomFile = was_public-9.0.0.pom WINDOWS USERS Windows users might need to provide the full path for the build files was_public.jar and was_public-9.0.0.pom , for example: mvm install:install-file -Dfile = C: \\U sers \\A dministrator.CE-APAC-WIND202 \\D ocuments \\w ca4ej-workshop \\m odresorts \\t was \\j 8 \\w as_dependency \\w as_public.jar -Dpom-File = C: \\U sers \\A dministrator.CE-APAC-WIND202 \\D ocuments \\w ca4ej-workshop \\m odresorts-twas-j8 \\w as_dependency \\w as_public-9.0.0.pom With the was_dependency folder now prepared with the necessary drivers, you are ready to build and deploy the application project into a live web application Open the Explorer tab from the left-hand side of the VS Code interface Below the list of assets belonging the modresorts-twas-j8 directory, locate and toggle the LIBERTY DASHBOARD [A] drop-down panel amongst the tabs If modresorts is not displayed, click the Add project to Liberty Dashboard [B] and press Enter when prompted to select the modresorts-twas-j8 project [C] Within the LIBERTY DASHBOARD , a modresorts app will show up under the Liberty Dashboard panel. Right click on the modresorts project name to open the drop-down menu of options Click Start to initialize the project VS Code will automatically download the necessary packages (you can trace the progress within the Terminal console) Wait until the initialization process has finished and the console has returned a Source compilation was successful message Copy and record the Web application available (default host): ... address returned by the Terminal console ( http://localhost:9080/resorts or similar) Record the value of the Liberty Debug Port to a notepad for reference later. Open a new web browser tab and visit the Web application URL recorded in Step 7. Explore and familiarize yourself with the various tabs and pages built into the legacy web application. ERRORS AND BROKEN WEB LINKS As the legacy application has been built for WebSphere Application Server (WAS) using Java 8 , but the deployment generated in Step 7 was intended for WebSphere Liberty using Java 21 , there are a number of pages within the app that will produce an \"Error\" \u2014 for example, the location information module. These will be aspects of the application that you will remedy as part of the modernization steps that follow. iv. Explain the project code Let's better understand the entirety of the project by using the explainability features built into watsonx Code Assistant. Open the Explorer tab from the left-hand interface to view the contents of the modresorts-twas-j8 project Right-click anywhere inside the modresorts-twas-j8 workspace [A] to open a drop-down menu of options Hover over the watsonx Code Assistant option and then select Explain Application [B] When prompted, click Proceed with code analysis Wait 1-2 minutes for the analysis to complete, at which time a pop-up will appear in the bottom-right corner of VS Code stating that The explanation has been completed Click the Open explanation button within the pop-up to open and peruse the report Record the entire output of the Explain Application report to a notepad for reference later. v. Build a modernization plan Before modernizing the WAS application into Liberty, you'll need to scope out the necessary changes and level of effort required to do so. To obtain that understanding, you will need to generate a modernization plan using IBM Cloud Transformation Advisor . For the purposes of this lab, one such plan has been prepared ahead of time and included within the modresorts-twas-j8 project folder. Open the Explore tab of VS Code and right-click anywhere inside the modresorts-twas-j8 workspace. Then hover over watsonx Code Assistant and select Modernize to Liberty . A Modernize to Liberty tab will open within the VS Code interface As the modernization plan prepared earlier by IBM Cloud Transformation Advisor has not yet been uploaded to WCA at this stage, the modernization recommendations proposed currently by the service are less granular and contextualized than they will be after uploading the migration bundle. This presents an interesting opportunity to compare the before and after impacts of the migration bundle on the WCA modernization plan. Before uploading the migration bundle , take note of the following information and record it to a notepad for reference later: how many proposed fixes are suggested for Automated Fixes , Assisted Fixes , and Self-Directed Fixes ? To supply the migration bundle, click the Return to Upload / analyze button in the top-right corner of the Modernize to Liberty panel Click the Upload migration bundle button When prompted, specify modresorts-twas-j8/migration-bundle/modresorts.ear_migrationBundle.zip as the location of the migration bundle Observe the state of the Selected files to be added to the project before making any adjustments or selections. Record these observations to a notepad for reference later. Be sure that both the server.xml and Containerfile assets are selected, then click Proceed to continue Analysis will take a few moments to complete. When ready, the Modernize panel will generate a report that identifies issues with the application that need to be fixed. Some of these can be automatically repaired, while others will require a degree of manual intervention. Under the Issues header, click the Automated fixes to pull open the list of issues that can be automated Inspect each of the automated fix suggestions, including their titles and the contents within the expandable tabs. These details should be recorded to a notepad for reference later. See more details about each by clicking the drop-down error to the right of the issue Click the Run automated fixes button at the bottom of the page to execute the automated fixes to Liberty After receiving a BUILD SUCCESS message from the console: Record details about the Estimate of time saved included in the console read-out Take note of how many Java source files were modified as a result of the automated fixes. Save this information to a notepad for reference later. View details about the fix(es) requiring a degree of manual intervention by clicking the Assisted fixes tab. Record the total number of Assisted fixes , Self-directed fixes , and Additional information suggestions to a notepad for future reference. Along the top of the tab, left-click the grey Instructions [A] panel to reveal the WCA-generated guidance on how to resolve the migration problems. In this example, the WebSphere Servlet API was superseded by a newer implementation that uses Servlet 3.0 functionality and as such a trio of packages used by the WAS app will no longer be available for use with Liberty Further down the panel, impacted file(s) in the legacy application code will be provided Click [B] the drop-down arrow to the right of the impacted file to reveal a detailed set of instructions for how to improve the code Afterwards, click [C] the name of the impacted file to inspect its source code in a new editor window: src/main/java/com/acme/modres/UpperServlet.java An editor window will open on the right side of VS Code, displaying the contents of UpperServlet.java for editing. The next set of instructions will follow along with the guidance recommended by the Modernize panel (in the center of the VS Code interface): Select [A] all of the class that uses the ResponseUtils.encodeDataString() method, beginning on Line 14 from @WebServlet(\"/resorts/upper\") and ending on Line 27 (an empty newline) Record the text (if any) that appears directly above Line 14 within the open UpperServlet.java file contents window. Save this information to a notepad for reference later. With the relevant code selected, click the Help me [B] button in the Modernize panel WCA will engage a Chat session and generate within the conversation TWO sets of code fixes that can be added to the legacy code in order to remedy the issue. Recommendation 1: The first fix will be a substitute of the lines of code for UpperServlet.java , beginning on Line 23 and ending on Line 26 . A new line will also need to be added to the import statements at the beginning of the file. // Assisted by watsonx Code Assistant import org.apache.commons.text.StringEscapeUtils ; @WebServlet ( \"/resorts/upper\" ) public class UpperServlet extends HttpServlet { private static final long serialVersionUID = 1L ; @Override protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { response . setContentType ( \"text/html\" ); String originalStr = request . getParameter ( \"input\" ); if ( originalStr == null ) { originalStr = \"\" ; } String escapedStr = StringEscapeUtils . escapeHtml4 ( originalStr ); newStr = StringEscapeUtils . escapeHtml4 ( newStr ); PrintWriter out = response . getWriter (); out . print ( \"<br/><b>capitalized input \" + newStr + \"</b>\" ); } } Recommendation 2: The second fix will be new lines of code that are to be added to the pom.xml file. < dependency > < groupId > org . apache . commons </ groupId > < artifactId > commons - text </ a > < version > 1.12.0 </ version > </ dependency > Edit the contents of UpperServlet.java by replacing the highlighted lines of code as instructed in Step 14 with the WCA-generated Recommendation 1 code. Save the changes to the file ( File > Save ). Locate the pom.xml file from the list of assets under the Explorer tab. Double-click on the filename to edit the contents Scroll down until you reach Level 58 ( </dependency> ) and place your cursor at the end of the line, then hit Enter to create a new line Beginning on the new Line 59 of the pom.xml contents, add the contents of WCA's Recommendation 2 (the second code block of Step 14 ) to the file The new lines of code should now occupy Lines 59-63 of the modified pom.xml code Ensure that the indentation lines up with other <dependency> declarations within the parent <dependencies> nesting Save the changes to the file ( File > Save ) With the application code now modified\u2014 by a combination of automated fixes and manual interventions \u2014the original deployment launched in Step 4 will need to be re-deployed. Return to the open VS Code Terminal Press Ctrl + C to terminate the application Record the message returned by the console after terminating the application. Save this information to a notebook for reference later. To re-deploy the application, return to the Modernize panel (right hand side). Take note of the fact that all Issues previously reported by the tool have been resolved. Click the Rebuild and refresh button to re-deploy the modernized application Wait for the Modernize ModResorts summary to refresh: it should now should only 1 Automated fix (optional and can be ignore) and 0 Assisted fixes are recommended Open the Explorer tab and locate the LIBERTY DASHBOARD drop-down Right click on modresorts , click Start , and wait for the console to report a successful deployment Refresh the tab of the web application to inspect the modernized Liberty application Previously broken features, such as the Logout button, should now be fully operable Click the Logout button on the redeployed ModResorts page. Wait for the page to refresh and then record the message on the page to a notepad for reference later. vi. Java version upgrades Recall from before that the application's version of Java code was originally written for Java 8 . However, to be compliant with modern versions of Liberty, that Java code will need to be upgraded to Java 21 . With the Explorer tab active, right click on the modresorts-twas-j8 directory to expose a drop-down menu. Hover over watsonx Code Assistant Left click Upgrade Java Version to continue A new Upgrade panel will open as a tab alongside the Modernize panel. WCA will automatically detect that the code Source is designed for IBM Java 8 Set the Target parameter equal to Java 21 (LTS) When ready, click the Build and analyze button Similar to the Modernize steps previously, the Upgrade automation will generate a new Issues tab containing a list of potential fixes required before continuing with the Java version upgrade. Some of these tasks can be handled fully by automation; others will require some degree of manual intervention. Select the Automated fixes tab first to identify three issues that can be resolved without human intervention Click any of the recommended fixes to pull down additional information on what changes will be performed by the automation When ready, click the Run automated fixes button to perform the tasks Completion of the tasks may take several minutes to conclude To examine the Upgrade tasks requiring human intervention, click the Assisted fixes tab. Similarly to the Modernization panel, a description of the issue and detailed recommendations on how to perform the code fixes are listed within the tab Click the name of the problematic file ( src/main/java/acme/modres/mbean/DMBeanUtils.java ) to open DMBeanUtils.java for editing and modification According to WCA, there is an incompatibility with the getOps method within the DMBeanUtils.java codebase \u2014 specifically with the MBeanOperationInfo constructor that the method calls on line 28. Click the Help me button to engage a new WCA Chat session WCA will generate code recommendations within the Chat panel that can substitute the problematic legacy code Copy the full public final class DMBeanUtils {...} code recommendation from the Chat panel to a clipboard Replace the entire contents of the DMBeanUtils.java file with the recommendation from WCA Save the changes to the file ( File > Save ) There is a second optional recommendation available within the Issues tab of the Upgrade panel, but this can be safely ignored for now as it only relates to a deprecation warning. With the application's Java version now upgraded to Java 21 by a combination of automated fixes and manual interventions \u2014the application will once again need to be redeployed to reflect the changes. Return to the open VS Code Terminal Press Ctrl + C to terminate the application To re-deploy the application, return to the Upgrade panel (right hand side). Take note of the fact that all Issues previously reported by the tool have been resolved. Click the Rebuild and refresh button to re-deploy the application Wait for the Terminal to report a successful deployment Refresh the tab of the web application to inspect the modernized Liberty application Previously broken features, such as the Location module, should now be fully operable vii. Conclusion Having concluded the Application Modernization - WebSphere to Liberty hands-on modules, participants should now complete the corresponding Evaluation quiz and then continue with the remainder of the Level 4 curriculum.","title":"8. Full stack modernization"},{"location":"appmod/8/#full-stack-modernizationapplication-modernization-websphere-to-liberty","text":"","title":"Full stack modernizationApplication Modernization - WebSphere to Liberty"},{"location":"appmod/8/#i-objectives","text":"As a capstone to the experimentation and feature-exploration conducted with IBM watsonx Code Assistant ( WCA ) in the previous modules of this lab, participants will conclude the Application Modernization topic with a hands-on opportunity: modernization of a full-stack WebSphere Application Service (WAS) application into WebSphere Liberty. Participants will be tasked with: Explaining the purpose of the legacy WAS code and detailing the necessary transformations Modernizing legacy packages and libraries from WAS to Liberty Upgrading Java versions from Java 8 to Java 21 Code recommendations will be generated using WCA Chat , as in the previous modules, alongside the Modernize and Java Upgrade capabilities built into WCA Standard plans The culmination of this work will be a fully modernized and interactive web application that tangibly demonstrates the benefits of the techniques discussed throughout this lab.","title":"i. Objectives"},{"location":"appmod/8/#ii-setting-up","text":"Return to the Visual Studio Code (VS Code) application. It should already be signed in and authenticated with the WCA service on IBM Cloud \u2014 if it's not, follow the instructions in the IBM Cloud (SaaS) Configuration lab. Ensure that the Explorer tab is cleared of any previously-opened folders or files before continuing. With the VS Code Explorer tab selected and open, click File > Close Folder from the top taskbar. Additional software must be prepared within VS Code before continuing with WCA Standard Plan's enterprise capabilities for WebSphere modernization. INCOMPATIBILITY WITH JDK 24 Note that the Full stack modernization module in Application Modernization - WebSphere to Liberty will encounter compatibility errors with JDK 24 drivers when attempting to Explain or Modernize the source application. This is owing to a deprecation of sun.misc.Unsafe method as of March 2025. Additional details may be found here. As a result, participants in this lab should ensure they are running JDK 21 (or as early as JDK 11), but specifically not JDK 24. If you are running JDK 24, you should uninstall the JDK from your machine and reinstall with the links provided in Configure the enterprise Java environment . From the left-hand side of the VS Code interface, click the Extensions tab Within the Extensions: Marketplace search bar , search for Liberty Tools Click the blue Install button to the right of the Liberty Tools tile Dismiss any \"Welcome\" splash screens Once the install is complete, return to the Extensions tab again Within the Extensions: Marketplace search bar , search Extension Pack for Java Click the blue Install to the right of the Extension Pack for Java tile Wait for the install to complete and dismiss any \"Welcome\" splash screens Next, participants must download the WebSphere Application Server (WAS) assets that are to be modernized. The assets will be retrieved from the linked application repository: wca-assets-2025.zip URL: https://ibm.box.com/s/ps65ax6mupmwx3pww2b2ylvc9ed18njp Save the wca-assets-2025.zip file to your local machine and unzip the contents Open the Explorer tab from the VS Code interface Click the blue Open Folder button and select the unzipped wca-assets-2025 directory The wca-assets-2025 contents will automatically open within Explorer","title":"ii. Setting up"},{"location":"appmod/8/#iii-deploy-the-application","text":"Participants now need to build the application Project . Open a Terminal within VS Code (if you haven't already) by clicking Terminal > New Terminal from the top taskbar. Navigate using the Terminal to the folder where wca-assets-2025 was saved in Step 3 and drill down /1-java-modernization/modresorts-twas-j8/was_dependency directory Attention: Substitute the <REPLACE> placeholder with the path to your directory cd <REPLACE>/wca-assets-2025/1-java-modernization/modresorts-twas-j8/was_dependency Source the ~/.zshrc PATH and JAVA_HOME variables (set up previously in the Configure the enterprise Java environment module) by executing the following: source ~/.zshrc The necessary Maven dependencies must be prepared within the was_dependency directory before the application can be deployed. Using a Terminal, execute the following instruction: mvn install:install-file -Dfile = was_public.jar -DpomFile = was_public-9.0.0.pom WINDOWS USERS Windows users might need to provide the full path for the build files was_public.jar and was_public-9.0.0.pom , for example: mvm install:install-file -Dfile = C: \\U sers \\A dministrator.CE-APAC-WIND202 \\D ocuments \\w ca4ej-workshop \\m odresorts \\t was \\j 8 \\w as_dependency \\w as_public.jar -Dpom-File = C: \\U sers \\A dministrator.CE-APAC-WIND202 \\D ocuments \\w ca4ej-workshop \\m odresorts-twas-j8 \\w as_dependency \\w as_public-9.0.0.pom With the was_dependency folder now prepared with the necessary drivers, you are ready to build and deploy the application project into a live web application Open the Explorer tab from the left-hand side of the VS Code interface Below the list of assets belonging the modresorts-twas-j8 directory, locate and toggle the LIBERTY DASHBOARD [A] drop-down panel amongst the tabs If modresorts is not displayed, click the Add project to Liberty Dashboard [B] and press Enter when prompted to select the modresorts-twas-j8 project [C] Within the LIBERTY DASHBOARD , a modresorts app will show up under the Liberty Dashboard panel. Right click on the modresorts project name to open the drop-down menu of options Click Start to initialize the project VS Code will automatically download the necessary packages (you can trace the progress within the Terminal console) Wait until the initialization process has finished and the console has returned a Source compilation was successful message Copy and record the Web application available (default host): ... address returned by the Terminal console ( http://localhost:9080/resorts or similar) Record the value of the Liberty Debug Port to a notepad for reference later. Open a new web browser tab and visit the Web application URL recorded in Step 7. Explore and familiarize yourself with the various tabs and pages built into the legacy web application. ERRORS AND BROKEN WEB LINKS As the legacy application has been built for WebSphere Application Server (WAS) using Java 8 , but the deployment generated in Step 7 was intended for WebSphere Liberty using Java 21 , there are a number of pages within the app that will produce an \"Error\" \u2014 for example, the location information module. These will be aspects of the application that you will remedy as part of the modernization steps that follow.","title":"iii. Deploy the application"},{"location":"appmod/8/#iv-explain-the-project-code","text":"Let's better understand the entirety of the project by using the explainability features built into watsonx Code Assistant. Open the Explorer tab from the left-hand interface to view the contents of the modresorts-twas-j8 project Right-click anywhere inside the modresorts-twas-j8 workspace [A] to open a drop-down menu of options Hover over the watsonx Code Assistant option and then select Explain Application [B] When prompted, click Proceed with code analysis Wait 1-2 minutes for the analysis to complete, at which time a pop-up will appear in the bottom-right corner of VS Code stating that The explanation has been completed Click the Open explanation button within the pop-up to open and peruse the report Record the entire output of the Explain Application report to a notepad for reference later.","title":"iv. Explain the project code"},{"location":"appmod/8/#v-build-a-modernization-plan","text":"Before modernizing the WAS application into Liberty, you'll need to scope out the necessary changes and level of effort required to do so. To obtain that understanding, you will need to generate a modernization plan using IBM Cloud Transformation Advisor . For the purposes of this lab, one such plan has been prepared ahead of time and included within the modresorts-twas-j8 project folder. Open the Explore tab of VS Code and right-click anywhere inside the modresorts-twas-j8 workspace. Then hover over watsonx Code Assistant and select Modernize to Liberty . A Modernize to Liberty tab will open within the VS Code interface As the modernization plan prepared earlier by IBM Cloud Transformation Advisor has not yet been uploaded to WCA at this stage, the modernization recommendations proposed currently by the service are less granular and contextualized than they will be after uploading the migration bundle. This presents an interesting opportunity to compare the before and after impacts of the migration bundle on the WCA modernization plan. Before uploading the migration bundle , take note of the following information and record it to a notepad for reference later: how many proposed fixes are suggested for Automated Fixes , Assisted Fixes , and Self-Directed Fixes ? To supply the migration bundle, click the Return to Upload / analyze button in the top-right corner of the Modernize to Liberty panel Click the Upload migration bundle button When prompted, specify modresorts-twas-j8/migration-bundle/modresorts.ear_migrationBundle.zip as the location of the migration bundle Observe the state of the Selected files to be added to the project before making any adjustments or selections. Record these observations to a notepad for reference later. Be sure that both the server.xml and Containerfile assets are selected, then click Proceed to continue Analysis will take a few moments to complete. When ready, the Modernize panel will generate a report that identifies issues with the application that need to be fixed. Some of these can be automatically repaired, while others will require a degree of manual intervention. Under the Issues header, click the Automated fixes to pull open the list of issues that can be automated Inspect each of the automated fix suggestions, including their titles and the contents within the expandable tabs. These details should be recorded to a notepad for reference later. See more details about each by clicking the drop-down error to the right of the issue Click the Run automated fixes button at the bottom of the page to execute the automated fixes to Liberty After receiving a BUILD SUCCESS message from the console: Record details about the Estimate of time saved included in the console read-out Take note of how many Java source files were modified as a result of the automated fixes. Save this information to a notepad for reference later. View details about the fix(es) requiring a degree of manual intervention by clicking the Assisted fixes tab. Record the total number of Assisted fixes , Self-directed fixes , and Additional information suggestions to a notepad for future reference. Along the top of the tab, left-click the grey Instructions [A] panel to reveal the WCA-generated guidance on how to resolve the migration problems. In this example, the WebSphere Servlet API was superseded by a newer implementation that uses Servlet 3.0 functionality and as such a trio of packages used by the WAS app will no longer be available for use with Liberty Further down the panel, impacted file(s) in the legacy application code will be provided Click [B] the drop-down arrow to the right of the impacted file to reveal a detailed set of instructions for how to improve the code Afterwards, click [C] the name of the impacted file to inspect its source code in a new editor window: src/main/java/com/acme/modres/UpperServlet.java An editor window will open on the right side of VS Code, displaying the contents of UpperServlet.java for editing. The next set of instructions will follow along with the guidance recommended by the Modernize panel (in the center of the VS Code interface): Select [A] all of the class that uses the ResponseUtils.encodeDataString() method, beginning on Line 14 from @WebServlet(\"/resorts/upper\") and ending on Line 27 (an empty newline) Record the text (if any) that appears directly above Line 14 within the open UpperServlet.java file contents window. Save this information to a notepad for reference later. With the relevant code selected, click the Help me [B] button in the Modernize panel WCA will engage a Chat session and generate within the conversation TWO sets of code fixes that can be added to the legacy code in order to remedy the issue. Recommendation 1: The first fix will be a substitute of the lines of code for UpperServlet.java , beginning on Line 23 and ending on Line 26 . A new line will also need to be added to the import statements at the beginning of the file. // Assisted by watsonx Code Assistant import org.apache.commons.text.StringEscapeUtils ; @WebServlet ( \"/resorts/upper\" ) public class UpperServlet extends HttpServlet { private static final long serialVersionUID = 1L ; @Override protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { response . setContentType ( \"text/html\" ); String originalStr = request . getParameter ( \"input\" ); if ( originalStr == null ) { originalStr = \"\" ; } String escapedStr = StringEscapeUtils . escapeHtml4 ( originalStr ); newStr = StringEscapeUtils . escapeHtml4 ( newStr ); PrintWriter out = response . getWriter (); out . print ( \"<br/><b>capitalized input \" + newStr + \"</b>\" ); } } Recommendation 2: The second fix will be new lines of code that are to be added to the pom.xml file. < dependency > < groupId > org . apache . commons </ groupId > < artifactId > commons - text </ a > < version > 1.12.0 </ version > </ dependency > Edit the contents of UpperServlet.java by replacing the highlighted lines of code as instructed in Step 14 with the WCA-generated Recommendation 1 code. Save the changes to the file ( File > Save ). Locate the pom.xml file from the list of assets under the Explorer tab. Double-click on the filename to edit the contents Scroll down until you reach Level 58 ( </dependency> ) and place your cursor at the end of the line, then hit Enter to create a new line Beginning on the new Line 59 of the pom.xml contents, add the contents of WCA's Recommendation 2 (the second code block of Step 14 ) to the file The new lines of code should now occupy Lines 59-63 of the modified pom.xml code Ensure that the indentation lines up with other <dependency> declarations within the parent <dependencies> nesting Save the changes to the file ( File > Save ) With the application code now modified\u2014 by a combination of automated fixes and manual interventions \u2014the original deployment launched in Step 4 will need to be re-deployed. Return to the open VS Code Terminal Press Ctrl + C to terminate the application Record the message returned by the console after terminating the application. Save this information to a notebook for reference later. To re-deploy the application, return to the Modernize panel (right hand side). Take note of the fact that all Issues previously reported by the tool have been resolved. Click the Rebuild and refresh button to re-deploy the modernized application Wait for the Modernize ModResorts summary to refresh: it should now should only 1 Automated fix (optional and can be ignore) and 0 Assisted fixes are recommended Open the Explorer tab and locate the LIBERTY DASHBOARD drop-down Right click on modresorts , click Start , and wait for the console to report a successful deployment Refresh the tab of the web application to inspect the modernized Liberty application Previously broken features, such as the Logout button, should now be fully operable Click the Logout button on the redeployed ModResorts page. Wait for the page to refresh and then record the message on the page to a notepad for reference later.","title":"v. Build a modernization plan"},{"location":"appmod/8/#vi-java-version-upgrades","text":"Recall from before that the application's version of Java code was originally written for Java 8 . However, to be compliant with modern versions of Liberty, that Java code will need to be upgraded to Java 21 . With the Explorer tab active, right click on the modresorts-twas-j8 directory to expose a drop-down menu. Hover over watsonx Code Assistant Left click Upgrade Java Version to continue A new Upgrade panel will open as a tab alongside the Modernize panel. WCA will automatically detect that the code Source is designed for IBM Java 8 Set the Target parameter equal to Java 21 (LTS) When ready, click the Build and analyze button Similar to the Modernize steps previously, the Upgrade automation will generate a new Issues tab containing a list of potential fixes required before continuing with the Java version upgrade. Some of these tasks can be handled fully by automation; others will require some degree of manual intervention. Select the Automated fixes tab first to identify three issues that can be resolved without human intervention Click any of the recommended fixes to pull down additional information on what changes will be performed by the automation When ready, click the Run automated fixes button to perform the tasks Completion of the tasks may take several minutes to conclude To examine the Upgrade tasks requiring human intervention, click the Assisted fixes tab. Similarly to the Modernization panel, a description of the issue and detailed recommendations on how to perform the code fixes are listed within the tab Click the name of the problematic file ( src/main/java/acme/modres/mbean/DMBeanUtils.java ) to open DMBeanUtils.java for editing and modification According to WCA, there is an incompatibility with the getOps method within the DMBeanUtils.java codebase \u2014 specifically with the MBeanOperationInfo constructor that the method calls on line 28. Click the Help me button to engage a new WCA Chat session WCA will generate code recommendations within the Chat panel that can substitute the problematic legacy code Copy the full public final class DMBeanUtils {...} code recommendation from the Chat panel to a clipboard Replace the entire contents of the DMBeanUtils.java file with the recommendation from WCA Save the changes to the file ( File > Save ) There is a second optional recommendation available within the Issues tab of the Upgrade panel, but this can be safely ignored for now as it only relates to a deprecation warning. With the application's Java version now upgraded to Java 21 by a combination of automated fixes and manual interventions \u2014the application will once again need to be redeployed to reflect the changes. Return to the open VS Code Terminal Press Ctrl + C to terminate the application To re-deploy the application, return to the Upgrade panel (right hand side). Take note of the fact that all Issues previously reported by the tool have been resolved. Click the Rebuild and refresh button to re-deploy the application Wait for the Terminal to report a successful deployment Refresh the tab of the web application to inspect the modernized Liberty application Previously broken features, such as the Location module, should now be fully operable","title":"vi. Java version upgrades"},{"location":"appmod/8/#vii-conclusion","text":"Having concluded the Application Modernization - WebSphere to Liberty hands-on modules, participants should now complete the corresponding Evaluation quiz and then continue with the remainder of the Level 4 curriculum.","title":"vii. Conclusion"},{"location":"saas/1/","text":"Objectives and requirements IBM Cloud (SaaS) Configuration i. About this lab For the purposes of the Level 4 training curriculum, the hands-on components have been split across both on-premises and Software-as-a-Service (SaaS) environments on IBM Cloud. Both are supported by IBM Technology Zone (ITZ) infrastructure. The On-Premises Installation and Deployment modules extensively covers the process of preparing, installing, and deploying a full-stack IBM watsonx Code Assistant (WCA) service \"on-premises\" (OpenShift on VMware). However, resource and budget constraints for ITZ team means that GPUs are unavailable for on-premises training environments like the one deployed in those modules. The NVIDIA A100 or H100 GPUs required are simply too cost-prohibitive to be made available for individual IBMers and business partners. These costs are beyond the scope of what can be supported for training with on-premises environments. Fortunately, participants do have access to GPUs for SaaS training environments on IBM Cloud. The IBM Cloud (SaaS) Configuration module will guide participants through the process of reserving the necessary Standard plan of WCA via ITZ and configuring the environment for use. Other modules in the L4 curriculum ( Application Modernization ) will each leverage the SaaS environment configured in the following steps. There are two tiers of plans (editions) available for SaaS deployments of WCA: Plan Details Use Cases ESSENTIALS PLAN Accelerates software development, allowing developers to use WCA with integrated generative AI (gen AI) for coding. Generating, explaining, and documenting code. Creation of unit tests. STANDARD PLAN In addition to all the capabilities found in the Essentials plan, the Standard plan includes enterprise Java modernization capabilities, which will be of particular advantage for the Application Modernization modules of the Level 4 curriculum. Java upgrades, regardless of runtime. WebSphere to Liberty transformation. Enhanced unit test generation and code explanation. To ensure that participants have access to the enterprise Java modernization capabilities, the instructions of this module call for provisioning a WCA Standard Plan as the basis of the SaaS environment. ii. Prerequisites There are two high-level architectural components to WCA Standard Plan: WCA extension : The interface through which developers interact with WCA, in the form of an extension (sometimes called a \"plug-in\") running in an integrated development environment (IDE). The IDEs currently supported by WCA are Visual Studio Code (VS Code) and Eclipse. WCA service: The back-end WCA service, to which requests from the extension are made and the results returned to the participant's IDE. It is available as software-as-a-service (SaaS) on IBM Cloud and as deployable software for on-premises deployments. Participants require access to ITZ in order to reserve an environment and complete the hands-on work. If you do not yet have an account with the ITZ, you will need to register for one . iii. Troubleshooting and support If you require assistance or run into issues with the hands-on lab, help is available. Environment issues: The lab environment is managed by IBM Technology Zone. Opening a support case ticket is recommended for issues related to the hands-on environment (provisioning, running, and so on.) Product questions: For questions related to IBM watsonx Code Assistant capabilities, sales opportunities, roadmap, and other such matters, open a thread on the #watsonx-code-assistant Slack channel. iv. Next steps In the following section, participants will prepare the SaaS-based lab environment with the necessary services and configurations through IBM Technology Zone.","title":"1. Objectives and requirements"},{"location":"saas/1/#objectives-and-requirementsibm-cloud-saas-configuration","text":"","title":"Objectives and requirementsIBM Cloud (SaaS) Configuration"},{"location":"saas/1/#i-about-this-lab","text":"For the purposes of the Level 4 training curriculum, the hands-on components have been split across both on-premises and Software-as-a-Service (SaaS) environments on IBM Cloud. Both are supported by IBM Technology Zone (ITZ) infrastructure. The On-Premises Installation and Deployment modules extensively covers the process of preparing, installing, and deploying a full-stack IBM watsonx Code Assistant (WCA) service \"on-premises\" (OpenShift on VMware). However, resource and budget constraints for ITZ team means that GPUs are unavailable for on-premises training environments like the one deployed in those modules. The NVIDIA A100 or H100 GPUs required are simply too cost-prohibitive to be made available for individual IBMers and business partners. These costs are beyond the scope of what can be supported for training with on-premises environments. Fortunately, participants do have access to GPUs for SaaS training environments on IBM Cloud. The IBM Cloud (SaaS) Configuration module will guide participants through the process of reserving the necessary Standard plan of WCA via ITZ and configuring the environment for use. Other modules in the L4 curriculum ( Application Modernization ) will each leverage the SaaS environment configured in the following steps. There are two tiers of plans (editions) available for SaaS deployments of WCA: Plan Details Use Cases ESSENTIALS PLAN Accelerates software development, allowing developers to use WCA with integrated generative AI (gen AI) for coding. Generating, explaining, and documenting code. Creation of unit tests. STANDARD PLAN In addition to all the capabilities found in the Essentials plan, the Standard plan includes enterprise Java modernization capabilities, which will be of particular advantage for the Application Modernization modules of the Level 4 curriculum. Java upgrades, regardless of runtime. WebSphere to Liberty transformation. Enhanced unit test generation and code explanation. To ensure that participants have access to the enterprise Java modernization capabilities, the instructions of this module call for provisioning a WCA Standard Plan as the basis of the SaaS environment.","title":"i. About this lab"},{"location":"saas/1/#ii-prerequisites","text":"There are two high-level architectural components to WCA Standard Plan: WCA extension : The interface through which developers interact with WCA, in the form of an extension (sometimes called a \"plug-in\") running in an integrated development environment (IDE). The IDEs currently supported by WCA are Visual Studio Code (VS Code) and Eclipse. WCA service: The back-end WCA service, to which requests from the extension are made and the results returned to the participant's IDE. It is available as software-as-a-service (SaaS) on IBM Cloud and as deployable software for on-premises deployments. Participants require access to ITZ in order to reserve an environment and complete the hands-on work. If you do not yet have an account with the ITZ, you will need to register for one .","title":"ii. Prerequisites"},{"location":"saas/1/#iii-troubleshooting-and-support","text":"If you require assistance or run into issues with the hands-on lab, help is available. Environment issues: The lab environment is managed by IBM Technology Zone. Opening a support case ticket is recommended for issues related to the hands-on environment (provisioning, running, and so on.) Product questions: For questions related to IBM watsonx Code Assistant capabilities, sales opportunities, roadmap, and other such matters, open a thread on the #watsonx-code-assistant Slack channel.","title":"iii. Troubleshooting and support"},{"location":"saas/1/#iv-next-steps","text":"In the following section, participants will prepare the SaaS-based lab environment with the necessary services and configurations through IBM Technology Zone.","title":"iv. Next steps"},{"location":"saas/2/","text":"Reserve an environment IBM Cloud (SaaS) Configuration The following section is partially based on IBM Cloud Documentation for Setting up your watsonx Code Assistant service in IBM Cloud . Some of the configuration steps\u2014 such as creation of an access group and adding an access group to the deployment space -are automatically handled by IBM Technology Zone provisioning tasks. As such, if you are repeating this deployment for a client production environment, you may wish to reference the complete documentation set. i. IBM Technology Zone The following steps will guide participants through the process for requesting access to an IBM watsonx Code Assistant (WCA) Standard Plan environment from IBM Technology Zone (ITZ). Open the ITZ collection at the following address: URL: https://techzone.ibm.com/collection/wca/environments There are multiple templates and flavors of WCA available: Locate the Request watsonx Code Assistant - Standard [A] tile Hover over and click the IBM Cloud environment / Reserve It [B] button When prompted, click the Reserve an environment button Supply additional details about the ITZ reservation request: Field Value Name Assign the reservation a unique name. Purpose Education Purpose Description Assign the reservation a unique description. Preferred Geography Select the region and data center closest to your location. Start Date and Time Select a time and date for when the reservation will begin. End Date and Time Select a time and date for when the reservation will expire. When ready, verify that you agree to the Terms and Conditions for the environment and finalize your reservation request by clicking Submit [A] . Navigate to the My Reservations tab of the ITZ to monitor the progress. Initially, the request will be marked as Scheduled or Provisioning [A] . Wait for the ITZ reservation to be marked as Ready before continuing to Step 5 Scheduled: marked in grey, the reservation is awaiting approval from ITZ Provisioning: marked in yellow, the reservation is being deployed Ready: marked in green, the reservation has successfully deployed ii. Accessing the service details Once the WCA service has been provisioned, you will receive two emails with the following headers: Reservation Ready on IBM Technology Zone: indicates that the ITZ cluster has been successfully provisioned Account: Action required: You are invited to join an account in IBM Cloud: additional steps required by the administrator (you) in order to link the WCA service to IBM Cloud Steps must be taken to link the WCA service and IBM Cloud accounts at this time. Click the Join now [A] button within the body of the Account: Action required: You are invited to join an account in IBM Cloud email A web browser tab will launch and redirect to IBM Cloud Check the I accept the product Terms and Conditions of this registration form [A] box under the Account Notice header, then click Join account [B] to continue. You will be presented with a prompt asking for your permission to switch your personal IBM Cloud account's view into the WCA service (ITZ-provisioned) IBM Cloud account \u2014 which will resemble something like itz-watsonx-24 . Click Proceed [A] to confirm. LOCATING THE ITZ-PROVISIONED ACCOUNT NAME Participants can retrieve the name of the ITZ-provisioned WCA service account ( itz-watsonx-24 , etc.) by looking at the contents of the Account: Action required: You are invited to join an account in IBM Cloud email: IBM Technology Zone invited you to join the following IBM Cloud account: itz-watsonx-... The IBM Cloud dashboard will now load within your web browser. At this time, confirm you are logged in under the WCA service account by inspecting the drop-down menu [A] as shown in the screenshot below. SWITCHING BETWEEN IBM CLOUD ACCOUNTS You can toggle between various IBM Cloud accounts at-will. However, for the purposes of this lab it's best that you remain under the WCA service [B] account. Open a new web browser tab and navigate to the My Reservations ITZ page to inspect the details of your newly-provisioned service (or follow the link provided in the Reservation Ready on IBM Technology Zone ) email. Click on the newly-provisioned service's tile [A] to inspect the environment's access and authentication details. Scroll down the page to the Reservations Details section and locate the following values. You will need to record these to a notepad for future reference. IBM Cloud Service ID [A] IBM Cloud API key [B] WCA URL [C] Open a new browser tab and navigate to the WCA URL recorded in Step 10. A Resource list view on IBM Cloud will load Click the Launch watsonx Code Assistant [A] button to continue iii. Configuring the environment A new tab will load to present the WCA Dashboard , which for a first-time login will automatically prompt you to configure the environment. When presented with the Set up watsonx Code Assistant for Standard plan panel, click on the Set up [A] button to continue. Type of installation configuration options must be configured. Select Single user [A] . Having specified the installation type, more options will unlock further down the page under the Steps to complete header. Click the blue arrow [A] icon to the right of the Create a deployment space option. Configure the Create a deployment space page as follows: Name [A] : Assign a name of your choosing to the deployment space (e.g. wca-l4 ) Description [B] : Optional Select storage service [C] : Do not change. IBM Technology Zone has automatically assigned Cloud Object Storage space for this reservation. Code assistant service [D] : Click the drop-down menu and select the WCA service belonging to your account. All other fields can remain as their default values. When ready, click Create [E] and remain on the page for the deployment to finish. Once the deployment space has been prepared, a pop-up alert will display \"The space is ready\" . Click the X [A] icon in the top-right corner to dismiss the message and continue with the configuration steps. The web browser will return to the set up wizard, which now displays additional options under the Steps to complete section. Notice that the Create a deployment space step has been marked as complete. Click the blue arrow [A] icon to the right of the Select your license preference for response generations option to continue. The Display of Code Suggestions page permits users to configure how to display code suggestions returned by the WCA service. Do not change any of the settings, but you are welcome to review them if you wish Close the page and return to the set up wizard Check [A] the box to the left of the Select your license preference for response generations option to mark the task as complete. A prompt will appear to indicate that all setup tasks are now complete Click the Go to home page [B] button to conclude the setup iv. Create a service ID and API key Participants will use this API key later to enable Visual Studio Code extensions or Eclipse IDE plug-ins to communicate with the WCA service. Open a new web browser tab and navigate to the IBM Cloud Service IDs admin page. Verify that the Service IDs [A] tab is open and that the Resource Group [B] is set to the ITZ-provisioned WCA account (Steps 7-8) Click Create service ID [C] to continue Set the Name [A] field equal to IBM watsonx Code Assistant user or another name of your choosing. Click the Create [B] button to continue. From the tabs along the left side of the page, click API Keys [A] . Once it loads, click Create [B] to continue. Create a new IBM Cloud API Key with the following parameters: Name [A] : IBM watsonx Code Assistant API key Leaked action [B] : Disable the leaked key Session creation [C] : No When ready, click Create [D] to finalize the key A prompt will appear reporting that API key successfully created . Click the Copy [A] button and record the WCA API Key to your notebook for reference later It's recommended that you also Download the key as a redundancy When ready, close [B] the window v. Add the service ID to the WCA deployment space With the Service ID and WCA API Key now generated, they need to be associated with your WCA instance \u2014 specifically, the WCA Deployment Space . This will be the way in which the WCA extension (VS Code or Eclipse IDE) communicates with the WCA service. Return to the WCA Dashboard web browser tab (where you left off in Step 19). Click the stacked tiles [A] in the top-left corner of the dashboard to expand the menu items along the left-hand side Click on the Deployments [B] tab Within the table of existing deployments, click the wca-l4 [A] deployment (or whatever name you chose to assign the deployment created in Step 15). From the tabs along the top, click the Manage [A] tab. Then, from the left-hand side options, click the Access control [B] tab. Click the Add collaborators [A] button to expand a list of options, then click Add service IDs [B] to continue. Within the table of Service IDs , you should see 1 entry for the IBM watsonx Code Assistant user that was created in Step 21. Click [A] the box to the left of the ID Click [B] the Role box to the right of the ID and select Editor from the drop-down menu Click Add [C] to finalize the operation Confirm that the IBM watsonx Code Assistant user Service ID now appears within the list of approved Collaborators under the Access Control tab. vi. Next steps The deployment and initial configurations of the watsonx Code Assistant (SaaS) Standard Plan service on IBM Cloud is now complete. In the following modules, participants will prepare the WCA extensions and plug-ins for Visual Studio Code and Eclipse IDE, respectively.","title":"2. Reserve an environment"},{"location":"saas/2/#reserve-an-environmentibm-cloud-saas-configuration","text":"The following section is partially based on IBM Cloud Documentation for Setting up your watsonx Code Assistant service in IBM Cloud . Some of the configuration steps\u2014 such as creation of an access group and adding an access group to the deployment space -are automatically handled by IBM Technology Zone provisioning tasks. As such, if you are repeating this deployment for a client production environment, you may wish to reference the complete documentation set.","title":"Reserve an environmentIBM Cloud (SaaS) Configuration"},{"location":"saas/2/#i-ibm-technology-zone","text":"The following steps will guide participants through the process for requesting access to an IBM watsonx Code Assistant (WCA) Standard Plan environment from IBM Technology Zone (ITZ). Open the ITZ collection at the following address: URL: https://techzone.ibm.com/collection/wca/environments There are multiple templates and flavors of WCA available: Locate the Request watsonx Code Assistant - Standard [A] tile Hover over and click the IBM Cloud environment / Reserve It [B] button When prompted, click the Reserve an environment button Supply additional details about the ITZ reservation request: Field Value Name Assign the reservation a unique name. Purpose Education Purpose Description Assign the reservation a unique description. Preferred Geography Select the region and data center closest to your location. Start Date and Time Select a time and date for when the reservation will begin. End Date and Time Select a time and date for when the reservation will expire. When ready, verify that you agree to the Terms and Conditions for the environment and finalize your reservation request by clicking Submit [A] . Navigate to the My Reservations tab of the ITZ to monitor the progress. Initially, the request will be marked as Scheduled or Provisioning [A] . Wait for the ITZ reservation to be marked as Ready before continuing to Step 5 Scheduled: marked in grey, the reservation is awaiting approval from ITZ Provisioning: marked in yellow, the reservation is being deployed Ready: marked in green, the reservation has successfully deployed","title":"i. IBM Technology Zone"},{"location":"saas/2/#ii-accessing-the-service-details","text":"Once the WCA service has been provisioned, you will receive two emails with the following headers: Reservation Ready on IBM Technology Zone: indicates that the ITZ cluster has been successfully provisioned Account: Action required: You are invited to join an account in IBM Cloud: additional steps required by the administrator (you) in order to link the WCA service to IBM Cloud Steps must be taken to link the WCA service and IBM Cloud accounts at this time. Click the Join now [A] button within the body of the Account: Action required: You are invited to join an account in IBM Cloud email A web browser tab will launch and redirect to IBM Cloud Check the I accept the product Terms and Conditions of this registration form [A] box under the Account Notice header, then click Join account [B] to continue. You will be presented with a prompt asking for your permission to switch your personal IBM Cloud account's view into the WCA service (ITZ-provisioned) IBM Cloud account \u2014 which will resemble something like itz-watsonx-24 . Click Proceed [A] to confirm. LOCATING THE ITZ-PROVISIONED ACCOUNT NAME Participants can retrieve the name of the ITZ-provisioned WCA service account ( itz-watsonx-24 , etc.) by looking at the contents of the Account: Action required: You are invited to join an account in IBM Cloud email: IBM Technology Zone invited you to join the following IBM Cloud account: itz-watsonx-... The IBM Cloud dashboard will now load within your web browser. At this time, confirm you are logged in under the WCA service account by inspecting the drop-down menu [A] as shown in the screenshot below. SWITCHING BETWEEN IBM CLOUD ACCOUNTS You can toggle between various IBM Cloud accounts at-will. However, for the purposes of this lab it's best that you remain under the WCA service [B] account. Open a new web browser tab and navigate to the My Reservations ITZ page to inspect the details of your newly-provisioned service (or follow the link provided in the Reservation Ready on IBM Technology Zone ) email. Click on the newly-provisioned service's tile [A] to inspect the environment's access and authentication details. Scroll down the page to the Reservations Details section and locate the following values. You will need to record these to a notepad for future reference. IBM Cloud Service ID [A] IBM Cloud API key [B] WCA URL [C] Open a new browser tab and navigate to the WCA URL recorded in Step 10. A Resource list view on IBM Cloud will load Click the Launch watsonx Code Assistant [A] button to continue","title":"ii. Accessing the service details"},{"location":"saas/2/#iii-configuring-the-environment","text":"A new tab will load to present the WCA Dashboard , which for a first-time login will automatically prompt you to configure the environment. When presented with the Set up watsonx Code Assistant for Standard plan panel, click on the Set up [A] button to continue. Type of installation configuration options must be configured. Select Single user [A] . Having specified the installation type, more options will unlock further down the page under the Steps to complete header. Click the blue arrow [A] icon to the right of the Create a deployment space option. Configure the Create a deployment space page as follows: Name [A] : Assign a name of your choosing to the deployment space (e.g. wca-l4 ) Description [B] : Optional Select storage service [C] : Do not change. IBM Technology Zone has automatically assigned Cloud Object Storage space for this reservation. Code assistant service [D] : Click the drop-down menu and select the WCA service belonging to your account. All other fields can remain as their default values. When ready, click Create [E] and remain on the page for the deployment to finish. Once the deployment space has been prepared, a pop-up alert will display \"The space is ready\" . Click the X [A] icon in the top-right corner to dismiss the message and continue with the configuration steps. The web browser will return to the set up wizard, which now displays additional options under the Steps to complete section. Notice that the Create a deployment space step has been marked as complete. Click the blue arrow [A] icon to the right of the Select your license preference for response generations option to continue. The Display of Code Suggestions page permits users to configure how to display code suggestions returned by the WCA service. Do not change any of the settings, but you are welcome to review them if you wish Close the page and return to the set up wizard Check [A] the box to the left of the Select your license preference for response generations option to mark the task as complete. A prompt will appear to indicate that all setup tasks are now complete Click the Go to home page [B] button to conclude the setup","title":"iii. Configuring the environment"},{"location":"saas/2/#iv-create-a-service-id-and-api-key","text":"Participants will use this API key later to enable Visual Studio Code extensions or Eclipse IDE plug-ins to communicate with the WCA service. Open a new web browser tab and navigate to the IBM Cloud Service IDs admin page. Verify that the Service IDs [A] tab is open and that the Resource Group [B] is set to the ITZ-provisioned WCA account (Steps 7-8) Click Create service ID [C] to continue Set the Name [A] field equal to IBM watsonx Code Assistant user or another name of your choosing. Click the Create [B] button to continue. From the tabs along the left side of the page, click API Keys [A] . Once it loads, click Create [B] to continue. Create a new IBM Cloud API Key with the following parameters: Name [A] : IBM watsonx Code Assistant API key Leaked action [B] : Disable the leaked key Session creation [C] : No When ready, click Create [D] to finalize the key A prompt will appear reporting that API key successfully created . Click the Copy [A] button and record the WCA API Key to your notebook for reference later It's recommended that you also Download the key as a redundancy When ready, close [B] the window","title":"iv. Create a service ID and API key"},{"location":"saas/2/#v-add-the-service-id-to-the-wca-deployment-space","text":"With the Service ID and WCA API Key now generated, they need to be associated with your WCA instance \u2014 specifically, the WCA Deployment Space . This will be the way in which the WCA extension (VS Code or Eclipse IDE) communicates with the WCA service. Return to the WCA Dashboard web browser tab (where you left off in Step 19). Click the stacked tiles [A] in the top-left corner of the dashboard to expand the menu items along the left-hand side Click on the Deployments [B] tab Within the table of existing deployments, click the wca-l4 [A] deployment (or whatever name you chose to assign the deployment created in Step 15). From the tabs along the top, click the Manage [A] tab. Then, from the left-hand side options, click the Access control [B] tab. Click the Add collaborators [A] button to expand a list of options, then click Add service IDs [B] to continue. Within the table of Service IDs , you should see 1 entry for the IBM watsonx Code Assistant user that was created in Step 21. Click [A] the box to the left of the ID Click [B] the Role box to the right of the ID and select Editor from the drop-down menu Click Add [C] to finalize the operation Confirm that the IBM watsonx Code Assistant user Service ID now appears within the list of approved Collaborators under the Access Control tab.","title":"v. Add the service ID to the WCA deployment space"},{"location":"saas/2/#vi-next-steps","text":"The deployment and initial configurations of the watsonx Code Assistant (SaaS) Standard Plan service on IBM Cloud is now complete. In the following modules, participants will prepare the WCA extensions and plug-ins for Visual Studio Code and Eclipse IDE, respectively.","title":"vi. Next steps"},{"location":"saas/3/","text":"Configure the enterprise Java environment IBM Cloud (SaaS) Configuration i. Objectives and rationale As participants will be working with the IBM watsonx Code Assistant (WCA) Standard Plan and interacting with enterprise Java applications, they will need to perform some additional configuration of their Windows or MacOS machines before setting up the extensions (or plug-ins) to the WCA service. Locally you must install both Java and Apache Maven. Details and download links for the two are summarized in the table below. Java Requirements Distribution Details Resources Java Java SE 11 with Java Developer Kit 21. Download Maven Use Maven to build your application. If you are using Liberty Tools and the Liberty Maven plug-in to build your app or project, use at least Maven 3.8.6. Download ii. Java installation Download and install the v21 of the Java Developer Kit (JDK) using the vendor link below. URL: https://www.oracle.com/java/technologies/downloads/?er=221886#jdk21-mac Participants must install JDK 21 From the downloads page, ensure that the JDK 21 [A] option is selected Further down the page, click the operating system [B] option that aligns with your machine operating system type (e.g. macOS ) Click the link for the Download [C] link for the installer that matches your machine's processing architecture (e.g. newer-generation macOS users will probably want to select the ARM64 DMG Installer ) Follow the prompts of the installation wizard and complete the installation before continuing to Step 2 INCOMPATIBILITY WITH JDK 24 Note that the Full stack modernization module in Application Modernization - WebSphere to Liberty will encounter compatibility errors with JDK 24 drivers when attempting to Explain or Modernize the source application. This is owing to a deprecation of sun.misc.Unsafe method as of March 2025. Additional details may be found here. As a result, participants in this lab should ensure they are running JDK 21 (or as early as JDK 11), but specifically not JDK 24. If you are running JDK 24, you should uninstall the JDK from your machine and reinstall with the links provided in Configure the enterprise Java environment . With your preferred Java distribution installed locally, you now need to set the appropriate environment variables. Find the Java installation path on your local machine using the instruction set that corresponds to your local operating system. macOS: Open a Terminal and execute: /usr/libexec/java_home The output should resemble something like: /Library/Java/JavaVirtualMachines/jdk-21.jdk/Contents/Home Record this path to a notepad for reference in Step 3 Windows: Open a Command Prompt and execute: echo %JAVA_HOME% If the JAVA_HOME variable has not yet been set, the Java installations are typically located in the C:\\Program Files\\Java\\jdk-XX.X.X directory Record this path to a notepad for reference in Step 3 Set the JAVA_HOME environment variable. Modify the JAVA_HOME path in the export JAVA_HOME=/.../ statements below if the pathway recorded in Step 2 for your machine differs. For example, if using a different Java developer kit version from JDK 24, replace /jdk-24.jdk/ with the version installed on your machine. macOS: Edit the shell configuration file ( zsh ) with Terminal: nano ~/.zshrc Add the following line to the file: export JAVA_HOME = /Library/Java/JavaVirtualMachines/jdk-21.jdk/Contents/Home export PATH = $JAVA_HOME /bin: $PATH Save by pressing Ctrl + O and hit Enter to confirm the filename Exit by pressing Ctrl + X Windows: Open the Start menu and search for Environment Variables Select Edit the system environment variables option Click the Environment Variables button Under System Variables , click New Set the Variable Name = JAVA_HOME and Variable Value = JDK path from Step 1 (e.g. C:\\Program Files\\Java\\jdk-21 ) Click OK to finalize Apply the changes immediately. macOS : Run the following command with Terminal: source ~/.zshrc If no errors are reported, the variables have been successfully sourced (set) Windows: Close all open command prompts or terminals Open a new Command Prompt to pick up the changes Verify the JAVA_HOME environment variable has been correctly set. macOS: With Terminal, execute: echo $JAVA_HOME The console will return the Java installation path Windows: With Command Prompt, execute: cmd echo %JAVA_HOME% The console will return the Java installation path iii. Maven installation Download and install the latest Maven distribution using either the MacOS or Windows instruction sets below. macOS: The simplest method is using Homebrew to install and deploy Maven locally. To install Homebrew, execute the following with Terminal: /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" With Terminal, execute: brew install maven Follow the prompts (confirming with yes if asked to confirm the install) After the install process has concluded, test with Terminal: mvn --version Windows: Visit the official Maven website: https://maven.apache.org/download.cgi Under Files , click on the binary zip archive link (for example, apache-maven-x.x.x-bin.zip ) Extract the zip file to a location on your local machine (for example, C:\\Apache\\maven\\ ) Replace <path-to-folder> with your machine's installation path and then execute the following with Command Prompt: MAVEN_HOME= <path-to-folder>\\maven\\apache-maven-3.9.9-bin\\apache-maven-3.9.9 Replace <path-to-folder> with your machine's installation path and then execute the following with Command Prompt: <path-to-folder>\\maven\\apache-maven-3.9.9-bin\\apache-maven-3.9.9\\bin Maven is now successfully installed and configured iv. Determine the JDK For Visual Studio (VS) Code and WCA Standard Plans, watsonx Code Assistant needs to determine which Java developer kit (JDK) to use, in the following order of precedence (with 1 being the highest priority): Order of precedence Description 1 Globally-configured Java developer kit for automatic building in the Red Hat extension, which is java.configuration.runtimes in the IDE settings.json file 2 java.jdt.ls.java.home or java.home IDE settings if they are present 3 JAVA_HOME system environment variable, or else JDK_HOME 4 The Java developer kit in the system PATH When WCA Standard Plan features are used, such as Java modernization or upgrade, you can verify which Java developer kit is being used: Within the VS Code IDE, click View and then Output In the Output view, use the dropdown menu to select WCA Look for a message such as Using the Java developer kit that is defined in <location> to run watsonx Code Assistant components. The path is: <path> to determine the feature currently in use v. Set the logging level To adjust logging for the VS Code extension for WCA: From the Extensions panel of VS Code, locate the WCA extension and right-click to pull down a list of available options Select the Extension Settings option Scroll down (or search) for WCA: Log level You may adjust this field from the default INFO setting to alternative options (like WARN ) to cycle between various logging levels vi. Next steps In the following modules, participants will prepare the WCA extensions and plug-ins for Visual Studio Code and Eclipse IDE, respectively.","title":"3. Configure for enterprise Java"},{"location":"saas/3/#configure-the-enterprise-java-environmentibm-cloud-saas-configuration","text":"","title":"Configure the enterprise Java environmentIBM Cloud (SaaS) Configuration"},{"location":"saas/3/#i-objectives-and-rationale","text":"As participants will be working with the IBM watsonx Code Assistant (WCA) Standard Plan and interacting with enterprise Java applications, they will need to perform some additional configuration of their Windows or MacOS machines before setting up the extensions (or plug-ins) to the WCA service. Locally you must install both Java and Apache Maven. Details and download links for the two are summarized in the table below. Java Requirements Distribution Details Resources Java Java SE 11 with Java Developer Kit 21. Download Maven Use Maven to build your application. If you are using Liberty Tools and the Liberty Maven plug-in to build your app or project, use at least Maven 3.8.6. Download","title":"i. Objectives and rationale"},{"location":"saas/3/#ii-java-installation","text":"Download and install the v21 of the Java Developer Kit (JDK) using the vendor link below. URL: https://www.oracle.com/java/technologies/downloads/?er=221886#jdk21-mac Participants must install JDK 21 From the downloads page, ensure that the JDK 21 [A] option is selected Further down the page, click the operating system [B] option that aligns with your machine operating system type (e.g. macOS ) Click the link for the Download [C] link for the installer that matches your machine's processing architecture (e.g. newer-generation macOS users will probably want to select the ARM64 DMG Installer ) Follow the prompts of the installation wizard and complete the installation before continuing to Step 2 INCOMPATIBILITY WITH JDK 24 Note that the Full stack modernization module in Application Modernization - WebSphere to Liberty will encounter compatibility errors with JDK 24 drivers when attempting to Explain or Modernize the source application. This is owing to a deprecation of sun.misc.Unsafe method as of March 2025. Additional details may be found here. As a result, participants in this lab should ensure they are running JDK 21 (or as early as JDK 11), but specifically not JDK 24. If you are running JDK 24, you should uninstall the JDK from your machine and reinstall with the links provided in Configure the enterprise Java environment . With your preferred Java distribution installed locally, you now need to set the appropriate environment variables. Find the Java installation path on your local machine using the instruction set that corresponds to your local operating system. macOS: Open a Terminal and execute: /usr/libexec/java_home The output should resemble something like: /Library/Java/JavaVirtualMachines/jdk-21.jdk/Contents/Home Record this path to a notepad for reference in Step 3 Windows: Open a Command Prompt and execute: echo %JAVA_HOME% If the JAVA_HOME variable has not yet been set, the Java installations are typically located in the C:\\Program Files\\Java\\jdk-XX.X.X directory Record this path to a notepad for reference in Step 3 Set the JAVA_HOME environment variable. Modify the JAVA_HOME path in the export JAVA_HOME=/.../ statements below if the pathway recorded in Step 2 for your machine differs. For example, if using a different Java developer kit version from JDK 24, replace /jdk-24.jdk/ with the version installed on your machine. macOS: Edit the shell configuration file ( zsh ) with Terminal: nano ~/.zshrc Add the following line to the file: export JAVA_HOME = /Library/Java/JavaVirtualMachines/jdk-21.jdk/Contents/Home export PATH = $JAVA_HOME /bin: $PATH Save by pressing Ctrl + O and hit Enter to confirm the filename Exit by pressing Ctrl + X Windows: Open the Start menu and search for Environment Variables Select Edit the system environment variables option Click the Environment Variables button Under System Variables , click New Set the Variable Name = JAVA_HOME and Variable Value = JDK path from Step 1 (e.g. C:\\Program Files\\Java\\jdk-21 ) Click OK to finalize Apply the changes immediately. macOS : Run the following command with Terminal: source ~/.zshrc If no errors are reported, the variables have been successfully sourced (set) Windows: Close all open command prompts or terminals Open a new Command Prompt to pick up the changes Verify the JAVA_HOME environment variable has been correctly set. macOS: With Terminal, execute: echo $JAVA_HOME The console will return the Java installation path Windows: With Command Prompt, execute: cmd echo %JAVA_HOME% The console will return the Java installation path","title":"ii. Java installation"},{"location":"saas/3/#iii-maven-installation","text":"Download and install the latest Maven distribution using either the MacOS or Windows instruction sets below. macOS: The simplest method is using Homebrew to install and deploy Maven locally. To install Homebrew, execute the following with Terminal: /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" With Terminal, execute: brew install maven Follow the prompts (confirming with yes if asked to confirm the install) After the install process has concluded, test with Terminal: mvn --version Windows: Visit the official Maven website: https://maven.apache.org/download.cgi Under Files , click on the binary zip archive link (for example, apache-maven-x.x.x-bin.zip ) Extract the zip file to a location on your local machine (for example, C:\\Apache\\maven\\ ) Replace <path-to-folder> with your machine's installation path and then execute the following with Command Prompt: MAVEN_HOME= <path-to-folder>\\maven\\apache-maven-3.9.9-bin\\apache-maven-3.9.9 Replace <path-to-folder> with your machine's installation path and then execute the following with Command Prompt: <path-to-folder>\\maven\\apache-maven-3.9.9-bin\\apache-maven-3.9.9\\bin Maven is now successfully installed and configured","title":"iii. Maven installation"},{"location":"saas/3/#iv-determine-the-jdk","text":"For Visual Studio (VS) Code and WCA Standard Plans, watsonx Code Assistant needs to determine which Java developer kit (JDK) to use, in the following order of precedence (with 1 being the highest priority): Order of precedence Description 1 Globally-configured Java developer kit for automatic building in the Red Hat extension, which is java.configuration.runtimes in the IDE settings.json file 2 java.jdt.ls.java.home or java.home IDE settings if they are present 3 JAVA_HOME system environment variable, or else JDK_HOME 4 The Java developer kit in the system PATH When WCA Standard Plan features are used, such as Java modernization or upgrade, you can verify which Java developer kit is being used: Within the VS Code IDE, click View and then Output In the Output view, use the dropdown menu to select WCA Look for a message such as Using the Java developer kit that is defined in <location> to run watsonx Code Assistant components. The path is: <path> to determine the feature currently in use","title":"iv. Determine the JDK"},{"location":"saas/3/#v-set-the-logging-level","text":"To adjust logging for the VS Code extension for WCA: From the Extensions panel of VS Code, locate the WCA extension and right-click to pull down a list of available options Select the Extension Settings option Scroll down (or search) for WCA: Log level You may adjust this field from the default INFO setting to alternative options (like WARN ) to cycle between various logging levels","title":"v. Set the logging level"},{"location":"saas/3/#vi-next-steps","text":"In the following modules, participants will prepare the WCA extensions and plug-ins for Visual Studio Code and Eclipse IDE, respectively.","title":"vi. Next steps"},{"location":"saas/4/","text":"Install WCA extension for Visual Studio Code IBM Cloud (SaaS) Configuration i. Objectives and rationale With the IBM watsonx Code Assistant (WCA) service component of the Software-as-a-Service (SaaS) architecture now successfully provisioned via the IBM Technology Zone (ITZ), participants will now need to set up the WCA extension within an integrated development environment (IDE). WCA currently supports both Visual Studio Code ( VS Code ) and Eclipse IDE . This module guides participants through the process of installing VS Code on their local machine. Afterwards, the WCA extension (\"plug-in\") can then be easily integrated with the IDE and authorized for use with the ITZ-provisioned WCA service. WHY INSTALL LOCALLY? Be aware that ITZ only allows two environments to be reserved for education and training purposes at any one time. Reservations for client demonstrations and pilots do not count against this limit. The WCA Standard plan on SaaS (this module) requires at least one reservation slot. The on-premises environment already provisioned through ITZ for the previous On-Premises Installation and Deployment modules is occupying the second available slot. Provisioning an ITZ-hosted virtual machine (VM) environment will require a third slot \u2014 exceeding what ITZ supports. Therefore, to accommodate a virtualized desktop, participants would need to retire and deprovision the on-premises environment that they've already gone to great lengths to set up. Let's avoid that scenario, if possible. IBM watsonx Code Assistant works great on locally-installed IDEs via extensions (or plug-ins) built into VS Code and Eclipse IDE, respectively. In fact, it's the de facto way to interact with the service and provides the best impression for users \u2014 with a less cumbersome experience executing the lab guide instructions and much more responsive IDE interactions. ii. Locally install VS Code Before you configure the extension for VS Code, you must first install the application on your machine. Download the latest Stable Build [A] release of VS Code available for your machine's operating system using the link below. Download : https://code.visualstudio.com Follow along with the installer wizard steps and continue with the hands-on lab instructions once VS Code is running on your local machine. Launch the VS Code application and take note of the sidebar along the left-side. Click the Extensions [A] icon to open the marketplace of services and open source technologies that can be integrated with VS Code. iii. Install the extension Search for the watsonx Code Assistant for Enterprise Java Applications extension, which corresponds to the WCA Standard plan. This plug-in supports all the features of the Essentials plan, plus enterprise Java modernization capabilities, enhanced code explanation, and enhanced unit test generation \u2014 all of which will be necessary for the Level 4 curriculum and hands-on training. Into the search bar [A] under the Extensions tab, enter the following text: watsonx Code Assistant for Enterprise Java Applications After locating the extension, click the Install [B] button When prompted, select Trust Publisher & Install [C] to confirm the procedure OTHER EXTENSIONS ARE AVAILABLE Note that Standard plan installation creates two entries in your Visual Studio Code Extensions panel: one for watsonx Code Assistant and one for watsonx Code Assistant for Enterprise Java Applications . The two extensions are dependencies for this installation. Two other plug-ins are available within VS Code for IBM watsonx Code Assistant specifically, and even more for other offerings such as IBM watsonx Code Assistant for Red Hat Ansible Lightspeed and IBM watsonx Code Assistant for Z . For WCA, there are alternative extensions available for Trial Plan and Essential Plan tiers. To open WCA within VS Code, click on the watsonx Code Assistant [A] icon that has appeared along the left-hand side of VS Code. You will be greeted with a Welcome, let's get started! prompt within the IDE. Now let's authorize the extension for use with the WCA service provisioned on IBM Cloud. From the WCA panel, click Log in with your API key [A] to continue. A drop-down menu will open at the top of the VS Code interface. Copy and paste [A] the WCA API Key that was recorded in Step 24 of Module 2 into the prompt. The interface should display a line of text indicating a Valid API Key has been detected Press Enter to confirm the input When prompted with The extension 'watsonx Code Assistant' wants to sign in using WCA API Key , click Allow [B] Confirm that the extension successfully authenticated with the WCA service by looking for an open Chat session 1 with watsonx along the left side of the WCA Extension tab [A] . If this Chat interface is available and operational, that confirms that VS Code extension has been successfully integrated with the WCA service. iv. Next steps At this stage, the WCA Standard Plan extension for VS Code has been successfully installed and configured. The following module will guide participants through the steps of locally configuring Eclipse IDE for use with the WCA extension.","title":"4. Install WCA extension for Visual Studio Code"},{"location":"saas/4/#install-wca-extension-for-visual-studio-codeibm-cloud-saas-configuration","text":"","title":"Install WCA extension for Visual Studio CodeIBM Cloud (SaaS) Configuration"},{"location":"saas/4/#i-objectives-and-rationale","text":"With the IBM watsonx Code Assistant (WCA) service component of the Software-as-a-Service (SaaS) architecture now successfully provisioned via the IBM Technology Zone (ITZ), participants will now need to set up the WCA extension within an integrated development environment (IDE). WCA currently supports both Visual Studio Code ( VS Code ) and Eclipse IDE . This module guides participants through the process of installing VS Code on their local machine. Afterwards, the WCA extension (\"plug-in\") can then be easily integrated with the IDE and authorized for use with the ITZ-provisioned WCA service. WHY INSTALL LOCALLY? Be aware that ITZ only allows two environments to be reserved for education and training purposes at any one time. Reservations for client demonstrations and pilots do not count against this limit. The WCA Standard plan on SaaS (this module) requires at least one reservation slot. The on-premises environment already provisioned through ITZ for the previous On-Premises Installation and Deployment modules is occupying the second available slot. Provisioning an ITZ-hosted virtual machine (VM) environment will require a third slot \u2014 exceeding what ITZ supports. Therefore, to accommodate a virtualized desktop, participants would need to retire and deprovision the on-premises environment that they've already gone to great lengths to set up. Let's avoid that scenario, if possible. IBM watsonx Code Assistant works great on locally-installed IDEs via extensions (or plug-ins) built into VS Code and Eclipse IDE, respectively. In fact, it's the de facto way to interact with the service and provides the best impression for users \u2014 with a less cumbersome experience executing the lab guide instructions and much more responsive IDE interactions.","title":"i. Objectives and rationale"},{"location":"saas/4/#ii-locally-install-vs-code","text":"Before you configure the extension for VS Code, you must first install the application on your machine. Download the latest Stable Build [A] release of VS Code available for your machine's operating system using the link below. Download : https://code.visualstudio.com Follow along with the installer wizard steps and continue with the hands-on lab instructions once VS Code is running on your local machine. Launch the VS Code application and take note of the sidebar along the left-side. Click the Extensions [A] icon to open the marketplace of services and open source technologies that can be integrated with VS Code.","title":"ii. Locally install VS Code"},{"location":"saas/4/#iii-install-the-extension","text":"Search for the watsonx Code Assistant for Enterprise Java Applications extension, which corresponds to the WCA Standard plan. This plug-in supports all the features of the Essentials plan, plus enterprise Java modernization capabilities, enhanced code explanation, and enhanced unit test generation \u2014 all of which will be necessary for the Level 4 curriculum and hands-on training. Into the search bar [A] under the Extensions tab, enter the following text: watsonx Code Assistant for Enterprise Java Applications After locating the extension, click the Install [B] button When prompted, select Trust Publisher & Install [C] to confirm the procedure OTHER EXTENSIONS ARE AVAILABLE Note that Standard plan installation creates two entries in your Visual Studio Code Extensions panel: one for watsonx Code Assistant and one for watsonx Code Assistant for Enterprise Java Applications . The two extensions are dependencies for this installation. Two other plug-ins are available within VS Code for IBM watsonx Code Assistant specifically, and even more for other offerings such as IBM watsonx Code Assistant for Red Hat Ansible Lightspeed and IBM watsonx Code Assistant for Z . For WCA, there are alternative extensions available for Trial Plan and Essential Plan tiers. To open WCA within VS Code, click on the watsonx Code Assistant [A] icon that has appeared along the left-hand side of VS Code. You will be greeted with a Welcome, let's get started! prompt within the IDE. Now let's authorize the extension for use with the WCA service provisioned on IBM Cloud. From the WCA panel, click Log in with your API key [A] to continue. A drop-down menu will open at the top of the VS Code interface. Copy and paste [A] the WCA API Key that was recorded in Step 24 of Module 2 into the prompt. The interface should display a line of text indicating a Valid API Key has been detected Press Enter to confirm the input When prompted with The extension 'watsonx Code Assistant' wants to sign in using WCA API Key , click Allow [B] Confirm that the extension successfully authenticated with the WCA service by looking for an open Chat session 1 with watsonx along the left side of the WCA Extension tab [A] . If this Chat interface is available and operational, that confirms that VS Code extension has been successfully integrated with the WCA service.","title":"iii. Install the extension"},{"location":"saas/4/#iv-next-steps","text":"At this stage, the WCA Standard Plan extension for VS Code has been successfully installed and configured. The following module will guide participants through the steps of locally configuring Eclipse IDE for use with the WCA extension.","title":"iv. Next steps"},{"location":"saas/5/","text":"Install WCA plug-in for Eclipse IDE IBM Cloud (SaaS) Configuration i. Objectives and rationale With the IBM watsonx Code Assistant (WCA) service component of the Software-as-a-Service (SaaS) architecture now successfully provisioned via the IBM Technology Zone (ITZ), participants will now need to set up the WCA extension within an integrated development environment (IDE). WCA currently supports both Visual Studio Code ( VS Code ) and Eclipse IDE . This module guides participants through the process of installing Eclipse IDE on their local machine. Afterwards, the WCA extension (\"plug-in\") can then be easily integrated with the IDE and authorized for use with the ITZ-provisioned WCA service. WHY INSTALL LOCALLY? Be aware that ITZ only allows two environments to be reserved for education and training purposes at any one time. Reservations for client demonstrations and pilots do not count against this limit. The WCA Standard plan on SaaS requires at least one reservation slot. The on-premises environment already provisioned through ITZ for the previous On-Premises Installation and Deployment modules is occupying the second available slot. Provisioning an ITZ-hosted virtual machine (VM) environment will require a third slot \u2014 exceeding what ITZ supports. Therefore, to accommodate a virtualized desktop, participants would need to retire and deprovision the on-premises environment that they've already gone to great lengths to set up. Let's avoid that scenario, if possible. IBM watsonx Code Assistant works great on locally-installed IDEs via extensions built into VS Code and Eclipse IDE. In fact, it's the de facto way to interact with the service and provides the best impression for users by far \u2014 with a less cumbersome experience with the lab guide instructions and much more responsive IDE interactions. ii. Locally install Eclipse IDE With the IBM Cloud credentials set up, the next step will be to install the Eclipse IDE locally and then integrate it with the WCA service via the IDE plug-in. Download the Eclipse IDE from the Eclipse Foundation. Use the Eclipse Installer , recommended at the top of the download page [A] Select the version appropriate to your local machine's operating system URL: https://www.eclipse.org/downloads/packages/ Run the installer on your local machine. Select the Eclipse IDE for Java Developers option [A] Follow along with the remaining prompts until the Eclipse IDE has been installed Once the install process has concluded, click Launch [B] from the installer or manually launch the Eclipse IDE application yourself Upon launching the Eclipse IDE for the first time, users will be prompted to Select a directory as workspace . Choose a directory on your local machine [A] you feel appropriate (or select the one selected by default for you) and then click Launch [B] to continue. iii. Install the plug-in Open the Eclipse Marketplace listing for IBM watsonx Code Assistant for Enterprise Java Applications plug-in, which corresponds to the WCA Standard plan. This plug-in supports all the features of the Essentials plan, plus enterprise Java modernization capabilities, enhanced code explanation, and enhanced unit test generation \u2014 all of which will be necessary for the Level 4 curriculum. Locate the Install button on the Eclipse Marketplace page. The easiest method for installing this plug-in is to click and hold [A] the mouse button down on this Install button, then drag and release [B] on top of the open Eclipse IDE application. An install wizard will open within the Eclipse IDE automatically Confirm Selected Features : verify the two WCA options are selected [C] and Confirm [D] Installation should take about 1 minute to conclude Wait for the Review Licenses panel to load Within the Review Licenses panel, read through all three license agreements [A] and click the I accept the terms of the license agreements [B] option. To progress the installation, click Finish Wait a few moments for the Trust Authorities panel to load Within the Trust Authorities , examine the Authority / Update Site table at the top to load. Select [A] (tick the box) left of the https://public.dhe.ibm.com option field All other fields can remain as their default settings Click the Trust Selected [B] button to continue Wait 1 to 2 minutes for the software to continue installing After a few moments, a Software Updates window will prompt you to restart the Eclipse IDE. Click the Restart Now [A] button to re-launch the application Installation of the WCA plug-in software and dependencies will continue after launching Wait a moment for the installation to conclude iv. Validate the plug-in At this stage, the WCA plug-in for Eclipse IDE has been successfully installed on your local machine. Now you must authorize the plug-in for use with the WCA Standard Plan on IBM Cloud. From the Eclipse application, select Window , then Show View , and finally Other [A] to open the plug-ins browser. From the table of option, scroll down and locate watsonx Code Assistant . Double-click on the folder (or click the arrow to the left of it) Select the Chat [A] option and then click Open [B] A new window (among several open tabs) will open at the bottom of the Eclipse IDE [A] . Scroll down within the window to the bottom of the page Click the Log in with your API key [B] button A new Preferences window will open. Within the API Key field [A] , paste the WCA API Key that was recorded in Step 24 of Module 2 into the prompt The remaining settings can remain at the default values Click the Apply and Close [B] button Click No [C] when prompted to create a Secure Storage - Password Hint Needed v. Conclusion The Eclipse IDE plug-in for IBM watsonx Code Assistant has been successfully installed and authorized for use with the WCA Standard (SaaS) plan deployed on IBM Cloud. The environment is now ready for use with the Application Modernization modules of the Level 4 curriculum. Having concluded the IBM Cloud (SaaS) Configuration hands-on modules, complete the corresponding Evaluation quiz and then continue with the remainder of the Level 4 curriculum.","title":"5. Install WCA plug-in for Eclipse IDE"},{"location":"saas/5/#install-wca-plug-in-for-eclipse-ideibm-cloud-saas-configuration","text":"","title":"Install WCA plug-in for Eclipse IDEIBM Cloud (SaaS) Configuration"},{"location":"saas/5/#i-objectives-and-rationale","text":"With the IBM watsonx Code Assistant (WCA) service component of the Software-as-a-Service (SaaS) architecture now successfully provisioned via the IBM Technology Zone (ITZ), participants will now need to set up the WCA extension within an integrated development environment (IDE). WCA currently supports both Visual Studio Code ( VS Code ) and Eclipse IDE . This module guides participants through the process of installing Eclipse IDE on their local machine. Afterwards, the WCA extension (\"plug-in\") can then be easily integrated with the IDE and authorized for use with the ITZ-provisioned WCA service. WHY INSTALL LOCALLY? Be aware that ITZ only allows two environments to be reserved for education and training purposes at any one time. Reservations for client demonstrations and pilots do not count against this limit. The WCA Standard plan on SaaS requires at least one reservation slot. The on-premises environment already provisioned through ITZ for the previous On-Premises Installation and Deployment modules is occupying the second available slot. Provisioning an ITZ-hosted virtual machine (VM) environment will require a third slot \u2014 exceeding what ITZ supports. Therefore, to accommodate a virtualized desktop, participants would need to retire and deprovision the on-premises environment that they've already gone to great lengths to set up. Let's avoid that scenario, if possible. IBM watsonx Code Assistant works great on locally-installed IDEs via extensions built into VS Code and Eclipse IDE. In fact, it's the de facto way to interact with the service and provides the best impression for users by far \u2014 with a less cumbersome experience with the lab guide instructions and much more responsive IDE interactions.","title":"i. Objectives and rationale"},{"location":"saas/5/#ii-locally-install-eclipse-ide","text":"With the IBM Cloud credentials set up, the next step will be to install the Eclipse IDE locally and then integrate it with the WCA service via the IDE plug-in. Download the Eclipse IDE from the Eclipse Foundation. Use the Eclipse Installer , recommended at the top of the download page [A] Select the version appropriate to your local machine's operating system URL: https://www.eclipse.org/downloads/packages/ Run the installer on your local machine. Select the Eclipse IDE for Java Developers option [A] Follow along with the remaining prompts until the Eclipse IDE has been installed Once the install process has concluded, click Launch [B] from the installer or manually launch the Eclipse IDE application yourself Upon launching the Eclipse IDE for the first time, users will be prompted to Select a directory as workspace . Choose a directory on your local machine [A] you feel appropriate (or select the one selected by default for you) and then click Launch [B] to continue.","title":"ii. Locally install Eclipse IDE"},{"location":"saas/5/#iii-install-the-plug-in","text":"Open the Eclipse Marketplace listing for IBM watsonx Code Assistant for Enterprise Java Applications plug-in, which corresponds to the WCA Standard plan. This plug-in supports all the features of the Essentials plan, plus enterprise Java modernization capabilities, enhanced code explanation, and enhanced unit test generation \u2014 all of which will be necessary for the Level 4 curriculum. Locate the Install button on the Eclipse Marketplace page. The easiest method for installing this plug-in is to click and hold [A] the mouse button down on this Install button, then drag and release [B] on top of the open Eclipse IDE application. An install wizard will open within the Eclipse IDE automatically Confirm Selected Features : verify the two WCA options are selected [C] and Confirm [D] Installation should take about 1 minute to conclude Wait for the Review Licenses panel to load Within the Review Licenses panel, read through all three license agreements [A] and click the I accept the terms of the license agreements [B] option. To progress the installation, click Finish Wait a few moments for the Trust Authorities panel to load Within the Trust Authorities , examine the Authority / Update Site table at the top to load. Select [A] (tick the box) left of the https://public.dhe.ibm.com option field All other fields can remain as their default settings Click the Trust Selected [B] button to continue Wait 1 to 2 minutes for the software to continue installing After a few moments, a Software Updates window will prompt you to restart the Eclipse IDE. Click the Restart Now [A] button to re-launch the application Installation of the WCA plug-in software and dependencies will continue after launching Wait a moment for the installation to conclude","title":"iii. Install the plug-in"},{"location":"saas/5/#iv-validate-the-plug-in","text":"At this stage, the WCA plug-in for Eclipse IDE has been successfully installed on your local machine. Now you must authorize the plug-in for use with the WCA Standard Plan on IBM Cloud. From the Eclipse application, select Window , then Show View , and finally Other [A] to open the plug-ins browser. From the table of option, scroll down and locate watsonx Code Assistant . Double-click on the folder (or click the arrow to the left of it) Select the Chat [A] option and then click Open [B] A new window (among several open tabs) will open at the bottom of the Eclipse IDE [A] . Scroll down within the window to the bottom of the page Click the Log in with your API key [B] button A new Preferences window will open. Within the API Key field [A] , paste the WCA API Key that was recorded in Step 24 of Module 2 into the prompt The remaining settings can remain at the default values Click the Apply and Close [B] button Click No [C] when prompted to create a Secure Storage - Password Hint Needed","title":"iv. Validate the plug-in"},{"location":"saas/5/#v-conclusion","text":"The Eclipse IDE plug-in for IBM watsonx Code Assistant has been successfully installed and authorized for use with the WCA Standard (SaaS) plan deployed on IBM Cloud. The environment is now ready for use with the Application Modernization modules of the Level 4 curriculum. Having concluded the IBM Cloud (SaaS) Configuration hands-on modules, complete the corresponding Evaluation quiz and then continue with the remainder of the Level 4 curriculum.","title":"v. Conclusion"}]}