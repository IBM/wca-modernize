{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"watsonx Code Assistant Level 4 i. Introduction The curriculum of watsonx Code Assistant Level 4 is designed to teach IBM technical sellers and business partners on how to best plan, execute on, and deploy IBM watsonx Code Assistant . Level 4 learning plans assume that participants have the technical background and proficiency to demonstrate a product or solution to a client, as well as a deep level of understanding for how it can help the client achieve their business goals. Level 4 learning plans are the next logical learning step that goes beyond the demonstrations covered in the Level 3 learning. In keeping with the offering's hybrid cloud architecture, this will encompass deployments both on-premises and for Software-as-a-Service (SaaS) cloud. The hands-on modules included within this GitHub documentation\u2014 and outlined in the section below \u2014are part of a broader Level 4 curriculum hosted on IBM YourLearning and IBM Training . To view the curriculum in its entirety and receive full accreditation for completing the Level 4 material, visit the following links: IBM YourLearning (IBMers): https://yourlearning.ibm.com/activity/PLAN-5C0B3BB33307 IBM Training (Business Partners): https://www.ibm.com/training/learning-path/watsonx-code-assistant-level-4-1012 The \"Practitioners\" (Deploy) coursework extensively covers deployment of the service for both on-premises and IBM Cloud environments. Before taking this course, those enrolling should have earned the watsonx Code Assistant Sales Foundation badge and the watsonx Code Assistant Technical Sales Intermediate badge, and have the technical background and proficiency at giving hands-on demos to clients. ii. WCA Portfolio IBM watsonx Code Assistant ( WCA ) is the flagship offering in a suite of generative AI (gen AI) code assistant products, which also include offerings for Ansible Automation Platform (via IBM watsonx Code Assistant for Red Hat Ansible Lightspeed) and IBM Z modernization (via IBM watsonx Code Assistant for Z). The WCA portfolio accelerates Software Development Lifecycle (SDLC) tasks with AI-powered capabilities including context-aware code generation, explanation, documentation, translation, and unit test generation. It does so while maintaining the principles of trust, security, and compliance with regards to IBM client's data and intellectual property (IP). WCA offerings are powered by IBM Granite foundation models that include state-of-the-art large language models (LLMs) designed for code. For offerings such as WCA for Ansible Lightspeed and WCA for Z, bespoke code models\u2014 tailored to working with Ansible Automation Platform and COBOL-to-Z use cases, respectively \u2014are invoked. Universally true for all of the WCA offerings is that they are geared towards helping IT teams create high-quality code using AI-generated recommendations, based on natural language requests or existing source code. These AI models, and the recommendations they generate, are seamlessly integrated via extensions with the world's most popular integrated development environments (IDEs) \u2013 including Visual Studio Code and Eclipse. USE CASES TO PURSUE The flagship offering, IBM watsonx Code Assistant is the premiere IBM technology for generating enterprise-grade code and applications using IBM Granite large language models (LLMs). It has a wide gamut of capabilities which will be covered in subsequent sections of this presentation. When prospecting clients, look out for use cases involving: real-time code recommendations; chat with code capabilities; code explainability; automated generation of code documentation; code testing and validation; as well as modernization of enterprise Java code. IBM watsonx Code Assistant for Red Hat Ansible Lightspeed (or \"WCA for Ansible Lightspeed\" in shorthand) allows clients to write automation jobs faster with AI-generated recommendations, using natural language prompts to instruct the solution on the types of automation jobs that require generation. Look out for use cases and opportunities with clients that involve enterprise organizations deploying (or automating) IT infrastructure with the Red Hat Ansible Automation Platform (AAP), which is a required enterprise license for using WCA for Ansible Lightspeed. IBM watsonx Code Assistant for Z (or \"WCA for Z\" in shorthand) is IBM's solution for selectively modernizing COBOL business services into Java applications running on IBM Z mainframe systems. Look out for client opportunities or use cases that involve integrating refactored COBOL (or Java) code into existing COBOL applications running on IBM Z, where it's critical that the full interoperability is maintained between environments and that quality of service is maintained. The portfolio of solutions under the IBM watsonx Code Assistant family is expansive in terms of capabilities and the types of use cases that can be addressed. Aligning the best-fit solution to the appropriate use cases, languages, applications, and infrastructure is critical. Use the following guidelines to help shape client discussions and opportunities. IBM watsonx Code Assistant supports over 115 different programming languages for code. In particular, languages and formats such as Java, C, JSON, JavaScript, HTML, and PHP are subjects in which WCA \u201cMajors\u201d and excels. Other languages such as Ruby, SQL, and Swift could be considered \u201cMinors\u201d where the generalized code model can work with the language, but has less training data to base those recommendations on. These percentages and training data volumes will continue to evolve as the Granite code models mature. WCA is also available via Software-as-a-Service (SaaS) consumption on cloud and deployable on-premises, which is a unique differentiator over other gen AI code solutions in the marketplace. LANGUAGES, APPLICATIONS, AND INFRASTRUCTURE TO PURSUE For those familiar with other WCA offerings\u2014 such as IBM watsonx Code Assistant for Red Hat Ansible Lightspeed and IBM watsonx Code Assistant for Z \u2014the generalized code model approach taken by WCA differs from the specialized code model approach of those two aforementioned offerings. The WCA for Ansible Lightspeed flavor of IBM Granite code models specializes (\u201dMajors\") only in Red Hat Ansible Playbooks and YAML (Yet Another Markup Language) formats. Similarly, the IBM Granite code model used by WCA for Z specializes in transforming COBOL mainframe code into modernized Java code for IBM Z systems. Ansible Playbooks and COBOL are supported (\u201dMinor\") languages for the generalized IBM Granite code models\u2014 and therefore are supported by WCA \u2014but if a client wishes to specialize in those particular languages and frameworks, they would be well advised to utilize the bespoke WCA for Ansible Lightspeed and WCA for Z offerings to do so. For WCA for Ansible Lightspeed , hone in on opportunities involving: Ansible Playbooks, AAP environments, YAML-based automation scripts, and containerized applications running atop of Red Hat OpenShift. For WCA for Z , focus on opportunities involving: z/OS application modernization, COBOL to modernized Java transformations, and COBOL to IBM Z mainframe use cases. iii. Curriculum The curriculum for the Level 4 hands-on labs is segmented across 3 chapters, each containing multiple modules that address topics of on-premises cluster deployments, configuration of Software-as-a-Service (SaaS) deployments on cloud, and modernization of legacy WebSphere Application Server code into WebSphere Liberty. CHAPTER MODULES On-Premises Installation and Deployment 1. Objectives and requirements 2. Reserve an environment 3. Bastion host setup 4. Cluster preparation 5. Install prerequisite software 6. Install IBM Software Hub 7. Install IBM watsonx Code Assistant IBM Cloud (SaaS) Configuration 1. Objectives and requirements 2. Reserve an environment 3. Configure the Java environment 4. Install VS Code extension 5. Install Eclipse plug-in Application Modernization - WebSphere to Liberty 1. Objectives and requirements 2. Basic migration capabilities 3. Configuration management 4. APIs and libraries 5. EJB modernization 6. JMS integration 7. Security modernization 8. Full stack modernization","title":"Introduction"},{"location":"#watsonx-code-assistant-level-4","text":"","title":"watsonx Code Assistant Level 4"},{"location":"#i-introduction","text":"The curriculum of watsonx Code Assistant Level 4 is designed to teach IBM technical sellers and business partners on how to best plan, execute on, and deploy IBM watsonx Code Assistant . Level 4 learning plans assume that participants have the technical background and proficiency to demonstrate a product or solution to a client, as well as a deep level of understanding for how it can help the client achieve their business goals. Level 4 learning plans are the next logical learning step that goes beyond the demonstrations covered in the Level 3 learning. In keeping with the offering's hybrid cloud architecture, this will encompass deployments both on-premises and for Software-as-a-Service (SaaS) cloud. The hands-on modules included within this GitHub documentation\u2014 and outlined in the section below \u2014are part of a broader Level 4 curriculum hosted on IBM YourLearning and IBM Training . To view the curriculum in its entirety and receive full accreditation for completing the Level 4 material, visit the following links: IBM YourLearning (IBMers): https://yourlearning.ibm.com/activity/PLAN-5C0B3BB33307 IBM Training (Business Partners): https://www.ibm.com/training/learning-path/watsonx-code-assistant-level-4-1012 The \"Practitioners\" (Deploy) coursework extensively covers deployment of the service for both on-premises and IBM Cloud environments. Before taking this course, those enrolling should have earned the watsonx Code Assistant Sales Foundation badge and the watsonx Code Assistant Technical Sales Intermediate badge, and have the technical background and proficiency at giving hands-on demos to clients.","title":"i. Introduction"},{"location":"#ii-wca-portfolio","text":"IBM watsonx Code Assistant ( WCA ) is the flagship offering in a suite of generative AI (gen AI) code assistant products, which also include offerings for Ansible Automation Platform (via IBM watsonx Code Assistant for Red Hat Ansible Lightspeed) and IBM Z modernization (via IBM watsonx Code Assistant for Z). The WCA portfolio accelerates Software Development Lifecycle (SDLC) tasks with AI-powered capabilities including context-aware code generation, explanation, documentation, translation, and unit test generation. It does so while maintaining the principles of trust, security, and compliance with regards to IBM client's data and intellectual property (IP). WCA offerings are powered by IBM Granite foundation models that include state-of-the-art large language models (LLMs) designed for code. For offerings such as WCA for Ansible Lightspeed and WCA for Z, bespoke code models\u2014 tailored to working with Ansible Automation Platform and COBOL-to-Z use cases, respectively \u2014are invoked. Universally true for all of the WCA offerings is that they are geared towards helping IT teams create high-quality code using AI-generated recommendations, based on natural language requests or existing source code. These AI models, and the recommendations they generate, are seamlessly integrated via extensions with the world's most popular integrated development environments (IDEs) \u2013 including Visual Studio Code and Eclipse. USE CASES TO PURSUE The flagship offering, IBM watsonx Code Assistant is the premiere IBM technology for generating enterprise-grade code and applications using IBM Granite large language models (LLMs). It has a wide gamut of capabilities which will be covered in subsequent sections of this presentation. When prospecting clients, look out for use cases involving: real-time code recommendations; chat with code capabilities; code explainability; automated generation of code documentation; code testing and validation; as well as modernization of enterprise Java code. IBM watsonx Code Assistant for Red Hat Ansible Lightspeed (or \"WCA for Ansible Lightspeed\" in shorthand) allows clients to write automation jobs faster with AI-generated recommendations, using natural language prompts to instruct the solution on the types of automation jobs that require generation. Look out for use cases and opportunities with clients that involve enterprise organizations deploying (or automating) IT infrastructure with the Red Hat Ansible Automation Platform (AAP), which is a required enterprise license for using WCA for Ansible Lightspeed. IBM watsonx Code Assistant for Z (or \"WCA for Z\" in shorthand) is IBM's solution for selectively modernizing COBOL business services into Java applications running on IBM Z mainframe systems. Look out for client opportunities or use cases that involve integrating refactored COBOL (or Java) code into existing COBOL applications running on IBM Z, where it's critical that the full interoperability is maintained between environments and that quality of service is maintained. The portfolio of solutions under the IBM watsonx Code Assistant family is expansive in terms of capabilities and the types of use cases that can be addressed. Aligning the best-fit solution to the appropriate use cases, languages, applications, and infrastructure is critical. Use the following guidelines to help shape client discussions and opportunities. IBM watsonx Code Assistant supports over 115 different programming languages for code. In particular, languages and formats such as Java, C, JSON, JavaScript, HTML, and PHP are subjects in which WCA \u201cMajors\u201d and excels. Other languages such as Ruby, SQL, and Swift could be considered \u201cMinors\u201d where the generalized code model can work with the language, but has less training data to base those recommendations on. These percentages and training data volumes will continue to evolve as the Granite code models mature. WCA is also available via Software-as-a-Service (SaaS) consumption on cloud and deployable on-premises, which is a unique differentiator over other gen AI code solutions in the marketplace. LANGUAGES, APPLICATIONS, AND INFRASTRUCTURE TO PURSUE For those familiar with other WCA offerings\u2014 such as IBM watsonx Code Assistant for Red Hat Ansible Lightspeed and IBM watsonx Code Assistant for Z \u2014the generalized code model approach taken by WCA differs from the specialized code model approach of those two aforementioned offerings. The WCA for Ansible Lightspeed flavor of IBM Granite code models specializes (\u201dMajors\") only in Red Hat Ansible Playbooks and YAML (Yet Another Markup Language) formats. Similarly, the IBM Granite code model used by WCA for Z specializes in transforming COBOL mainframe code into modernized Java code for IBM Z systems. Ansible Playbooks and COBOL are supported (\u201dMinor\") languages for the generalized IBM Granite code models\u2014 and therefore are supported by WCA \u2014but if a client wishes to specialize in those particular languages and frameworks, they would be well advised to utilize the bespoke WCA for Ansible Lightspeed and WCA for Z offerings to do so. For WCA for Ansible Lightspeed , hone in on opportunities involving: Ansible Playbooks, AAP environments, YAML-based automation scripts, and containerized applications running atop of Red Hat OpenShift. For WCA for Z , focus on opportunities involving: z/OS application modernization, COBOL to modernized Java transformations, and COBOL to IBM Z mainframe use cases.","title":"ii. WCA Portfolio"},{"location":"#iii-curriculum","text":"The curriculum for the Level 4 hands-on labs is segmented across 3 chapters, each containing multiple modules that address topics of on-premises cluster deployments, configuration of Software-as-a-Service (SaaS) deployments on cloud, and modernization of legacy WebSphere Application Server code into WebSphere Liberty. CHAPTER MODULES On-Premises Installation and Deployment 1. Objectives and requirements 2. Reserve an environment 3. Bastion host setup 4. Cluster preparation 5. Install prerequisite software 6. Install IBM Software Hub 7. Install IBM watsonx Code Assistant IBM Cloud (SaaS) Configuration 1. Objectives and requirements 2. Reserve an environment 3. Configure the Java environment 4. Install VS Code extension 5. Install Eclipse plug-in Application Modernization - WebSphere to Liberty 1. Objectives and requirements 2. Basic migration capabilities 3. Configuration management 4. APIs and libraries 5. EJB modernization 6. JMS integration 7. Security modernization 8. Full stack modernization","title":"iii. Curriculum"},{"location":"appmod/1/","text":"Objectives and requirements Application Modernization - WebSphere to Liberty i. About this lab SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". The approach taken with each module of Application Modernization - WebSphere to Liberty , engaging with IBM watsonx Code Assistant's (WCA) Chat functionality in the chapters ahead, is to emulate the experience of collaborating with a trusted colleague on how to best take on the modernization of WebSphere Application Server code: segmented by specific use cases, tackling particular business functions that need to be revitalized for cloud-native, and exploring precise pain points within a client's code base. The WCA Chat experience reflects how you and that trusted colleague might, together, approach a scenario like modernizing usage of Enterprise JavaBeans with WebSphere Liberty, as an example. Thinking about modernization in discrete scenarios such as these, where the aperture is narrowly focused on a specific piece of functionality or use case\u2014 rather than trying to modernize an entire, complex application stack altogether \u2014has immense value. It is far more akin and practical to the real-world scenarios that you will encounter during engagements with clients: as a seller; a business partner; a trusted advisor. Entrusted with bestowing best practices for how that client can modernize specific pain points in their application code; not taking on the task of modernizing the entirety of their application stack \"in one go.\" Crafting complex modernization plans for enterprise-scale applications cannot be approached as explicit \"A, then B, followed by C\" rulebooks or rigid decision trees. It is essential that you understand how to approach modernization as a collaborative, problem-solving oriented, question-and-answer refinement exercise. WCA Chat, which you will use to these ends in the following modules, is an ideal mechanism for refining the correct modernization approach. ii. Prerequisites This lab requires that participants have previously completed the IBM Cloud (SaaS) Configuration lab in its entirety. Those conducting the hands-on sections of this lab will require access to a deployed instance of WCA Standard Plan and have successfully integrated with the WCA service via either the Visual Studio Code ( VS Code ) extension or Eclipse IDE plug-ins. iii. Hands-on topics For each module of the Application Modernization - WebSphere to Liberty lab, participants will have the opportunity to dissect the contents and purpose of legacy WebSphere Application Server ( WAS ) code, examine its limitations in the context of more up-to-date alternatives, and then compare that to a best-practices implementation of that equivalent codebase written in WebSphere Liberty . Afterwards, participants will go hands-on with the IBM watsonx Code Assistant ( WCA ) Standard environment to reproduce the steps of modernizing the WAS legacy code into Liberty code. Differences in the two code bases and the benefits of WCA's approach to code modernization will also be examined. MODERNIZATION TASK WEBSPHERE APPLICATION LIBERTY APPLICATION Basic migration capabilities WebSphere Enterprise Archive (EAR) configuration, at enterprise scale, becomes cumbersome to maintain and can often result in frequent deployment delays (or human-induced configuration errors) each time the modules need to be modified. Liberty Web Archive (WAR) configurations remove the need for multiple external descriptors and consolidate settings into a single, unified file. Configuration and dependency management WebSphere class loader configuration implementation suffers from significant (and unnecessary) complexity owing to bloated class-loader configurations. Liberty server configuration is expected to manage dependencies and simplify the overall process of application configuration. APIs and libraries WebSphere Scheduler APIs may not be immediately portable in their current form, they are potentially more costly to maintain than Liberty counterparts, and have less functionality due to outdated implementations. Liberty's Jakarta EE-templated APIs are more transferable across vendors and platforms, are built to cloud-native architecture by design, and are portable to containers. Enterprise JavaBeans (EJB) modernization WebSphere EJB with XML represent server-side components used by Java Enterprise Edition (Java EE or Jakarta EE) to encapsulate repeatable business logic. They are more challenging to maintain and prone to human-induced errors. Liberty EJBs with annotations use Java instead of XML, applying them directly within Java classes for configuration. In many cases, this reduces the need for external XML files and eases maintainability. Java Message Service integration WebSphere's MQ JMS integration uses complex configurations made up of verbose XML or admin console requirements. They can be difficult to maintain due to their dispersed nature. Liberty's MQ JMS integration provides a more centralized pattern to simplify the process of troubleshooting messaging integrations and maintaining existing policies. Security modernization WebSphere's XML-based security is challenging to understand and maintain due to XML file separation from the supporting Java code, which tends to lower developer productivity due to frequent context-switching. Liberty's annotation-based security reduces the need for external configuration and instead centralizes security declarations closer to the actual code implementation. iv. Troubleshooting If you require assistance or run into issues with the hands-on lab, help is available. Environment issues: The lab environment is managed by IBM Technology Zone. Opening a support case ticket is recommended for issues related to the hands-on environment (provisioning, running, and so on.) Product questions: For questions related to IBM watsonx Code Assistant capabilities, sales opportunities, roadmap, and other such matters, open a thread on the #watsonx-code-assistant Slack channel. v. Next steps In the following section, participants will explore fundamental modernization and migration techniques using legacy WebSphere Enterprise Archive ( EAR ) configuration code \u2014 ultimately producing a modernized Liberty Web Archive ( WAR ) configuration codebase.","title":"1. Objectives and requirements"},{"location":"appmod/1/#objectives-and-requirementsapplication-modernization-websphere-to-liberty","text":"","title":"Objectives and requirementsApplication Modernization - WebSphere to Liberty"},{"location":"appmod/1/#i-about-this-lab","text":"SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". The approach taken with each module of Application Modernization - WebSphere to Liberty , engaging with IBM watsonx Code Assistant's (WCA) Chat functionality in the chapters ahead, is to emulate the experience of collaborating with a trusted colleague on how to best take on the modernization of WebSphere Application Server code: segmented by specific use cases, tackling particular business functions that need to be revitalized for cloud-native, and exploring precise pain points within a client's code base. The WCA Chat experience reflects how you and that trusted colleague might, together, approach a scenario like modernizing usage of Enterprise JavaBeans with WebSphere Liberty, as an example. Thinking about modernization in discrete scenarios such as these, where the aperture is narrowly focused on a specific piece of functionality or use case\u2014 rather than trying to modernize an entire, complex application stack altogether \u2014has immense value. It is far more akin and practical to the real-world scenarios that you will encounter during engagements with clients: as a seller; a business partner; a trusted advisor. Entrusted with bestowing best practices for how that client can modernize specific pain points in their application code; not taking on the task of modernizing the entirety of their application stack \"in one go.\" Crafting complex modernization plans for enterprise-scale applications cannot be approached as explicit \"A, then B, followed by C\" rulebooks or rigid decision trees. It is essential that you understand how to approach modernization as a collaborative, problem-solving oriented, question-and-answer refinement exercise. WCA Chat, which you will use to these ends in the following modules, is an ideal mechanism for refining the correct modernization approach.","title":"i. About this lab"},{"location":"appmod/1/#ii-prerequisites","text":"This lab requires that participants have previously completed the IBM Cloud (SaaS) Configuration lab in its entirety. Those conducting the hands-on sections of this lab will require access to a deployed instance of WCA Standard Plan and have successfully integrated with the WCA service via either the Visual Studio Code ( VS Code ) extension or Eclipse IDE plug-ins.","title":"ii. Prerequisites"},{"location":"appmod/1/#iii-hands-on-topics","text":"For each module of the Application Modernization - WebSphere to Liberty lab, participants will have the opportunity to dissect the contents and purpose of legacy WebSphere Application Server ( WAS ) code, examine its limitations in the context of more up-to-date alternatives, and then compare that to a best-practices implementation of that equivalent codebase written in WebSphere Liberty . Afterwards, participants will go hands-on with the IBM watsonx Code Assistant ( WCA ) Standard environment to reproduce the steps of modernizing the WAS legacy code into Liberty code. Differences in the two code bases and the benefits of WCA's approach to code modernization will also be examined. MODERNIZATION TASK WEBSPHERE APPLICATION LIBERTY APPLICATION Basic migration capabilities WebSphere Enterprise Archive (EAR) configuration, at enterprise scale, becomes cumbersome to maintain and can often result in frequent deployment delays (or human-induced configuration errors) each time the modules need to be modified. Liberty Web Archive (WAR) configurations remove the need for multiple external descriptors and consolidate settings into a single, unified file. Configuration and dependency management WebSphere class loader configuration implementation suffers from significant (and unnecessary) complexity owing to bloated class-loader configurations. Liberty server configuration is expected to manage dependencies and simplify the overall process of application configuration. APIs and libraries WebSphere Scheduler APIs may not be immediately portable in their current form, they are potentially more costly to maintain than Liberty counterparts, and have less functionality due to outdated implementations. Liberty's Jakarta EE-templated APIs are more transferable across vendors and platforms, are built to cloud-native architecture by design, and are portable to containers. Enterprise JavaBeans (EJB) modernization WebSphere EJB with XML represent server-side components used by Java Enterprise Edition (Java EE or Jakarta EE) to encapsulate repeatable business logic. They are more challenging to maintain and prone to human-induced errors. Liberty EJBs with annotations use Java instead of XML, applying them directly within Java classes for configuration. In many cases, this reduces the need for external XML files and eases maintainability. Java Message Service integration WebSphere's MQ JMS integration uses complex configurations made up of verbose XML or admin console requirements. They can be difficult to maintain due to their dispersed nature. Liberty's MQ JMS integration provides a more centralized pattern to simplify the process of troubleshooting messaging integrations and maintaining existing policies. Security modernization WebSphere's XML-based security is challenging to understand and maintain due to XML file separation from the supporting Java code, which tends to lower developer productivity due to frequent context-switching. Liberty's annotation-based security reduces the need for external configuration and instead centralizes security declarations closer to the actual code implementation.","title":"iii. Hands-on topics"},{"location":"appmod/1/#iv-troubleshooting","text":"If you require assistance or run into issues with the hands-on lab, help is available. Environment issues: The lab environment is managed by IBM Technology Zone. Opening a support case ticket is recommended for issues related to the hands-on environment (provisioning, running, and so on.) Product questions: For questions related to IBM watsonx Code Assistant capabilities, sales opportunities, roadmap, and other such matters, open a thread on the #watsonx-code-assistant Slack channel.","title":"iv. Troubleshooting"},{"location":"appmod/1/#v-next-steps","text":"In the following section, participants will explore fundamental modernization and migration techniques using legacy WebSphere Enterprise Archive ( EAR ) configuration code \u2014 ultimately producing a modernized Liberty Web Archive ( WAR ) configuration codebase.","title":"v. Next steps"},{"location":"appmod/2/","text":"Basic migration capabilities Application Modernization - WebSphere to Liberty i. Incentives to modernize SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". Lariat Corporation has a large collection of WebSphere Enterprise Archive (EAR) applications designed specifically for deployments using WAS . These are packaged archive files that bundle together multiple Java Enterprise Edition (Java EE shorthand, or more recently referred to by Jakarta EE) components: web modules, Enterprise JavaBeans (EJB) files, resource adapters, libraries, and so on. Collectively, all of these components allow for Lariat's engineers and developers to manage complex enterprise applications \"efficiently\" (as the theory goes) by encapsulating all of the necessary components into a single, structured archive. Liberty , however, supports comparatively simple and standardized configurations that greatly reduce the complexities found with WebSphere applications. Liberty Web Archive ( WAR ) configurations remove the need for multiple external descriptors and consolidate settings into one unified file ( server.xml ). Overall, this approach improves the maintainability of the code base in the long term and improves the deployment speed for new instances (or versions) of the Liberty-based application. Feature WebSphere EAR configuration Liberty WAR configuration Deployment Complexity High: multiple modules and files to manage. Low: single deployable artifact. Speed Slow deployments due to heightened complexity. Faster deployments owing to simplicity and lightweight design. Maintainability Challenging due multiple configuration files need to managed and changes reconciled across multiple locations. Streamlined and less complex. Scalability Difficult to scale due to potential for complex sets of dependencies. Rapidly scaled due to cloud-native design. As part of the modernization efforts, the new Liberty application will need to support the functionality of the legacy WebSphere application, such as: Deployment of complex, modular Java EE applications onto WebSphere servers Encapsulation of web applications, EJB modules, and dependencies in a structured format Facilitate version control, deployment, and existing rollback strategies to guarantee consistent and reliable production environments In general, the team supporting the modernization anticipate that Liberty will enable greatly simplified, more modular deployment structures \u2014 which in turn will reduce the overhead, complexity, and maintenance burden of these applications. ii. WebSphere legacy code First, examine the legacy code (below), which as mentioned previously is a snapshot of a larger application using WebSphere EAR configuration : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <!-- application.xml --> <application> <module> <web> <web-uri> legacyapp.war </web-uri> <context-root> /legacyapp </context-root> </web> </module> <module> <ejb> legacyEJB.jar </ejb> </module> <security-role> <role-name> user </role-name> </security-role> </application> <!-- ibm-web-bnd.xml --> <web-bnd> <virtual-host name= \"default_host\" /> <resource-ref name= \"jdbc/LegacyDS\" binding-name= \"jdbc/LegacyDS\" /> </web-bnd> The application defines two modules\u2014 legacyapp.war and legacyEJB.jar \u2014which denote the web and EJB components of the application, respectively ( lines 5 and 10 ). The code sets a specific context root to access the legacyapp.war web module. It also introduces WebSphere-specific bindings such as ibm-web-bnd.xml ( line 17 ), which are employed for virtual hosting and resource references. Security roles and resource bindings are managed externally through the use of XML. The legacy code showcased above has a particular structural element that makes it a prime candidate for this type of Liberty modernization. Chiefly, the EAR application uses separate XML descriptors like application.xml ( line 1 ) and ibm-web-bnd.xml ( line 17 ) to define distinct modules. This setup, at enterprise scale, becomes cumbersome to maintain and can often result in frequent deployment delays (or human-induced configuration errors) each time the modules need to be modified. The maintenance burden of this more intricate structural design can be reduced with a more simplified, Liberty-based approach. iii. Liberty modernized code Consider the modernized (functionally equivalent) code using Liberty WAR configuration : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 <!-- server.xml --> <server> <featureManager> <feature> webProfile-8.0 </feature> <feature> jdbc-4.2 </feature> </featureManager> <httpEndpoint host= \"*\" httpPort= \"9080\" httpsPort= \"9443\" /> <application id= \"modernapp\" location= \"modernapp.war\" context-root= \"/modernapp\" > <classloader delegation= \"parentLast\" /> </application> <dataSource id= \"jdbc/ModernDS\" jndiName= \"jdbc/ModernDS\" > <jdbcDriver libraryRef= \"jdbcLib\" /> <connectionManager maxPoolSize= \"50\" /> </dataSource> <library id= \"jdbcLib\" > <fileset dir= \"${server.config.dir}/jdbc\" includes= \"*.jar\" /> </library> </server> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <!-- application.xml --> <application> <module> <web> <web-uri> legacyapp.war </web-uri> <context-root> /legacyapp </context-root> </web> </module> <module> <ejb> legacyEJB.jar </ejb> </module> <security-role> <role-name> user </role-name> </security-role> </application> <!-- ibm-web-bnd.xml --> <web-bnd> <virtual-host name= \"default_host\" /> <resource-ref name= \"jdbc/LegacyDS\" binding-name= \"jdbc/LegacyDS\" /> </web-bnd> BREVITY: DISPELLING MODERNIZATION MISCONCEPTIONS The Liberty application code snippet is in fact \"longer\", in terms of lines of code, than the legacy WAS predecessor application. This raises an important point about modernized application code: the brevity and terseness of an application's code does not always reflect more efficient or practical code. What is important to the success and value of modernization efforts is that the new code is more appropriate to the tasks to be performed, has greater efficacy than before, and is more easily maintained \u2014 or a combination of these factors. Whether that is achieved in fewer lines of code than before is ultimately far less important. The modernized Liberty application code streamlines the original WebSphere configuration details into a single WAR file ( server.xml ) with clear, unified definitions. JDBC configurations are directly defined alongside the application deployment, removing the need for external bindings. Legacy EAR files have been consolidated into lightweight Web Archive (WAR) structures. WebSphere-specific descriptors like ibm-web-bnd.xml have been converted into modern Liberty features ( webProfile-8.0 , jdbc-4.2 ). WebSphere-specific APIs and deprecated components, like AdminClient APIs or Java Naming and Directory Interface (JDNI) look-ups, have been replaced. Liberty WAR configuration file uses parentLast ( line 11 ) class loading to ensure that the application's resources take precedence. <application id= \"modernapp\" location= \"modernapp.war\" context-root= \"/modernapp\" > <classloader delegation= \"parentLast\" /> </application> Ultimately, the modernized Liberty application code supports Lariat's objectives of simplified, modular deployment structures that reduce the overhead and technical burdens placed on developers maintaining the legacy WebSphere code base. iv. Hands-on with WCA SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <!-- application.xml --> <application> <module> <web> <web-uri> legacyapp.war </web-uri> <context-root> /legacyapp </context-root> </web> </module> <module> <ejb> legacyEJB.jar </ejb> </module> <security-role> <role-name> user </role-name> </security-role> </application> <!-- ibm-web-bnd.xml --> <web-bnd> <virtual-host name= \"default_host\" /> <resource-ref name= \"jdbc/LegacyDS\" binding-name= \"jdbc/LegacyDS\" /> </web-bnd> After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY server.xml WCA LIBERTY web.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 <server description= \"new server\" > <featureManager> <feature> jsp-2.3 </feature> <feature> servlet-3.1 </feature> <feature> ejbLite-3.2 </feature> </featureManager> <httpEndpoint id= \"defaultHttpEndpoint\" host= \"*\" httpPort= \"9080\" httpsPort= \"9443\" /> <webApplication location= \"path/to/legacyapp.war\" name= \"legacyapp\" > <context-root> /legacyapp </context-root> <classLoader commonLibraryRef= \"LibertyBasicCL\" /> </webApplication> <basicRegistry id= \"LibertyBasicCL\" realm= \"LibertyBasicRealm\" > <user name= \"admin\" password= \"adminPassword\" /> </basicRegistry> <login-config> <auth-method> BASIC </auth-method> </login-config> <realm name= \"LibertyBasicRealm\" realm-name= \"LibertyBasicRealm\" > <users file= \"path/to/users.properties\" /> <groups file= \"path/to/groups.properties\" /> </realm> <jdbcDriver libraryRef= \"DefaultDataSource\" /> <dataSource jndiName= \"jdbc/LegacyDS\" id= \"DefaultDataSource\" > <jdbcDriver libraryRef= \"XADatabase\" /> <properties.db2.jcc databaseName= \"yourDatabaseName\" serverName= \"yourServerName\" portNumber= \"yourPortNumber\" /> </dataSource> </server> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <web-app xmlns= \"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version= \"3.1\" > <resource-ref> <description> Legacy Data Source </description> <res-ref-name> jdbc/LegacyDS </res-ref-name> <res-type> javax.sql.DataSource </res-type> <res-auth> Container </res-auth> </resource-ref> <security-role> <role-name> user </role-name> </security-role> </web-app> Let's first examine the use of WebSphere and Liberty-specific features . Lariat makes use of the webProfile-8.0 bundle set for servlets and Enterprise JavaBeans: <featureManager> <feature> webProfile-8.0 </feature> <feature> jdbc-4.2 </feature> </featureManager> By contrast, WCA has explicitly pulled in individual features like jsp-2.3 , servlet-3.1 , and ejbLite-3.2 which provides finer control over imports - avoiding unnecessary bloat. <featureManager> <feature> jsp-2.3 </feature> <feature> servlet-3.1 </feature> <feature> ejbLite-3.2 </feature> </featureManager> Security configuration is another area in which WCA has outperformed Lariat's modernization efforts. For Lariat, no authentication or user realm is configured. By contrast, WCA implements BASIC authentication, user and group registries, login, and custom realm with external property files. Security best-practices have been tuned and baked directly into the AI-generated code recommendations produced by WCA. <basicRegistry id= \"LibertyBasicCL\" realm= \"LibertyBasicRealm\" > <user name= \"admin\" password= \"adminPassword\" /> </basicRegistry> <login-config> <auth-method> BASIC </auth-method> </login-config> <realm name= \"LibertyBasicRealm\" realm-name= \"LibertyBasicRealm\" > <users file= \"path/to/users.properties\" /> <groups file= \"path/to/groups.properties\" /> </realm> DataSource configuration is arguably a toss-up between either version, depending on an organization's goals. Lariat's code has been structured for portability and is decoupled from any specific database: <dataSource id= \"jdbc/ModernDS\" jndiName= \"jdbc/ModernDS\" > <jdbcDriver libraryRef= \"jdbcLib\" /> <connectionManager maxPoolSize= \"50\" /> </dataSource> WCA's recommendation utilizes an IBM Db2-specific set of JDBC drivers. For clients with a highly-regulated, Db2-heavy enterprise environment, this code recommendation has much more utility to the requirements of their business: <dataSource jndiName= \"jdbc/LegacyDS\" id= \"DefaultDataSource\" > <jdbcDriver libraryRef= \"XADatabase\" /> <properties.db2.jcc ... /> </dataSource> v. Next steps In the following module, participants will examine how to modernize legacy WebSphere Application Server code for configuration and dependency management.","title":"2. Basic migration capabilities"},{"location":"appmod/2/#basic-migration-capabilitiesapplication-modernization-websphere-to-liberty","text":"","title":"Basic migration capabilitiesApplication Modernization - WebSphere to Liberty"},{"location":"appmod/2/#i-incentives-to-modernize","text":"SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". Lariat Corporation has a large collection of WebSphere Enterprise Archive (EAR) applications designed specifically for deployments using WAS . These are packaged archive files that bundle together multiple Java Enterprise Edition (Java EE shorthand, or more recently referred to by Jakarta EE) components: web modules, Enterprise JavaBeans (EJB) files, resource adapters, libraries, and so on. Collectively, all of these components allow for Lariat's engineers and developers to manage complex enterprise applications \"efficiently\" (as the theory goes) by encapsulating all of the necessary components into a single, structured archive. Liberty , however, supports comparatively simple and standardized configurations that greatly reduce the complexities found with WebSphere applications. Liberty Web Archive ( WAR ) configurations remove the need for multiple external descriptors and consolidate settings into one unified file ( server.xml ). Overall, this approach improves the maintainability of the code base in the long term and improves the deployment speed for new instances (or versions) of the Liberty-based application. Feature WebSphere EAR configuration Liberty WAR configuration Deployment Complexity High: multiple modules and files to manage. Low: single deployable artifact. Speed Slow deployments due to heightened complexity. Faster deployments owing to simplicity and lightweight design. Maintainability Challenging due multiple configuration files need to managed and changes reconciled across multiple locations. Streamlined and less complex. Scalability Difficult to scale due to potential for complex sets of dependencies. Rapidly scaled due to cloud-native design. As part of the modernization efforts, the new Liberty application will need to support the functionality of the legacy WebSphere application, such as: Deployment of complex, modular Java EE applications onto WebSphere servers Encapsulation of web applications, EJB modules, and dependencies in a structured format Facilitate version control, deployment, and existing rollback strategies to guarantee consistent and reliable production environments In general, the team supporting the modernization anticipate that Liberty will enable greatly simplified, more modular deployment structures \u2014 which in turn will reduce the overhead, complexity, and maintenance burden of these applications.","title":"i. Incentives to modernize"},{"location":"appmod/2/#ii-websphere-legacy-code","text":"First, examine the legacy code (below), which as mentioned previously is a snapshot of a larger application using WebSphere EAR configuration : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <!-- application.xml --> <application> <module> <web> <web-uri> legacyapp.war </web-uri> <context-root> /legacyapp </context-root> </web> </module> <module> <ejb> legacyEJB.jar </ejb> </module> <security-role> <role-name> user </role-name> </security-role> </application> <!-- ibm-web-bnd.xml --> <web-bnd> <virtual-host name= \"default_host\" /> <resource-ref name= \"jdbc/LegacyDS\" binding-name= \"jdbc/LegacyDS\" /> </web-bnd> The application defines two modules\u2014 legacyapp.war and legacyEJB.jar \u2014which denote the web and EJB components of the application, respectively ( lines 5 and 10 ). The code sets a specific context root to access the legacyapp.war web module. It also introduces WebSphere-specific bindings such as ibm-web-bnd.xml ( line 17 ), which are employed for virtual hosting and resource references. Security roles and resource bindings are managed externally through the use of XML. The legacy code showcased above has a particular structural element that makes it a prime candidate for this type of Liberty modernization. Chiefly, the EAR application uses separate XML descriptors like application.xml ( line 1 ) and ibm-web-bnd.xml ( line 17 ) to define distinct modules. This setup, at enterprise scale, becomes cumbersome to maintain and can often result in frequent deployment delays (or human-induced configuration errors) each time the modules need to be modified. The maintenance burden of this more intricate structural design can be reduced with a more simplified, Liberty-based approach.","title":"ii. WebSphere legacy code"},{"location":"appmod/2/#iii-liberty-modernized-code","text":"Consider the modernized (functionally equivalent) code using Liberty WAR configuration : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 <!-- server.xml --> <server> <featureManager> <feature> webProfile-8.0 </feature> <feature> jdbc-4.2 </feature> </featureManager> <httpEndpoint host= \"*\" httpPort= \"9080\" httpsPort= \"9443\" /> <application id= \"modernapp\" location= \"modernapp.war\" context-root= \"/modernapp\" > <classloader delegation= \"parentLast\" /> </application> <dataSource id= \"jdbc/ModernDS\" jndiName= \"jdbc/ModernDS\" > <jdbcDriver libraryRef= \"jdbcLib\" /> <connectionManager maxPoolSize= \"50\" /> </dataSource> <library id= \"jdbcLib\" > <fileset dir= \"${server.config.dir}/jdbc\" includes= \"*.jar\" /> </library> </server> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <!-- application.xml --> <application> <module> <web> <web-uri> legacyapp.war </web-uri> <context-root> /legacyapp </context-root> </web> </module> <module> <ejb> legacyEJB.jar </ejb> </module> <security-role> <role-name> user </role-name> </security-role> </application> <!-- ibm-web-bnd.xml --> <web-bnd> <virtual-host name= \"default_host\" /> <resource-ref name= \"jdbc/LegacyDS\" binding-name= \"jdbc/LegacyDS\" /> </web-bnd> BREVITY: DISPELLING MODERNIZATION MISCONCEPTIONS The Liberty application code snippet is in fact \"longer\", in terms of lines of code, than the legacy WAS predecessor application. This raises an important point about modernized application code: the brevity and terseness of an application's code does not always reflect more efficient or practical code. What is important to the success and value of modernization efforts is that the new code is more appropriate to the tasks to be performed, has greater efficacy than before, and is more easily maintained \u2014 or a combination of these factors. Whether that is achieved in fewer lines of code than before is ultimately far less important. The modernized Liberty application code streamlines the original WebSphere configuration details into a single WAR file ( server.xml ) with clear, unified definitions. JDBC configurations are directly defined alongside the application deployment, removing the need for external bindings. Legacy EAR files have been consolidated into lightweight Web Archive (WAR) structures. WebSphere-specific descriptors like ibm-web-bnd.xml have been converted into modern Liberty features ( webProfile-8.0 , jdbc-4.2 ). WebSphere-specific APIs and deprecated components, like AdminClient APIs or Java Naming and Directory Interface (JDNI) look-ups, have been replaced. Liberty WAR configuration file uses parentLast ( line 11 ) class loading to ensure that the application's resources take precedence. <application id= \"modernapp\" location= \"modernapp.war\" context-root= \"/modernapp\" > <classloader delegation= \"parentLast\" /> </application> Ultimately, the modernized Liberty application code supports Lariat's objectives of simplified, modular deployment structures that reduce the overhead and technical burdens placed on developers maintaining the legacy WebSphere code base.","title":"iii. Liberty modernized code"},{"location":"appmod/2/#iv-hands-on-with-wca","text":"SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <!-- application.xml --> <application> <module> <web> <web-uri> legacyapp.war </web-uri> <context-root> /legacyapp </context-root> </web> </module> <module> <ejb> legacyEJB.jar </ejb> </module> <security-role> <role-name> user </role-name> </security-role> </application> <!-- ibm-web-bnd.xml --> <web-bnd> <virtual-host name= \"default_host\" /> <resource-ref name= \"jdbc/LegacyDS\" binding-name= \"jdbc/LegacyDS\" /> </web-bnd> After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY server.xml WCA LIBERTY web.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 <server description= \"new server\" > <featureManager> <feature> jsp-2.3 </feature> <feature> servlet-3.1 </feature> <feature> ejbLite-3.2 </feature> </featureManager> <httpEndpoint id= \"defaultHttpEndpoint\" host= \"*\" httpPort= \"9080\" httpsPort= \"9443\" /> <webApplication location= \"path/to/legacyapp.war\" name= \"legacyapp\" > <context-root> /legacyapp </context-root> <classLoader commonLibraryRef= \"LibertyBasicCL\" /> </webApplication> <basicRegistry id= \"LibertyBasicCL\" realm= \"LibertyBasicRealm\" > <user name= \"admin\" password= \"adminPassword\" /> </basicRegistry> <login-config> <auth-method> BASIC </auth-method> </login-config> <realm name= \"LibertyBasicRealm\" realm-name= \"LibertyBasicRealm\" > <users file= \"path/to/users.properties\" /> <groups file= \"path/to/groups.properties\" /> </realm> <jdbcDriver libraryRef= \"DefaultDataSource\" /> <dataSource jndiName= \"jdbc/LegacyDS\" id= \"DefaultDataSource\" > <jdbcDriver libraryRef= \"XADatabase\" /> <properties.db2.jcc databaseName= \"yourDatabaseName\" serverName= \"yourServerName\" portNumber= \"yourPortNumber\" /> </dataSource> </server> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <web-app xmlns= \"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version= \"3.1\" > <resource-ref> <description> Legacy Data Source </description> <res-ref-name> jdbc/LegacyDS </res-ref-name> <res-type> javax.sql.DataSource </res-type> <res-auth> Container </res-auth> </resource-ref> <security-role> <role-name> user </role-name> </security-role> </web-app> Let's first examine the use of WebSphere and Liberty-specific features . Lariat makes use of the webProfile-8.0 bundle set for servlets and Enterprise JavaBeans: <featureManager> <feature> webProfile-8.0 </feature> <feature> jdbc-4.2 </feature> </featureManager> By contrast, WCA has explicitly pulled in individual features like jsp-2.3 , servlet-3.1 , and ejbLite-3.2 which provides finer control over imports - avoiding unnecessary bloat. <featureManager> <feature> jsp-2.3 </feature> <feature> servlet-3.1 </feature> <feature> ejbLite-3.2 </feature> </featureManager> Security configuration is another area in which WCA has outperformed Lariat's modernization efforts. For Lariat, no authentication or user realm is configured. By contrast, WCA implements BASIC authentication, user and group registries, login, and custom realm with external property files. Security best-practices have been tuned and baked directly into the AI-generated code recommendations produced by WCA. <basicRegistry id= \"LibertyBasicCL\" realm= \"LibertyBasicRealm\" > <user name= \"admin\" password= \"adminPassword\" /> </basicRegistry> <login-config> <auth-method> BASIC </auth-method> </login-config> <realm name= \"LibertyBasicRealm\" realm-name= \"LibertyBasicRealm\" > <users file= \"path/to/users.properties\" /> <groups file= \"path/to/groups.properties\" /> </realm> DataSource configuration is arguably a toss-up between either version, depending on an organization's goals. Lariat's code has been structured for portability and is decoupled from any specific database: <dataSource id= \"jdbc/ModernDS\" jndiName= \"jdbc/ModernDS\" > <jdbcDriver libraryRef= \"jdbcLib\" /> <connectionManager maxPoolSize= \"50\" /> </dataSource> WCA's recommendation utilizes an IBM Db2-specific set of JDBC drivers. For clients with a highly-regulated, Db2-heavy enterprise environment, this code recommendation has much more utility to the requirements of their business: <dataSource jndiName= \"jdbc/LegacyDS\" id= \"DefaultDataSource\" > <jdbcDriver libraryRef= \"XADatabase\" /> <properties.db2.jcc ... /> </dataSource>","title":"iv. Hands-on with WCA"},{"location":"appmod/2/#v-next-steps","text":"In the following module, participants will examine how to modernize legacy WebSphere Application Server code for configuration and dependency management.","title":"v. Next steps"},{"location":"appmod/3/","text":"Configuration and dependency management Application Modernization - WebSphere to Liberty i. Incentives to modernize SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". In order to perform configuration and dependency management, Lariat Corporation employs various WebSphere class loader configurations to exert control over how Java classes and libraries are accessed by applications. In essence, these class loaders help define the scope and visibility of Java classes, resources, and libraries that are available for use by those applications. Legacy applications built for WAS can use class loader configurations in a variety of ways, including: Isolation of application dependencies: provide assurances that applications avoid conflicts or unintended interactions that might arise from using shared libraries Application module management: for WebSphere Enterprise Archive (EAR) applications, like those covered in the previous section, class loader configurations can manage the visibility of classes across different modules of the same EAR file In addition, the ability to selectively control class loading can reduce the overall memory footprint and resource overhead of an application. The result is that class loader configurations play an important part for managing dependency conflicts and application stability across Lariat's WAS services and environments. Feature WebSphere class loader configuration Liberty server configuration Configuration Complexity High: hierarchical and administration-intensive. Low: concise and self-contained. Maintainability Configuration tends to be dispersed, raising difficulties with maintenance. Clear and concise, only need to maintain a single configuration file. Developer Productivity Lowered due to administrative overhead, high probability of class-loading conflicts. Raised due to minimal overhead and reduced likelihood of human-introduced errors from single source of truth. Scalability Difficult to scale due to potential for complex sets of dependencies. Rapidly scaled due to cloud-native design. Lariat's legacy WebSphere class loader configuration implementation suffers from significant (and unnecessary) complexity owing to bloated class-loader configurations. Multiple shared libraries need to be configured and adjusted via an admin console, resulting in redundant use of dependencies and libraries that could otherwise be shared with better design. Through modernization of the code to Liberty server configuration , the expectation is that the process of managing dependencies and application configuration can be simplified and more easily maintained. ii. WebSphere legacy code First, examine the legacy code (below), which as mentioned previously is a snapshot of a larger application using WebSphere class loader configuration : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <!-- deployment.xml --> <deployment> <classloader mode= \"PARENT_LAST\" > <library> <file path= \"/shared/libs/customlib.jar\" /> </library> <shared-library name= \"LegacySharedLib\" /> </classloader> </deployment> <!-- shared-libraries.xml --> <shared-libraries> <library name= \"LegacySharedLib\" > <files> <file> /opt/was/shared/lib/shared-legacy.jar </file> </files> </library> </shared-libraries> The legacy implementation utilizes separate, detailed descriptor files like deployment.xml ( lines 1-9 ) and shared-libraries.xml ( lines 11-18 ) to handle complex dependency and class-loading configurations. Lariat administrators who manage this code base must explicitly set class loader modes to control resource loading order \u2014 an inefficient, manual process achieved using the PARENT_LAST option. As a consequence, libraries that should ideally be shared by multiple applications instead need to be managed separately by each application in turn. This is terribly inefficient and produces needlessly complex classloader configurations. For Lariat's administrators, this approach to configuration and dependency management has frequently resulted in version conflicts for applications and complex debugging work for developers. iii. Liberty modernized code Consider below the modernized (but functionally equivalent) application code using Liberty server configuration : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <!-- server.xml --> <server> <featureManager> <feature> webProfile-8.0 </feature> </featureManager> <library id= \"customLib\" > <fileset dir= \"${server.config.dir}/shared/libs\" includes= \"*.jar\" /> </library> <application location= \"modernized.war\" > <classloader delegation= \"parentLast\" > <commonLibrary> <library ref= \"customLib\" /> </commonLibrary> </classloader> </application> </server> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <!-- deployment.xml --> <deployment> <classloader mode= \"PARENT_LAST\" > <library> <file path= \"/shared/libs/customlib.jar\" /> </library> <shared-library name= \"LegacySharedLib\" /> </classloader> </deployment> <!-- shared-libraries.xml --> <shared-libraries> <library name= \"LegacySharedLib\" > <files> <file> /opt/was/shared/lib/shared-legacy.jar </file> </files> </library> </shared-libraries> The modernized Liberty code implementation simplifies the management of dependencies by removing the discrete (separate) descriptors like deployment.xml and shared-libraries.xml from the WAS implementation. Instead, configuration and dependency management has been consolidated into a single server.xml descriptor, which more clearly defines the permitted libraries and their associated paths. Other benefits from the modernization work also include: Class loading policies (such as 'parentLast' on line 12 ) are now explicitly stated, helping to simplify the process of resource management for developers drawing from these resources. <classloader delegation= \"parentLast\" > <commonLibrary> <library ref= \"customLib\" /> </commonLibrary> </classloader> Dependencies are now directly tied and associated to applications, creating relationships between the two that are more transparent and easier to maintain. Ultimately, the modernization process into Liberty has resulted in configuration and dependency management that reduces dependency conflicts, simplifies resource management, and improves the overall clarity and maintainability of these assets going forward. iv. Hands-on with WCA SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <!-- deployment.xml --> <deployment> <classloader mode= \"PARENT_LAST\" > <library> <file path= \"/shared/libs/customlib.jar\" /> </library> <shared-library name= \"LegacySharedLib\" /> </classloader> </deployment> <!-- shared-libraries.xml --> <shared-libraries> <library name= \"LegacySharedLib\" > <files> <file> /opt/was/shared/lib/shared-legacy.jar </file> </files> </library> </shared-libraries> After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY server.xml WCA LIBERTY shared-library.xml 1 2 3 4 5 6 7 8 9 <server description= \"new server\" > <featureManager> <feature> jsp-2.3 </feature> <feature> servlet-3.1 </feature> </featureManager> <httpEndpoint id= \"defaultHttpEndpoint\" host= \"*\" httpPort= \"9080\" httpsPort= \"9443\" /> <sharedLibrary id= \"LegacySharedLib\" location= \"path/to/shared-legacy.jar\" /> <classLoader commonLibraryRef= \"LegacySharedLib\" /> </server> 1 2 3 4 5 6 7 <sharedLibraries> <library id= \"LegacySharedLib\" > <files> <file> path/to/customlib.jar </file> </files> </library> </sharedLibraries> At a glance, the newly-generated WCA code appears to be significantly more complex: splitting configuration organization across server.xml and shared-library.xml , rather than Lariat's consolidated server.xml approach. Not an encouraging start, but let's drill down into specific elements before making a final critique. In terms of encapsulation of necessary classes and libraries, Lariat's best-practices Liberty code outshines WCA's Liberty recommendations. Consider the following slice of Lariat's modernized code: <library id= \"customLib\" > <fileset dir= \"${server.config.dir}/shared/libs\" includes= \"*.jar\" /> </library> <classloader delegation= \"parentLast\" > <commonLibrary> <library ref= \"customLib\" /> </commonLibrary> </classloader> The code's Classloader has been limited in scope only to the deployed WAR: parentLast ensures that the application's classes override any shared ones, which is generally the \"safer\" approach to take for modernization of legacy applications. Contrast that to WCA's approach: <sharedLibrary id= \"LegacySharedLib\" location= \"path/to/shared-legacy.jar\" /> <classLoader commonLibraryRef= \"LegacySharedLib\" /> ... <sharedLibraries> <library id= \"LegacySharedLib\" > <files> <file> path/to/customlib.jar </file> </files> </library> </sharedLibraries> WCA uses a global scoped Classloader which will impact all applications in the environment PATH. The implementation is also slightly confusing to look at and redundant in design \u2014 LegacySharedLib has been declared twice in the highlighted code. Lastly, on the topic of application deployments , Lariat's code base has explicit WAR deployment instructions built into the server.xml configuration file: <application location= \"modernized.war\" > <classloader delegation= \"parentLast\" > <commonLibrary> <library ref= \"customLib\" /> </commonLibrary> </classloader> </application> Conversely, WCA's modernized Liberty code recommendations do not include a WAR deployment instruction set. This may be an artifact of the original WAS script (submitted in Step 4) that was only a snippet of the larger application \u2014 and therefore not indicative of a full-fledged, end to end application. As a result, WCA's recommendation does not include WAR deployment definitions which would be needed to actually load an application. v. Next steps In the following module, participants will examine how to modernize legacy WebSphere Application Server APIs and libraries.","title":"3. Configuration management"},{"location":"appmod/3/#configuration-and-dependency-managementapplication-modernization-websphere-to-liberty","text":"","title":"Configuration and dependency managementApplication Modernization - WebSphere to Liberty"},{"location":"appmod/3/#i-incentives-to-modernize","text":"SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". In order to perform configuration and dependency management, Lariat Corporation employs various WebSphere class loader configurations to exert control over how Java classes and libraries are accessed by applications. In essence, these class loaders help define the scope and visibility of Java classes, resources, and libraries that are available for use by those applications. Legacy applications built for WAS can use class loader configurations in a variety of ways, including: Isolation of application dependencies: provide assurances that applications avoid conflicts or unintended interactions that might arise from using shared libraries Application module management: for WebSphere Enterprise Archive (EAR) applications, like those covered in the previous section, class loader configurations can manage the visibility of classes across different modules of the same EAR file In addition, the ability to selectively control class loading can reduce the overall memory footprint and resource overhead of an application. The result is that class loader configurations play an important part for managing dependency conflicts and application stability across Lariat's WAS services and environments. Feature WebSphere class loader configuration Liberty server configuration Configuration Complexity High: hierarchical and administration-intensive. Low: concise and self-contained. Maintainability Configuration tends to be dispersed, raising difficulties with maintenance. Clear and concise, only need to maintain a single configuration file. Developer Productivity Lowered due to administrative overhead, high probability of class-loading conflicts. Raised due to minimal overhead and reduced likelihood of human-introduced errors from single source of truth. Scalability Difficult to scale due to potential for complex sets of dependencies. Rapidly scaled due to cloud-native design. Lariat's legacy WebSphere class loader configuration implementation suffers from significant (and unnecessary) complexity owing to bloated class-loader configurations. Multiple shared libraries need to be configured and adjusted via an admin console, resulting in redundant use of dependencies and libraries that could otherwise be shared with better design. Through modernization of the code to Liberty server configuration , the expectation is that the process of managing dependencies and application configuration can be simplified and more easily maintained.","title":"i. Incentives to modernize"},{"location":"appmod/3/#ii-websphere-legacy-code","text":"First, examine the legacy code (below), which as mentioned previously is a snapshot of a larger application using WebSphere class loader configuration : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <!-- deployment.xml --> <deployment> <classloader mode= \"PARENT_LAST\" > <library> <file path= \"/shared/libs/customlib.jar\" /> </library> <shared-library name= \"LegacySharedLib\" /> </classloader> </deployment> <!-- shared-libraries.xml --> <shared-libraries> <library name= \"LegacySharedLib\" > <files> <file> /opt/was/shared/lib/shared-legacy.jar </file> </files> </library> </shared-libraries> The legacy implementation utilizes separate, detailed descriptor files like deployment.xml ( lines 1-9 ) and shared-libraries.xml ( lines 11-18 ) to handle complex dependency and class-loading configurations. Lariat administrators who manage this code base must explicitly set class loader modes to control resource loading order \u2014 an inefficient, manual process achieved using the PARENT_LAST option. As a consequence, libraries that should ideally be shared by multiple applications instead need to be managed separately by each application in turn. This is terribly inefficient and produces needlessly complex classloader configurations. For Lariat's administrators, this approach to configuration and dependency management has frequently resulted in version conflicts for applications and complex debugging work for developers.","title":"ii. WebSphere legacy code"},{"location":"appmod/3/#iii-liberty-modernized-code","text":"Consider below the modernized (but functionally equivalent) application code using Liberty server configuration : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <!-- server.xml --> <server> <featureManager> <feature> webProfile-8.0 </feature> </featureManager> <library id= \"customLib\" > <fileset dir= \"${server.config.dir}/shared/libs\" includes= \"*.jar\" /> </library> <application location= \"modernized.war\" > <classloader delegation= \"parentLast\" > <commonLibrary> <library ref= \"customLib\" /> </commonLibrary> </classloader> </application> </server> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <!-- deployment.xml --> <deployment> <classloader mode= \"PARENT_LAST\" > <library> <file path= \"/shared/libs/customlib.jar\" /> </library> <shared-library name= \"LegacySharedLib\" /> </classloader> </deployment> <!-- shared-libraries.xml --> <shared-libraries> <library name= \"LegacySharedLib\" > <files> <file> /opt/was/shared/lib/shared-legacy.jar </file> </files> </library> </shared-libraries> The modernized Liberty code implementation simplifies the management of dependencies by removing the discrete (separate) descriptors like deployment.xml and shared-libraries.xml from the WAS implementation. Instead, configuration and dependency management has been consolidated into a single server.xml descriptor, which more clearly defines the permitted libraries and their associated paths. Other benefits from the modernization work also include: Class loading policies (such as 'parentLast' on line 12 ) are now explicitly stated, helping to simplify the process of resource management for developers drawing from these resources. <classloader delegation= \"parentLast\" > <commonLibrary> <library ref= \"customLib\" /> </commonLibrary> </classloader> Dependencies are now directly tied and associated to applications, creating relationships between the two that are more transparent and easier to maintain. Ultimately, the modernization process into Liberty has resulted in configuration and dependency management that reduces dependency conflicts, simplifies resource management, and improves the overall clarity and maintainability of these assets going forward.","title":"iii. Liberty modernized code"},{"location":"appmod/3/#iv-hands-on-with-wca","text":"SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <!-- deployment.xml --> <deployment> <classloader mode= \"PARENT_LAST\" > <library> <file path= \"/shared/libs/customlib.jar\" /> </library> <shared-library name= \"LegacySharedLib\" /> </classloader> </deployment> <!-- shared-libraries.xml --> <shared-libraries> <library name= \"LegacySharedLib\" > <files> <file> /opt/was/shared/lib/shared-legacy.jar </file> </files> </library> </shared-libraries> After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY server.xml WCA LIBERTY shared-library.xml 1 2 3 4 5 6 7 8 9 <server description= \"new server\" > <featureManager> <feature> jsp-2.3 </feature> <feature> servlet-3.1 </feature> </featureManager> <httpEndpoint id= \"defaultHttpEndpoint\" host= \"*\" httpPort= \"9080\" httpsPort= \"9443\" /> <sharedLibrary id= \"LegacySharedLib\" location= \"path/to/shared-legacy.jar\" /> <classLoader commonLibraryRef= \"LegacySharedLib\" /> </server> 1 2 3 4 5 6 7 <sharedLibraries> <library id= \"LegacySharedLib\" > <files> <file> path/to/customlib.jar </file> </files> </library> </sharedLibraries> At a glance, the newly-generated WCA code appears to be significantly more complex: splitting configuration organization across server.xml and shared-library.xml , rather than Lariat's consolidated server.xml approach. Not an encouraging start, but let's drill down into specific elements before making a final critique. In terms of encapsulation of necessary classes and libraries, Lariat's best-practices Liberty code outshines WCA's Liberty recommendations. Consider the following slice of Lariat's modernized code: <library id= \"customLib\" > <fileset dir= \"${server.config.dir}/shared/libs\" includes= \"*.jar\" /> </library> <classloader delegation= \"parentLast\" > <commonLibrary> <library ref= \"customLib\" /> </commonLibrary> </classloader> The code's Classloader has been limited in scope only to the deployed WAR: parentLast ensures that the application's classes override any shared ones, which is generally the \"safer\" approach to take for modernization of legacy applications. Contrast that to WCA's approach: <sharedLibrary id= \"LegacySharedLib\" location= \"path/to/shared-legacy.jar\" /> <classLoader commonLibraryRef= \"LegacySharedLib\" /> ... <sharedLibraries> <library id= \"LegacySharedLib\" > <files> <file> path/to/customlib.jar </file> </files> </library> </sharedLibraries> WCA uses a global scoped Classloader which will impact all applications in the environment PATH. The implementation is also slightly confusing to look at and redundant in design \u2014 LegacySharedLib has been declared twice in the highlighted code. Lastly, on the topic of application deployments , Lariat's code base has explicit WAR deployment instructions built into the server.xml configuration file: <application location= \"modernized.war\" > <classloader delegation= \"parentLast\" > <commonLibrary> <library ref= \"customLib\" /> </commonLibrary> </classloader> </application> Conversely, WCA's modernized Liberty code recommendations do not include a WAR deployment instruction set. This may be an artifact of the original WAS script (submitted in Step 4) that was only a snippet of the larger application \u2014 and therefore not indicative of a full-fledged, end to end application. As a result, WCA's recommendation does not include WAR deployment definitions which would be needed to actually load an application.","title":"iv. Hands-on with WCA"},{"location":"appmod/3/#v-next-steps","text":"In the following module, participants will examine how to modernize legacy WebSphere Application Server APIs and libraries.","title":"v. Next steps"},{"location":"appmod/4/","text":"APIs and libraries Application Modernization - WebSphere to Liberty i. Incentives to modernize SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". Lariat Corporation's application stack utilizes a myriad of WebSphere Application Server APIs \u2014 Work Manager API, Async Beans, Scheduler API, and so on \u2014which will likely be impacted and require remediation as part of the company's overall modernization towards WebSphere Liberty. WAS APIs may not be immediately portable in their current form, they are potentially more costly to maintain than their Liberty counterparts, and may have less functionality given their outdated implementations. Liberty-compatible APIs increase the portability of applications across different Java Enterprise Edition ( Java EE or Jakarta EE ) application servers. The result is that developers can more easily facilitate cloud deployments or migrations to other runtimes. Liberty APIs follow standardized annotations and conventions that simplify the boilerplate code needed for applications to exchange data with these APIs. WAS-specific APIs, by contrast, are potentially locked to specific versions of WebSphere - which in turn \"lock in\" the applications dependent on such APIs. Feature WebSphere Scheduler API Liberty's Jakarta EE-templated APIs Standardization Built on proprietary WebSphere-only APIs. Built on industry-standardized Jakarta EE APIs. More transferable across vendors and platforms. Cloud-Readiness Tied to traditional WebSphere Application Server only. Cloud-native architecture by design and portable to containers. Developer Productivity Complex setup requiring use of admin console and external XML definitions. Declarative and code-driven with Java annotations. Currently, Lariat's WebSphere Scheduler APIs rely upon IBM-specific extensions (such as .com.ibm.websphere packages) that will need to be identified and remediated before modernization with Liberty's Jakarta EE-templated APIs . The shift from proprietary WAS-based APIs to standardized Liberty-based APIs (built to Jakarta EE / Java EE specifications) should improve application portability and align with industry best practices. ii. WebSphere legacy code First, examine the legacy Java code (below), which as mentioned previously is a snapshot of a larger application using WebSphere Scheduler API : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import com.ibm.websphere.scheduler.TaskHandler ; import com.ibm.websphere.scheduler.Scheduler ; import javax.naming.InitialContext ; public class LegacySchedulerTask { public void scheduleTask () throws Exception { InitialContext ctx = new InitialContext (); Scheduler scheduler = ( Scheduler ) ctx . lookup ( \"scheduler/legacyScheduler\" ); TaskHandler handler = scheduler . createTaskHandler ( \"TaskName\" , new LegacyTask (), null , \"0 0/5 * * * ?\" , true , null ); handler . start (); } } The LegacySchedulerTask API describes a WAS-specific scheduler (identifiable by the com.ibm.websphere.scheduler import statements on lines 1 and 2 ), which invokes IBM-proprietary API standards. These API invocations are in turn used to schedule periodic task executions within Lariat's application estate. import com.ibm.websphere.scheduler.TaskHandler ; import com.ibm.websphere.scheduler.Scheduler ; Utilizing WAS-specific API calls requires explicit JNDI (Java Naming and Directory Interface) look-ups. Furthermore, it demands manual intervention on the part of application developers to create and manage scheduled API tasks. The result is that this legacy API code, by placing heavy reliance upon WebSphere platform-specific APIs, has impaired the portability of applications. iii. Liberty modernized code Consider below the modernized (but functionally equivalent) Java code in support of Liberty's Jakarta EE-templated APIs : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import javax.annotation.Resource ; import javax.enterprise.context.ApplicationScoped ; import javax.enterprise.concurrent.ManagedScheduledExecutorService ; import java.util.concurrent.TimeUnit ; @ApplicationScoped public class ModernSchedulerTask { @Resource ManagedScheduledExecutorService executor ; public void scheduleTask () { executor . scheduleAtFixedRate ( () -> { // Modern task logic here System . out . println ( \"Executing scheduled task.\" ); }, 0 , 5 , TimeUnit . MINUTES ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import com.ibm.websphere.scheduler.TaskHandler ; import com.ibm.websphere.scheduler.Scheduler ; import javax.naming.InitialContext ; public class LegacySchedulerTask { public void scheduleTask () throws Exception { InitialContext ctx = new InitialContext (); Scheduler scheduler = ( Scheduler ) ctx . lookup ( \"scheduler/legacyScheduler\" ); TaskHandler handler = scheduler . createTaskHandler ( \"TaskName\" , new LegacyTask (), null , \"0 0/5 * * * ?\" , true , null ); handler . start (); } } In contrast to the legacy WAS-based Java API, the modernized Liberty approach (templated using Jakarta EE's API conventions) significantly simplifies the scheduling logic. The standardized ManagedScheduledExecutorService API for concurrency simplifies the scheduling of tasks using direct resource injection, as indicated by @Resource beginning on line 9 . @Resource ManagedScheduledExecutorService executor ; The previous (legacy) requirement of forcing JNDI look-ups, therefore, has been remediated through the use of direct resource injection. The Jakarta EE standard also follows an annotation-driven model for scheduling tasks to reduce the overall complexity of the code and improve its \"readability\" for human developers. Ultimately, the modernization efforts have significantly increased the portability and extensibility of Lariat's API-driven application estate. The structure of the API code has been simplified and made much more portable by breaking away from propriety API standards. iv. Hands-on with WCA SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import com.ibm.websphere.scheduler.TaskHandler ; import com.ibm.websphere.scheduler.Scheduler ; import javax.naming.InitialContext ; public class LegacySchedulerTask { public void scheduleTask () throws Exception { InitialContext ctx = new InitialContext (); Scheduler scheduler = ( Scheduler ) ctx . lookup ( \"scheduler/legacyScheduler\" ); TaskHandler handler = scheduler . createTaskHandler ( \"TaskName\" , new LegacyTask (), null , \"0 0/5 * * * ?\" , true , null ); handler . start (); } } After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY server.xml Part 1 WCA LIBERTY server.xml Part 2 WCA LIBERTY server.xml Part 3 1 2 3 4 5 6 7 // Enable the Scheduler feature: // In your server.xml file, add the scheduler-1.0 feature to the featureManager section. < featureManager > < feature > jsp - 2.3 </ feature > < feature > servlet - 3.1 </ feature > < feature > scheduler - 1.0 </ feature > </ featureManager > 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Update the task class: // Create a new class that implements the com.ibm.websphere.scheduler.Task interface. import com.ibm.websphere.scheduler.Task ; import javax.naming.InitialContext ; import javax.naming.NamingException ; public class LegacyTask implements Task { private static final String TASK_NAME = \"TaskName\" ; private static final String CRON_EXPRESSION = \"0 0/5 * * * ?\" ; @Override public void execute () throws Exception { // Your task logic here } @Override public String getName () { return TASK_NAME ; } @Override public String getCronExpression () { return CRON_EXPRESSION ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Update the scheduler configuration: // In your server.xml file, add a scheduler element to configure the scheduler. < scheduler id = \"legacyScheduler\" > < property name = \"cronExpression\" value = \"0 0/5 * * * ?\" /> < property name = \"initialDelay\" value = \"0\" /> < property name = \"period\" value = \"0\" /> < property name = \"timeZone\" value = \"UTC\" /> </ scheduler > Update the task scheduling code : Modify the scheduleTask method to use the Liberty Scheduler API . // Update the task scheduling code: // Modify the scheduleTask method to use the Liberty Scheduler API. import com.ibm.websphere.scheduler.Scheduler ; import javax.naming.InitialContext ; import javax.naming.NamingException ; public class LegacySchedulerTask { public void scheduleTask () throws Exception { InitialContext ctx = new InitialContext (); Scheduler scheduler = ( Scheduler ) ctx . lookup ( \"scheduler/legacyScheduler\" ); scheduler . schedule ( new LegacyTask (), null ); } } The first thing to note is that Lariat and WCA have taken two fundamentally different scheduling approaches on their respective WebSphere Liberty codebases. In the case of Lariat, the team implemented the standardized Jakarta EE API with the intent of keeping the code as portable as possible: @Resource ManagedScheduledExecutorService executor ; WCA recommended the use of com.ibm.websphere.scheduler.Scheduler and Task interfaces, which require a CRON expression in the XML descriptor and additional code lookups for Scheduler : <scheduler id= \"legacyScheduler\" > <property name= \"cronExpression\" value= \"0 0/5 * * * ?\" /> <property name= \"initialDelay\" value= \"0\" /> <property name= \"period\" value= \"0\" /> <property name= \"timeZone\" value= \"UTC\" /> </scheduler> The WCA solution is arguably stronger in scenarios where complex scheduling tasks are anticipated, given the granularity of control that CRON offers with regular expression matching. The Lariat solution is simpler, but limited in terms of customizability. In terms of portability of the Liberty codebase, Lariat's implementation has been designed around Jakarta EE 's API which provides simple mobility across nearly every Java EE-compliant runtime. WCA's recommendation to use the Scheduler API (a proprietary Liberty) format ensures full compatibility with WebSphere Liberty endpoints \u2014 which, as you will recall, the request to WCA was explicitly to modernize to Liberty . But the use of Scheduler also poses a potential lock-in risk for that particular distribution, to the exclusion of others. v. Next steps In the following module, participants will examine how to modernize legacy WebSphere Application Server code for Enterprise JavaBeans.","title":"4. APIs and libraries"},{"location":"appmod/4/#apis-and-librariesapplication-modernization-websphere-to-liberty","text":"","title":"APIs and librariesApplication Modernization - WebSphere to Liberty"},{"location":"appmod/4/#i-incentives-to-modernize","text":"SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". Lariat Corporation's application stack utilizes a myriad of WebSphere Application Server APIs \u2014 Work Manager API, Async Beans, Scheduler API, and so on \u2014which will likely be impacted and require remediation as part of the company's overall modernization towards WebSphere Liberty. WAS APIs may not be immediately portable in their current form, they are potentially more costly to maintain than their Liberty counterparts, and may have less functionality given their outdated implementations. Liberty-compatible APIs increase the portability of applications across different Java Enterprise Edition ( Java EE or Jakarta EE ) application servers. The result is that developers can more easily facilitate cloud deployments or migrations to other runtimes. Liberty APIs follow standardized annotations and conventions that simplify the boilerplate code needed for applications to exchange data with these APIs. WAS-specific APIs, by contrast, are potentially locked to specific versions of WebSphere - which in turn \"lock in\" the applications dependent on such APIs. Feature WebSphere Scheduler API Liberty's Jakarta EE-templated APIs Standardization Built on proprietary WebSphere-only APIs. Built on industry-standardized Jakarta EE APIs. More transferable across vendors and platforms. Cloud-Readiness Tied to traditional WebSphere Application Server only. Cloud-native architecture by design and portable to containers. Developer Productivity Complex setup requiring use of admin console and external XML definitions. Declarative and code-driven with Java annotations. Currently, Lariat's WebSphere Scheduler APIs rely upon IBM-specific extensions (such as .com.ibm.websphere packages) that will need to be identified and remediated before modernization with Liberty's Jakarta EE-templated APIs . The shift from proprietary WAS-based APIs to standardized Liberty-based APIs (built to Jakarta EE / Java EE specifications) should improve application portability and align with industry best practices.","title":"i. Incentives to modernize"},{"location":"appmod/4/#ii-websphere-legacy-code","text":"First, examine the legacy Java code (below), which as mentioned previously is a snapshot of a larger application using WebSphere Scheduler API : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import com.ibm.websphere.scheduler.TaskHandler ; import com.ibm.websphere.scheduler.Scheduler ; import javax.naming.InitialContext ; public class LegacySchedulerTask { public void scheduleTask () throws Exception { InitialContext ctx = new InitialContext (); Scheduler scheduler = ( Scheduler ) ctx . lookup ( \"scheduler/legacyScheduler\" ); TaskHandler handler = scheduler . createTaskHandler ( \"TaskName\" , new LegacyTask (), null , \"0 0/5 * * * ?\" , true , null ); handler . start (); } } The LegacySchedulerTask API describes a WAS-specific scheduler (identifiable by the com.ibm.websphere.scheduler import statements on lines 1 and 2 ), which invokes IBM-proprietary API standards. These API invocations are in turn used to schedule periodic task executions within Lariat's application estate. import com.ibm.websphere.scheduler.TaskHandler ; import com.ibm.websphere.scheduler.Scheduler ; Utilizing WAS-specific API calls requires explicit JNDI (Java Naming and Directory Interface) look-ups. Furthermore, it demands manual intervention on the part of application developers to create and manage scheduled API tasks. The result is that this legacy API code, by placing heavy reliance upon WebSphere platform-specific APIs, has impaired the portability of applications.","title":"ii. WebSphere legacy code"},{"location":"appmod/4/#iii-liberty-modernized-code","text":"Consider below the modernized (but functionally equivalent) Java code in support of Liberty's Jakarta EE-templated APIs : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import javax.annotation.Resource ; import javax.enterprise.context.ApplicationScoped ; import javax.enterprise.concurrent.ManagedScheduledExecutorService ; import java.util.concurrent.TimeUnit ; @ApplicationScoped public class ModernSchedulerTask { @Resource ManagedScheduledExecutorService executor ; public void scheduleTask () { executor . scheduleAtFixedRate ( () -> { // Modern task logic here System . out . println ( \"Executing scheduled task.\" ); }, 0 , 5 , TimeUnit . MINUTES ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import com.ibm.websphere.scheduler.TaskHandler ; import com.ibm.websphere.scheduler.Scheduler ; import javax.naming.InitialContext ; public class LegacySchedulerTask { public void scheduleTask () throws Exception { InitialContext ctx = new InitialContext (); Scheduler scheduler = ( Scheduler ) ctx . lookup ( \"scheduler/legacyScheduler\" ); TaskHandler handler = scheduler . createTaskHandler ( \"TaskName\" , new LegacyTask (), null , \"0 0/5 * * * ?\" , true , null ); handler . start (); } } In contrast to the legacy WAS-based Java API, the modernized Liberty approach (templated using Jakarta EE's API conventions) significantly simplifies the scheduling logic. The standardized ManagedScheduledExecutorService API for concurrency simplifies the scheduling of tasks using direct resource injection, as indicated by @Resource beginning on line 9 . @Resource ManagedScheduledExecutorService executor ; The previous (legacy) requirement of forcing JNDI look-ups, therefore, has been remediated through the use of direct resource injection. The Jakarta EE standard also follows an annotation-driven model for scheduling tasks to reduce the overall complexity of the code and improve its \"readability\" for human developers. Ultimately, the modernization efforts have significantly increased the portability and extensibility of Lariat's API-driven application estate. The structure of the API code has been simplified and made much more portable by breaking away from propriety API standards.","title":"iii. Liberty modernized code"},{"location":"appmod/4/#iv-hands-on-with-wca","text":"SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import com.ibm.websphere.scheduler.TaskHandler ; import com.ibm.websphere.scheduler.Scheduler ; import javax.naming.InitialContext ; public class LegacySchedulerTask { public void scheduleTask () throws Exception { InitialContext ctx = new InitialContext (); Scheduler scheduler = ( Scheduler ) ctx . lookup ( \"scheduler/legacyScheduler\" ); TaskHandler handler = scheduler . createTaskHandler ( \"TaskName\" , new LegacyTask (), null , \"0 0/5 * * * ?\" , true , null ); handler . start (); } } After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY server.xml Part 1 WCA LIBERTY server.xml Part 2 WCA LIBERTY server.xml Part 3 1 2 3 4 5 6 7 // Enable the Scheduler feature: // In your server.xml file, add the scheduler-1.0 feature to the featureManager section. < featureManager > < feature > jsp - 2.3 </ feature > < feature > servlet - 3.1 </ feature > < feature > scheduler - 1.0 </ feature > </ featureManager > 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Update the task class: // Create a new class that implements the com.ibm.websphere.scheduler.Task interface. import com.ibm.websphere.scheduler.Task ; import javax.naming.InitialContext ; import javax.naming.NamingException ; public class LegacyTask implements Task { private static final String TASK_NAME = \"TaskName\" ; private static final String CRON_EXPRESSION = \"0 0/5 * * * ?\" ; @Override public void execute () throws Exception { // Your task logic here } @Override public String getName () { return TASK_NAME ; } @Override public String getCronExpression () { return CRON_EXPRESSION ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Update the scheduler configuration: // In your server.xml file, add a scheduler element to configure the scheduler. < scheduler id = \"legacyScheduler\" > < property name = \"cronExpression\" value = \"0 0/5 * * * ?\" /> < property name = \"initialDelay\" value = \"0\" /> < property name = \"period\" value = \"0\" /> < property name = \"timeZone\" value = \"UTC\" /> </ scheduler > Update the task scheduling code : Modify the scheduleTask method to use the Liberty Scheduler API . // Update the task scheduling code: // Modify the scheduleTask method to use the Liberty Scheduler API. import com.ibm.websphere.scheduler.Scheduler ; import javax.naming.InitialContext ; import javax.naming.NamingException ; public class LegacySchedulerTask { public void scheduleTask () throws Exception { InitialContext ctx = new InitialContext (); Scheduler scheduler = ( Scheduler ) ctx . lookup ( \"scheduler/legacyScheduler\" ); scheduler . schedule ( new LegacyTask (), null ); } } The first thing to note is that Lariat and WCA have taken two fundamentally different scheduling approaches on their respective WebSphere Liberty codebases. In the case of Lariat, the team implemented the standardized Jakarta EE API with the intent of keeping the code as portable as possible: @Resource ManagedScheduledExecutorService executor ; WCA recommended the use of com.ibm.websphere.scheduler.Scheduler and Task interfaces, which require a CRON expression in the XML descriptor and additional code lookups for Scheduler : <scheduler id= \"legacyScheduler\" > <property name= \"cronExpression\" value= \"0 0/5 * * * ?\" /> <property name= \"initialDelay\" value= \"0\" /> <property name= \"period\" value= \"0\" /> <property name= \"timeZone\" value= \"UTC\" /> </scheduler> The WCA solution is arguably stronger in scenarios where complex scheduling tasks are anticipated, given the granularity of control that CRON offers with regular expression matching. The Lariat solution is simpler, but limited in terms of customizability. In terms of portability of the Liberty codebase, Lariat's implementation has been designed around Jakarta EE 's API which provides simple mobility across nearly every Java EE-compliant runtime. WCA's recommendation to use the Scheduler API (a proprietary Liberty) format ensures full compatibility with WebSphere Liberty endpoints \u2014 which, as you will recall, the request to WCA was explicitly to modernize to Liberty . But the use of Scheduler also poses a potential lock-in risk for that particular distribution, to the exclusion of others.","title":"iv. Hands-on with WCA"},{"location":"appmod/4/#v-next-steps","text":"In the following module, participants will examine how to modernize legacy WebSphere Application Server code for Enterprise JavaBeans.","title":"v. Next steps"},{"location":"appmod/5/","text":"Enterprise JavaBeans (EJB) modernization Application Modernization - WebSphere to Liberty i. Incentives to modernize SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". WebSphere Enterprise JavaBeans ( EJB ) represent server-side components used by Java Enterprise Edition ( Java EE or Jakarta EE ) to encapsulate repeatable business logic. In turn, EJB can be used to provide scalable and highly performant handling for requests made by Lariat Corporation's web application estate. EJBs provide the resource access management for the databases, messaging services, and external APIs these such application require to power their business functions. WebSphere's EJBs make extensive use of XML deployment descriptors to configure their behavior. Liberty EJBs use Java annotations instead of XML , applying them directly within Java classes for configuration. In many cases, this eliminates the need for external XML files completely (or at least significantly reduces their size and number). Feature WebSphere EJB with XML Liberty EJB with annotations Maintainability Difficult due to scattered XML configs. Improved due to cohesive annotations. Readability Lower due to switching between Java and XML. Higher due to configuration directly in Java code. Productivity Lower due to manual XML edits. Higher due to rapid development through annotations. Error Propensity Higher chance of manual XML errors. Lower due to clear annotations and IDE checks. Modernizing WebSphere's EJB's stateless session beans into Liberty's standard-compliant EJB will provide Lariat with the net benefit of code that's easier to maintain, more portable, and extensible for modern cloud-native endpoints. Ultimately, this should yield a simplified developer experience and better resource management. ii. WebSphere legacy code First, examine the legacy code (below), which as mentioned previously is a snapshot of a larger application using WebSphere's EJB Stateful Session Bean with XML : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 <!-- ejb-jar.xml --> <ejb-jar> <enterprise-beans> <session> <ejb-name> LegacySessionBean </ejb-name> <home> com.lariat.ejb.LegacyHome </home> <remote> com.lariat.ejb.LegacyRemote </remote> <ejb-class> com.lariat.ejb.LegacySessionBean </ejb-class> <session-type> Stateless </session-type> <transaction-type> Container </transaction-type> </session> </enterprise-beans> </ejb-jar> The legacy EJB implementation uses XML ( ejb-jar.xml beginning on line 1 ) to explicitly define the contents of the stateful session bean. This requires that the <home> and <remote> interfaces be explicitly defined, along with the bean class. Transaction types and security are also configured externally via descriptors within the XML. iii. Liberty modernized code Consider below the modernized (but functionally equivalent) application code using Liberty's EJB Stateless Session Bean with annotations : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package com.lariat.ejb ; import javax.ejb.Stateless ; import javax.ejb.Remote ; @Stateless @Remote ( ModernRemote . class ) public class ModernSessionBean implements ModernRemote { @Override public String getGreeting ( String name ) { return \"Hello, \" + name + \"!\" ; } } package com.lariat.ejb ; import javax.ejb.Remote ; @Remote public interface ModernRemote { String getGreeting ( String name ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 <!-- ejb-jar.xml --> <ejb-jar> <enterprise-beans> <session> <ejb-name> LegacySessionBean </ejb-name> <home> com.lariat.ejb.LegacyHome </home> <remote> com.lariat.ejb.LegacyRemote </remote> <ejb-class> com.lariat.ejb.LegacySessionBean </ejb-class> <session-type> Stateless </session-type> <transaction-type> Container </transaction-type> </session> </enterprise-beans> </ejb-jar> The modernized Liberty code adopts EJB with Java annotations directly within the bean implementation; for example, utilizing such annotations as @Stateless beginning on line 6 : @Stateless @Remote ( ModernRemote . class ) public class ModernSessionBean implements ModernRemote { @Override public String getGreeting ( String name ) { return \"Hello, \" + name + \"!\" ; } } This approach also eliminates the need for explicit home interfaces, instead allowing Lariat's developers to directly specify remote interfaces within the bean definition. There are also positive side effects to the \"readability\" of the code \u2014 since transaction management and security settings are managed via annotations, the amount of XML overhead is reduced and thus the code can be more easily parsed (and maintained) by humans. Ultimately, Liberty's modernized EJB implementation simplifies the bean declaration significantly and reduces the amount of boilerplate code necessary for the application. In turn, Lariat's code will be easier to maintain, more readable for their developers, and easier to extend with capabilities over time. iv. Hands-on with WCA SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 <!-- ejb-jar.xml --> <ejb-jar> <enterprise-beans> <session> <ejb-name> LegacySessionBean </ejb-name> <home> com.lariat.ejb.LegacyHome </home> <remote> com.lariat.ejb.LegacyRemote </remote> <ejb-class> com.lariat.ejb.LegacySessionBean </ejb-class> <session-type> Stateless </session-type> <transaction-type> Container </transaction-type> </session> </enterprise-beans> </ejb-jar> After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY ejb-jar.xml Part 1 WCA LIBERTY ejb-jar.xml Part 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 <ejb-jar xmlns= \"http://java.sun.com/xml/ns/javaee\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd\" version= \"3.1\" > <enterprise-beans> <session> <ejb-name> LegacySessionBean </ejb-name> <ejb-class> com.lariat.ejb.LegacySessionBean </ejb-class> <session-type> Stateless </session-type> <transaction-type> Container </transaction-type> <concurrency-strategy> OnePerRequest </concurrency-strategy> <resource-ref> <res-ref-name> jdbc/LegacyDS </res-ref-name> <res-type> javax.sql.DataSource </res-type> <res-auth> Container </res-auth> </resource-ref> </session> </enterprise-beans> </ejb-jar> 1 2 3 4 5 6 7 8 9 10 11 import javax.annotation.Resource ; import javax.ejb.Stateless ; import javax.sql.DataSource ; @Stateless public class LegacySessionBean { @Resource ( name = \"jdbc/LegacyDS\" ) private DataSource dataSource ; // Your EJB methods here } In terms of EJB declarations , there is a divergence between the approaches taken by Lariat and favored by WCA. @Stateless @Remote ( ModernRemote . class ) public class ModernSessionBean implements ModernRemote In the case of the Lariat code (above), the declaration is fully annotation-based \u2014 as discussed earlier in this section. This provides a clear contract between the interface and applications, and is a relatively simple pattern for Lariat's developers to build against. <session> <ejb-name> LegacySessionBean </ejb-name> <ejb-class> com.lariat.ejb.LegacySessionBean </ejb-class> <session-type> Stateless </session-type> ... </session> WCA recommends that the EJB metadata remain in XML format, without the use of @Remote or @Local interfaces that were present within the Lariat code. Instead, WCA relies on container parsing of the ejb-jar.xml definition and generating it based on that discovered class. With respect to resource injections , this pattern is absent from the Lariat codebase. By contrast, WCA has configured the injection of a DataSource via @Resource in both Java and ejb-jar.xml . For example: @Resource ( name = \"jdbc/LegacyDS\" ) private DataSource dataSource ; One consideration to keep in mind with this case is that WCA's approach is tailored specifically for dealing with older enterprise systems or in cases where applications need to override behaviors per environment (via resource injection). v. Next steps In the following module, participants will examine how to modernize legacy WebSphere Application Server code for Java Message Service.","title":"5. EJB modernization"},{"location":"appmod/5/#enterprise-javabeans-ejb-modernizationapplication-modernization-websphere-to-liberty","text":"","title":"Enterprise JavaBeans (EJB) modernizationApplication Modernization - WebSphere to Liberty"},{"location":"appmod/5/#i-incentives-to-modernize","text":"SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". WebSphere Enterprise JavaBeans ( EJB ) represent server-side components used by Java Enterprise Edition ( Java EE or Jakarta EE ) to encapsulate repeatable business logic. In turn, EJB can be used to provide scalable and highly performant handling for requests made by Lariat Corporation's web application estate. EJBs provide the resource access management for the databases, messaging services, and external APIs these such application require to power their business functions. WebSphere's EJBs make extensive use of XML deployment descriptors to configure their behavior. Liberty EJBs use Java annotations instead of XML , applying them directly within Java classes for configuration. In many cases, this eliminates the need for external XML files completely (or at least significantly reduces their size and number). Feature WebSphere EJB with XML Liberty EJB with annotations Maintainability Difficult due to scattered XML configs. Improved due to cohesive annotations. Readability Lower due to switching between Java and XML. Higher due to configuration directly in Java code. Productivity Lower due to manual XML edits. Higher due to rapid development through annotations. Error Propensity Higher chance of manual XML errors. Lower due to clear annotations and IDE checks. Modernizing WebSphere's EJB's stateless session beans into Liberty's standard-compliant EJB will provide Lariat with the net benefit of code that's easier to maintain, more portable, and extensible for modern cloud-native endpoints. Ultimately, this should yield a simplified developer experience and better resource management.","title":"i. Incentives to modernize"},{"location":"appmod/5/#ii-websphere-legacy-code","text":"First, examine the legacy code (below), which as mentioned previously is a snapshot of a larger application using WebSphere's EJB Stateful Session Bean with XML : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 <!-- ejb-jar.xml --> <ejb-jar> <enterprise-beans> <session> <ejb-name> LegacySessionBean </ejb-name> <home> com.lariat.ejb.LegacyHome </home> <remote> com.lariat.ejb.LegacyRemote </remote> <ejb-class> com.lariat.ejb.LegacySessionBean </ejb-class> <session-type> Stateless </session-type> <transaction-type> Container </transaction-type> </session> </enterprise-beans> </ejb-jar> The legacy EJB implementation uses XML ( ejb-jar.xml beginning on line 1 ) to explicitly define the contents of the stateful session bean. This requires that the <home> and <remote> interfaces be explicitly defined, along with the bean class. Transaction types and security are also configured externally via descriptors within the XML.","title":"ii. WebSphere legacy code"},{"location":"appmod/5/#iii-liberty-modernized-code","text":"Consider below the modernized (but functionally equivalent) application code using Liberty's EJB Stateless Session Bean with annotations : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package com.lariat.ejb ; import javax.ejb.Stateless ; import javax.ejb.Remote ; @Stateless @Remote ( ModernRemote . class ) public class ModernSessionBean implements ModernRemote { @Override public String getGreeting ( String name ) { return \"Hello, \" + name + \"!\" ; } } package com.lariat.ejb ; import javax.ejb.Remote ; @Remote public interface ModernRemote { String getGreeting ( String name ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 <!-- ejb-jar.xml --> <ejb-jar> <enterprise-beans> <session> <ejb-name> LegacySessionBean </ejb-name> <home> com.lariat.ejb.LegacyHome </home> <remote> com.lariat.ejb.LegacyRemote </remote> <ejb-class> com.lariat.ejb.LegacySessionBean </ejb-class> <session-type> Stateless </session-type> <transaction-type> Container </transaction-type> </session> </enterprise-beans> </ejb-jar> The modernized Liberty code adopts EJB with Java annotations directly within the bean implementation; for example, utilizing such annotations as @Stateless beginning on line 6 : @Stateless @Remote ( ModernRemote . class ) public class ModernSessionBean implements ModernRemote { @Override public String getGreeting ( String name ) { return \"Hello, \" + name + \"!\" ; } } This approach also eliminates the need for explicit home interfaces, instead allowing Lariat's developers to directly specify remote interfaces within the bean definition. There are also positive side effects to the \"readability\" of the code \u2014 since transaction management and security settings are managed via annotations, the amount of XML overhead is reduced and thus the code can be more easily parsed (and maintained) by humans. Ultimately, Liberty's modernized EJB implementation simplifies the bean declaration significantly and reduces the amount of boilerplate code necessary for the application. In turn, Lariat's code will be easier to maintain, more readable for their developers, and easier to extend with capabilities over time.","title":"iii. Liberty modernized code"},{"location":"appmod/5/#iv-hands-on-with-wca","text":"SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 <!-- ejb-jar.xml --> <ejb-jar> <enterprise-beans> <session> <ejb-name> LegacySessionBean </ejb-name> <home> com.lariat.ejb.LegacyHome </home> <remote> com.lariat.ejb.LegacyRemote </remote> <ejb-class> com.lariat.ejb.LegacySessionBean </ejb-class> <session-type> Stateless </session-type> <transaction-type> Container </transaction-type> </session> </enterprise-beans> </ejb-jar> After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY ejb-jar.xml Part 1 WCA LIBERTY ejb-jar.xml Part 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 <ejb-jar xmlns= \"http://java.sun.com/xml/ns/javaee\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd\" version= \"3.1\" > <enterprise-beans> <session> <ejb-name> LegacySessionBean </ejb-name> <ejb-class> com.lariat.ejb.LegacySessionBean </ejb-class> <session-type> Stateless </session-type> <transaction-type> Container </transaction-type> <concurrency-strategy> OnePerRequest </concurrency-strategy> <resource-ref> <res-ref-name> jdbc/LegacyDS </res-ref-name> <res-type> javax.sql.DataSource </res-type> <res-auth> Container </res-auth> </resource-ref> </session> </enterprise-beans> </ejb-jar> 1 2 3 4 5 6 7 8 9 10 11 import javax.annotation.Resource ; import javax.ejb.Stateless ; import javax.sql.DataSource ; @Stateless public class LegacySessionBean { @Resource ( name = \"jdbc/LegacyDS\" ) private DataSource dataSource ; // Your EJB methods here } In terms of EJB declarations , there is a divergence between the approaches taken by Lariat and favored by WCA. @Stateless @Remote ( ModernRemote . class ) public class ModernSessionBean implements ModernRemote In the case of the Lariat code (above), the declaration is fully annotation-based \u2014 as discussed earlier in this section. This provides a clear contract between the interface and applications, and is a relatively simple pattern for Lariat's developers to build against. <session> <ejb-name> LegacySessionBean </ejb-name> <ejb-class> com.lariat.ejb.LegacySessionBean </ejb-class> <session-type> Stateless </session-type> ... </session> WCA recommends that the EJB metadata remain in XML format, without the use of @Remote or @Local interfaces that were present within the Lariat code. Instead, WCA relies on container parsing of the ejb-jar.xml definition and generating it based on that discovered class. With respect to resource injections , this pattern is absent from the Lariat codebase. By contrast, WCA has configured the injection of a DataSource via @Resource in both Java and ejb-jar.xml . For example: @Resource ( name = \"jdbc/LegacyDS\" ) private DataSource dataSource ; One consideration to keep in mind with this case is that WCA's approach is tailored specifically for dealing with older enterprise systems or in cases where applications need to override behaviors per environment (via resource injection).","title":"iv. Hands-on with WCA"},{"location":"appmod/5/#v-next-steps","text":"In the following module, participants will examine how to modernize legacy WebSphere Application Server code for Java Message Service.","title":"v. Next steps"},{"location":"appmod/6/","text":"Java Message Service integration Application Modernization - WebSphere to Liberty i. Incentives to modernize SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". WebSphere traditionally connects Java Enterprise Edition (Java EE) applications to IBM MQ using complex Java Message Service ( JMS ) configurations which depend upon external XML files. JMS is the standard by which Java APIs send, receive, and manage asynchronous messages between distributed Java EE applications. In turn, IBM MQ provides a middleware layer to ensure that such asynchronous messaging are delivered reliably between said applications. Collectively, these components come together to form the WebSphere MQ JMS integration that Lariat Corporation is using in their legacy systems today. Liberty still makes use of JMS and MQ, but replaces the use of external XML file configuration management in favor of declarative configurations directly within Liberty's server.xml resource. The result is that configuration is no longer defined external to the server, which in turn reduces the complexity of managing such configurations for Lariat's developers and improves the maintainability of their messaging integrations. Feature WebSphere MQ JMS Integration Liberty JMS Configuration Complexity High complexity owing to verbose XML or admin console requirements. Significantly simplified and concise. Maintainability Difficult, configuration is dispersed and complex. Easy to maintain, with all resources clearly defined in one place. Productivity Lower developer productivity due to manual configuration and overhead. Improved developer productivity due to straightforward and rapid setup. Integrations Cloud and microservices are harder to scale or adapt. Cloud and microservices are easily adapted due to cloud-native design. By modernizing Lariat's WebSphere-based approach of MQ JMS integration to Liberty's declarative JMS-based configuration, the expectation is that the company's management of asynchronous message delivery between applications can be more easily maintained and better aligned to cloud-native best practices. ii. WebSphere legacy code First, examine the legacy code (below), which as mentioned previously is a snapshot of a larger application using WebSphere's MQ JMS integration : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 <!-- ejb-jar.xml --> <message-driven> <ejb-name> LegacyMDB </ejb-name> <ejb-class> com.lariat.messaging.LegacyMDB </ejb-class> <transaction-type> Container </transaction-type> <message-driven-destination> <destination-type> javax.jms.Queue </destination-type> </message-driven-destination> </message-driven> <!-- ibm-ejb-jar-bnd.xml --> <message-driven name= \"LegacyMDB\" > <activation-config> <activation-config-property> <activation-config-property-name> destination </activation-config-property-name> <activation-config-property-value> jms/legacyQueue </activation-config-property-value> </activation-config-property> </activation-config> </message-driven> Lariat's particular implementation of WebSphere MQ JMS utilizes XML descriptors ( ejb-jar.xml , ibm-ejb-jar-bnd.xml on lines 1 and 11 , respectively) to define message-driven beans (MDB) and their JMS destinations. This is the explicit and manual style of configuring messaging endpoints through separate descriptor (XML) files \u2014 in sharp contrast to the declarative approach you will examine with Liberty momentarily. WebSphere's approach of using separate descriptor files makes the setup of new configurations potentially more complex and prone to human-induced errors within the code. iii. Liberty modernized code Consider below the modernized (but functionally equivalent) application code using Liberty's JMS configuration : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <!-- server.xml --> <server> <featureManager> <feature> jms-2.0 </feature> </featureManager> <jmsQueue id= \"modernQueue\" jndiName= \"jms/modernQueue\" /> <messageDrivenBean id= \"ModernMDB\" > <activationSpec> <activationSpecClass> javax.jms.Queue </activationSpecClass> <activationSpecProperty name= \"destination\" > jms/modernQueue </activationSpecProperty> </activationSpec> <className> com.lariat.messaging.ModernMDB </className> </messageDrivenBean> </server> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 <!-- ejb-jar.xml --> <message-driven> <ejb-name> LegacyMDB </ejb-name> <ejb-class> com.lariat.messaging.LegacyMDB </ejb-class> <transaction-type> Container </transaction-type> <message-driven-destination> <destination-type> javax.jms.Queue </destination-type> </message-driven-destination> </message-driven> <!-- ibm-ejb-jar-bnd.xml --> <message-driven name= \"LegacyMDB\" > <activation-config> <activation-config-property> <activation-config-property-name> destination </activation-config-property-name> <activation-config-property-value> jms/legacyQueue </activation-config-property-value> </activation-config-property> </activation-config> </message-driven> Through the process of modernizing the code, Lariat switched to Liberty's messaging providers using standardized JMS APIs in a single, unified server.xml configuration. All JMS resources, such as queues and MDBs, are defined directly within the server.xml configuration file. The net result is that configurations are simplified compared to the traditional WebSphere approach of separate descriptor files. Clearly named and easily identifiable JMS queues ( line 1 ), as well as activation specifications (beginning on line 3 ), are consolidated within the streamlined server.xml configuration. In summary, consolidation of Lariat's messaging configurations into a simplified and centralized pattern has streamlined future maintenance of these configuration files and simplified the process of troubleshooting messaging integrations for their developers. iv. Hands-on with WCA SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 <!-- ejb-jar.xml --> <message-driven> <ejb-name> LegacyMDB </ejb-name> <ejb-class> com.lariat.messaging.LegacyMDB </ejb-class> <transaction-type> Container </transaction-type> <message-driven-destination> <destination-type> javax.jms.Queue </destination-type> </message-driven-destination> </message-driven> <!-- ibm-ejb-jar-bnd.xml --> <message-driven name= \"LegacyMDB\" > <activation-config> <activation-config-property> <activation-config-property-name> destination </activation-config-property-name> <activation-config-property-value> jms/legacyQueue </activation-config-property-value> </activation-config-property> </activation-config> </message-driven> After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY ejb-jar.xml Part 1 WCA LIBERTY ejb-jar.xml Part 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 <ejb-jar xmlns= \"http://java.sun.com/xml/ns/javaee\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd\" version= \"3.1\" > <enterprise-beans> <message-driven> <ejb-name> LegacyMDB </ejb-name> <ejb-class> com.lariat.messaging.LegacyMDB </ejb-class> <transaction-type> Container </transaction-type> <message-driven-destination> <destination-type> javax.jms.Queue </destination-type> <destination-jndi-name> jms/legacyQueue </destination-jndi-name> </message-driven-destination> </message-driven> </enterprise-beans> </ejb-jar> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import javax.annotation.Resource ; import javax.jms.JMSException ; import javax.jms.Message ; import javax.jms.MessageListener ; import javax.jms.Queue ; import javax.jms.QueueConnection ; import javax.jms.QueueReceiver ; import javax.jms.QueueSender ; import javax.jms.Session ; import javax.naming.InitialContext ; import javax.naming.NamingException ; @MessageDriven ( name = \"LegacyMDB\" , activationConfig = { @ActivationConfigProperty ( propertyName = \"destination\" , propertyValue = \"jms/legacyQueue\" ) } ) public class LegacyMDB implements MessageListener { @Resource ( name = \"jms/legacyQueue\" ) private Queue queue ; @Resource ( name = \"jms/JmsConnectionFactory\" ) private QueueConnectionFactory connectionFactory ; @Resource ( name = \"jms/JmsXA\" ) private InitialContext initialContext ; public void onMessage ( Message message ) { // Your message processing logic here } // Other methods for sending messages, if needed } Explicit transaction control is vital for systems that rely heavily on transactional integrity (such as banking, healthcare, order processing, and so on), so let's compare how Lariat and WCA's modernization efforts performed in this regard. @Resource ( name = \"jms/JmsConnectionFactory\" ) private QueueConnectionFactory connectionFactory ; @Resource ( name = \"jms/JmsXA\" ) private InitialContext initialContext ; By injecting a QueueConnectionFactory and InitialContext , WCA allows developers to exact a high degree of control over the JMS lifecycle. For real-world enterprise operations, redundancy and explicit design can provide safety for production environments (as well as protection against misdeployments.) For many enterprises with continuous integration and continuous delivery ( CI/CD ) requirements, a Liberty codebase that uses an \" application code + server.xml \" approach may hamper those CI/CD pipelines. This is also true for enterprise organizations that might use runtime orchestration tools to override configurations with deployment descriptors. Let's compare the two solutions against this scenario. <ejb-jar xmlns= \"http://java.sun.com/xml/ns/javaee\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd\" version= \"3.1\" > WCA's invocation of ejb-jar.xml enables declarative binding for legacy JMS destinations, providing a degree of backwards compatibility to other legacy applications in the company's estate that isn't as easily achieved with Lariat's code. v. Next steps In the following module, participants will examine how to modernize legacy WebSphere Application Server code for security management.","title":"6. JMS integration"},{"location":"appmod/6/#java-message-service-integrationapplication-modernization-websphere-to-liberty","text":"","title":"Java Message Service integrationApplication Modernization - WebSphere to Liberty"},{"location":"appmod/6/#i-incentives-to-modernize","text":"SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". WebSphere traditionally connects Java Enterprise Edition (Java EE) applications to IBM MQ using complex Java Message Service ( JMS ) configurations which depend upon external XML files. JMS is the standard by which Java APIs send, receive, and manage asynchronous messages between distributed Java EE applications. In turn, IBM MQ provides a middleware layer to ensure that such asynchronous messaging are delivered reliably between said applications. Collectively, these components come together to form the WebSphere MQ JMS integration that Lariat Corporation is using in their legacy systems today. Liberty still makes use of JMS and MQ, but replaces the use of external XML file configuration management in favor of declarative configurations directly within Liberty's server.xml resource. The result is that configuration is no longer defined external to the server, which in turn reduces the complexity of managing such configurations for Lariat's developers and improves the maintainability of their messaging integrations. Feature WebSphere MQ JMS Integration Liberty JMS Configuration Complexity High complexity owing to verbose XML or admin console requirements. Significantly simplified and concise. Maintainability Difficult, configuration is dispersed and complex. Easy to maintain, with all resources clearly defined in one place. Productivity Lower developer productivity due to manual configuration and overhead. Improved developer productivity due to straightforward and rapid setup. Integrations Cloud and microservices are harder to scale or adapt. Cloud and microservices are easily adapted due to cloud-native design. By modernizing Lariat's WebSphere-based approach of MQ JMS integration to Liberty's declarative JMS-based configuration, the expectation is that the company's management of asynchronous message delivery between applications can be more easily maintained and better aligned to cloud-native best practices.","title":"i. Incentives to modernize"},{"location":"appmod/6/#ii-websphere-legacy-code","text":"First, examine the legacy code (below), which as mentioned previously is a snapshot of a larger application using WebSphere's MQ JMS integration : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 <!-- ejb-jar.xml --> <message-driven> <ejb-name> LegacyMDB </ejb-name> <ejb-class> com.lariat.messaging.LegacyMDB </ejb-class> <transaction-type> Container </transaction-type> <message-driven-destination> <destination-type> javax.jms.Queue </destination-type> </message-driven-destination> </message-driven> <!-- ibm-ejb-jar-bnd.xml --> <message-driven name= \"LegacyMDB\" > <activation-config> <activation-config-property> <activation-config-property-name> destination </activation-config-property-name> <activation-config-property-value> jms/legacyQueue </activation-config-property-value> </activation-config-property> </activation-config> </message-driven> Lariat's particular implementation of WebSphere MQ JMS utilizes XML descriptors ( ejb-jar.xml , ibm-ejb-jar-bnd.xml on lines 1 and 11 , respectively) to define message-driven beans (MDB) and their JMS destinations. This is the explicit and manual style of configuring messaging endpoints through separate descriptor (XML) files \u2014 in sharp contrast to the declarative approach you will examine with Liberty momentarily. WebSphere's approach of using separate descriptor files makes the setup of new configurations potentially more complex and prone to human-induced errors within the code.","title":"ii. WebSphere legacy code"},{"location":"appmod/6/#iii-liberty-modernized-code","text":"Consider below the modernized (but functionally equivalent) application code using Liberty's JMS configuration : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <!-- server.xml --> <server> <featureManager> <feature> jms-2.0 </feature> </featureManager> <jmsQueue id= \"modernQueue\" jndiName= \"jms/modernQueue\" /> <messageDrivenBean id= \"ModernMDB\" > <activationSpec> <activationSpecClass> javax.jms.Queue </activationSpecClass> <activationSpecProperty name= \"destination\" > jms/modernQueue </activationSpecProperty> </activationSpec> <className> com.lariat.messaging.ModernMDB </className> </messageDrivenBean> </server> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 <!-- ejb-jar.xml --> <message-driven> <ejb-name> LegacyMDB </ejb-name> <ejb-class> com.lariat.messaging.LegacyMDB </ejb-class> <transaction-type> Container </transaction-type> <message-driven-destination> <destination-type> javax.jms.Queue </destination-type> </message-driven-destination> </message-driven> <!-- ibm-ejb-jar-bnd.xml --> <message-driven name= \"LegacyMDB\" > <activation-config> <activation-config-property> <activation-config-property-name> destination </activation-config-property-name> <activation-config-property-value> jms/legacyQueue </activation-config-property-value> </activation-config-property> </activation-config> </message-driven> Through the process of modernizing the code, Lariat switched to Liberty's messaging providers using standardized JMS APIs in a single, unified server.xml configuration. All JMS resources, such as queues and MDBs, are defined directly within the server.xml configuration file. The net result is that configurations are simplified compared to the traditional WebSphere approach of separate descriptor files. Clearly named and easily identifiable JMS queues ( line 1 ), as well as activation specifications (beginning on line 3 ), are consolidated within the streamlined server.xml configuration. In summary, consolidation of Lariat's messaging configurations into a simplified and centralized pattern has streamlined future maintenance of these configuration files and simplified the process of troubleshooting messaging integrations for their developers.","title":"iii. Liberty modernized code"},{"location":"appmod/6/#iv-hands-on-with-wca","text":"SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 <!-- ejb-jar.xml --> <message-driven> <ejb-name> LegacyMDB </ejb-name> <ejb-class> com.lariat.messaging.LegacyMDB </ejb-class> <transaction-type> Container </transaction-type> <message-driven-destination> <destination-type> javax.jms.Queue </destination-type> </message-driven-destination> </message-driven> <!-- ibm-ejb-jar-bnd.xml --> <message-driven name= \"LegacyMDB\" > <activation-config> <activation-config-property> <activation-config-property-name> destination </activation-config-property-name> <activation-config-property-value> jms/legacyQueue </activation-config-property-value> </activation-config-property> </activation-config> </message-driven> After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY ejb-jar.xml Part 1 WCA LIBERTY ejb-jar.xml Part 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 <ejb-jar xmlns= \"http://java.sun.com/xml/ns/javaee\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd\" version= \"3.1\" > <enterprise-beans> <message-driven> <ejb-name> LegacyMDB </ejb-name> <ejb-class> com.lariat.messaging.LegacyMDB </ejb-class> <transaction-type> Container </transaction-type> <message-driven-destination> <destination-type> javax.jms.Queue </destination-type> <destination-jndi-name> jms/legacyQueue </destination-jndi-name> </message-driven-destination> </message-driven> </enterprise-beans> </ejb-jar> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import javax.annotation.Resource ; import javax.jms.JMSException ; import javax.jms.Message ; import javax.jms.MessageListener ; import javax.jms.Queue ; import javax.jms.QueueConnection ; import javax.jms.QueueReceiver ; import javax.jms.QueueSender ; import javax.jms.Session ; import javax.naming.InitialContext ; import javax.naming.NamingException ; @MessageDriven ( name = \"LegacyMDB\" , activationConfig = { @ActivationConfigProperty ( propertyName = \"destination\" , propertyValue = \"jms/legacyQueue\" ) } ) public class LegacyMDB implements MessageListener { @Resource ( name = \"jms/legacyQueue\" ) private Queue queue ; @Resource ( name = \"jms/JmsConnectionFactory\" ) private QueueConnectionFactory connectionFactory ; @Resource ( name = \"jms/JmsXA\" ) private InitialContext initialContext ; public void onMessage ( Message message ) { // Your message processing logic here } // Other methods for sending messages, if needed } Explicit transaction control is vital for systems that rely heavily on transactional integrity (such as banking, healthcare, order processing, and so on), so let's compare how Lariat and WCA's modernization efforts performed in this regard. @Resource ( name = \"jms/JmsConnectionFactory\" ) private QueueConnectionFactory connectionFactory ; @Resource ( name = \"jms/JmsXA\" ) private InitialContext initialContext ; By injecting a QueueConnectionFactory and InitialContext , WCA allows developers to exact a high degree of control over the JMS lifecycle. For real-world enterprise operations, redundancy and explicit design can provide safety for production environments (as well as protection against misdeployments.) For many enterprises with continuous integration and continuous delivery ( CI/CD ) requirements, a Liberty codebase that uses an \" application code + server.xml \" approach may hamper those CI/CD pipelines. This is also true for enterprise organizations that might use runtime orchestration tools to override configurations with deployment descriptors. Let's compare the two solutions against this scenario. <ejb-jar xmlns= \"http://java.sun.com/xml/ns/javaee\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd\" version= \"3.1\" > WCA's invocation of ejb-jar.xml enables declarative binding for legacy JMS destinations, providing a degree of backwards compatibility to other legacy applications in the company's estate that isn't as easily achieved with Lariat's code.","title":"iv. Hands-on with WCA"},{"location":"appmod/6/#v-next-steps","text":"In the following module, participants will examine how to modernize legacy WebSphere Application Server code for security management.","title":"v. Next steps"},{"location":"appmod/7/","text":"Security modernization Application Modernization - WebSphere to Liberty i. Incentives to modernize SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". Traditionally, Lariat Corporation has leveraged WebSphere's approach to defining application security configurations\u2014 for roles, authentication, authorization, and access constraints \u2014via external, XML-based deployment descriptors. Oftentimes these take the forms of standard deployment descriptors (like web.xml ) or IBM-specific descriptors ( ibm-application-bnd.xml ). Liberty applications, by contrast, utilize Java annotations to embed security rules directly in-line within Java classes or methods. This helps to eliminate (or at least reduce) dependencies on external XML descriptors, creating a more robust security implementation and permitting simple to maintain configurations. Java annotations are patterned using Java Enterprise Edition (Java EE or Jakarta EE) standards which align directly with the best-practices of cloud-native design. Feature WebSphere XML-based security Liberty annotations-based security Maintainability Complex owing to dispersed configuration. Simplified owing to centralized and self-contained design. Readability Challenging due to XML files separated from Java code. Easier due to in-line annotations that provide clarity. Productivity Lower developer productivity due to frequent context-switching. Improved developer productivity due to direct configurations via code annotations. Standardization Considered a legacy practice, less aligned with modern industry standards. Modern standard (Jakarta EE) that aligns with cloud-native practices. Ultimately, Lariat anticipates that modernization of their WebSphere application's security from XML-based descriptors to Java annotation will reduce the complexity of their security configuration management as they move steadily towards cloud-native application design. ii. WebSphere legacy code First, examine the legacy code (below), which as mentioned previously is a snapshot of a larger application using WebSphere's XML-based security : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 <!-- web.xml --> <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> <login-config> <auth-method> FORM </auth-method> <form-login-config> <form-login-page> /login.jsp </form-login-page> <form-error-page> /error.jsp </form-error-page> </form-login-config> </login-config> <security-role> <role-name> admin </role-name> </security-role> The legacy XML-based code defines security constraints explicitly in web.xml using roles and URL pattern-matching, creating conditions where form-based authentication settings are specified through XML. Naturally, this complicates security management for Lariat's developer teams, as external role definitions now need to be declared in a specific manner owing to this architectural choice. In order to modernize this code, Lariat will need to convert the role-based authorization mechanisms and deployment descriptors into Java annotations. iii. Liberty modernized code Consider below the modernized (but functionally equivalent) application code using Liberty's annotation-based security : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import javax.annotation.security.DeclareRoles ; import javax.annotation.security.RolesAllowed ; import javax.ws.rs.GET ; import javax.ws.rs.Path ; import javax.ws.rs.core.Response ; @Path ( \"/secured\" ) @DeclareRoles ({ \"admin\" }) public class SecuredEndpoint { @GET @Path ( \"/data\" ) @RolesAllowed ( \"admin\" ) public Response getSecuredData () { return Response . ok ( \"Sensitive data available only to admins.\" ). build (); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 <!-- web.xml --> <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> <login-config> <auth-method> FORM </auth-method> <form-login-config> <form-login-page> /login.jsp </form-login-page> <form-error-page> /error.jsp </form-error-page> </form-login-config> </login-config> <security-role> <role-name> admin </role-name> </security-role> The modernized, Java annotations-driven security of Liberty defines @DeclareRoles ( line 8 ) and @RolesAllowed ( line 13 ) to clearly create security constraints at the method and class level. @DeclareRoles ({ \"admin\" }) @Path ( \"/secured\" ) public class SecuredEndpoint { @GET @RolesAllowed ( \"admin\" ) public Response getSecuredData () { return Response . ok ( \"Sensitive data available only to admins.\" ). build (); } } This approach simplifies the URL and method-level security mechanisms that were present within the legacy WebSphere code, replacing it via annotations within RESTful (REST API-addressable) endpoints. Ultimately, this reduces the need for external configuration and instead centralizes security declarations closer to the actual code implementation. Lariat, in turn, gains the benefits of improved clarity in how their security constraints are structured. This will enable more straightforward audits in the future and simplify the ongoing maintenance of security policies across their organization. iv. Hands-on with WCA SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 <!-- web.xml --> <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> <login-config> <auth-method> FORM </auth-method> <form-login-config> <form-login-page> /login.jsp </form-login-page> <form-error-page> /error.jsp </form-error-page> </form-login-config> </login-config> <security-role> <role-name> admin </role-name> </security-role> After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY web.xml Part 1 WCA LIBERTY web.xml Part 2 WCA LIBERTY web.xml Part 3 WCA LIBERTY web.xml Part 4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> <security-role> <role-name> admin </role-name> </security-role> <security-role-mapping> <role-name> admin </role-name> <user> adminUser </user> </security-role-mapping> 1 2 3 4 5 6 7 8 9 10 <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> <http-method> POST </http-method> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> 1 2 3 4 <login-config> <auth-method> BASIC </auth-method> <realm-name> MyRealm </realm-name> </login-config> 1 2 3 4 <error-page> <error-code> 401 </error-code> <location> /unauthorized.jsp </location> </error-page> With regards to granular control over security measures, WCA's recommendation provides much finer-grain control over the HTTP methods and URLs that are invoked by the Liberty code. Lariat's approach to modernized Liberty, by contrast, provides simpler endpoint-level restrictions. Examine the explicit security configuration recommended by WCA below: <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> WCA has defined clear security boundaries which align to enterprise standards. XML-based descriptors are often preferred within enterprise environments because those definitions are explicit, centralized, and easily audited. Changes made to Lariat's security policies can be applied quickly without needing to recompile and redeploy the code. Let's examine WCA's recommendations for fine-grained HTTP method control : <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> <http-method> POST </http-method> </web-resource-collection> WCA's Liberty code allows Lariat to restrict specific HTTP methods (like POST , PUT , DELETE ) independently of GET methods. This is essential for scenarios where reading data (with GET ) might be broadly allowed by certain applications or users within the enterprise IT estate, but other restricted operations (like POST ) need to remain tightly controlled. Lastly, consider the explicit role-to-user mapping defined by WCA's recommendation: <security-role-mapping> <role-name> admin </role-name> <user> adminUser </user> </security-role-mapping> Once again, this recommendation has been specifically tailored for enterprise use cases. WCA's defines which set of users belong to which roles \u2014 reflecting the need that Lariat, and many other enterprise organizations, have for transparency in user-role assignments. Explicit definitions such as these ensure that the modernized Liberty code is easily managed and tightly controlled by Lariat's developers. v. Conclusion Full-stack modernization requires access to the entire application code base of libraries, dependencies, compiled assets, and the contents of the application's directory structure \u2014 combined as well with the transformation guidance that is built out using IBM Cloud Transformation Advisor . Out of context fragments of application code cannot convey that level of information and complexity. Techniques for full-stack application modernization will be explored in following section.","title":"7. Security modernization"},{"location":"appmod/7/#security-modernizationapplication-modernization-websphere-to-liberty","text":"","title":"Security modernizationApplication Modernization - WebSphere to Liberty"},{"location":"appmod/7/#i-incentives-to-modernize","text":"SECTION I. TERMINOLOGY For readability, IBM WebSphere Application Server (WAS) in this chapter is referred to in shorthand as \"WebSphere\", unless noted otherwise. Similarly, IBM WebSphere Liberty is referenced in shorthand as simply \"Liberty\". Traditionally, Lariat Corporation has leveraged WebSphere's approach to defining application security configurations\u2014 for roles, authentication, authorization, and access constraints \u2014via external, XML-based deployment descriptors. Oftentimes these take the forms of standard deployment descriptors (like web.xml ) or IBM-specific descriptors ( ibm-application-bnd.xml ). Liberty applications, by contrast, utilize Java annotations to embed security rules directly in-line within Java classes or methods. This helps to eliminate (or at least reduce) dependencies on external XML descriptors, creating a more robust security implementation and permitting simple to maintain configurations. Java annotations are patterned using Java Enterprise Edition (Java EE or Jakarta EE) standards which align directly with the best-practices of cloud-native design. Feature WebSphere XML-based security Liberty annotations-based security Maintainability Complex owing to dispersed configuration. Simplified owing to centralized and self-contained design. Readability Challenging due to XML files separated from Java code. Easier due to in-line annotations that provide clarity. Productivity Lower developer productivity due to frequent context-switching. Improved developer productivity due to direct configurations via code annotations. Standardization Considered a legacy practice, less aligned with modern industry standards. Modern standard (Jakarta EE) that aligns with cloud-native practices. Ultimately, Lariat anticipates that modernization of their WebSphere application's security from XML-based descriptors to Java annotation will reduce the complexity of their security configuration management as they move steadily towards cloud-native application design.","title":"i. Incentives to modernize"},{"location":"appmod/7/#ii-websphere-legacy-code","text":"First, examine the legacy code (below), which as mentioned previously is a snapshot of a larger application using WebSphere's XML-based security : WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 <!-- web.xml --> <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> <login-config> <auth-method> FORM </auth-method> <form-login-config> <form-login-page> /login.jsp </form-login-page> <form-error-page> /error.jsp </form-error-page> </form-login-config> </login-config> <security-role> <role-name> admin </role-name> </security-role> The legacy XML-based code defines security constraints explicitly in web.xml using roles and URL pattern-matching, creating conditions where form-based authentication settings are specified through XML. Naturally, this complicates security management for Lariat's developer teams, as external role definitions now need to be declared in a specific manner owing to this architectural choice. In order to modernize this code, Lariat will need to convert the role-based authorization mechanisms and deployment descriptors into Java annotations.","title":"ii. WebSphere legacy code"},{"location":"appmod/7/#iii-liberty-modernized-code","text":"Consider below the modernized (but functionally equivalent) application code using Liberty's annotation-based security : WEBSPHERE LIBERTY WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import javax.annotation.security.DeclareRoles ; import javax.annotation.security.RolesAllowed ; import javax.ws.rs.GET ; import javax.ws.rs.Path ; import javax.ws.rs.core.Response ; @Path ( \"/secured\" ) @DeclareRoles ({ \"admin\" }) public class SecuredEndpoint { @GET @Path ( \"/data\" ) @RolesAllowed ( \"admin\" ) public Response getSecuredData () { return Response . ok ( \"Sensitive data available only to admins.\" ). build (); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 <!-- web.xml --> <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> <login-config> <auth-method> FORM </auth-method> <form-login-config> <form-login-page> /login.jsp </form-login-page> <form-error-page> /error.jsp </form-error-page> </form-login-config> </login-config> <security-role> <role-name> admin </role-name> </security-role> The modernized, Java annotations-driven security of Liberty defines @DeclareRoles ( line 8 ) and @RolesAllowed ( line 13 ) to clearly create security constraints at the method and class level. @DeclareRoles ({ \"admin\" }) @Path ( \"/secured\" ) public class SecuredEndpoint { @GET @RolesAllowed ( \"admin\" ) public Response getSecuredData () { return Response . ok ( \"Sensitive data available only to admins.\" ). build (); } } This approach simplifies the URL and method-level security mechanisms that were present within the legacy WebSphere code, replacing it via annotations within RESTful (REST API-addressable) endpoints. Ultimately, this reduces the need for external configuration and instead centralizes security declarations closer to the actual code implementation. Lariat, in turn, gains the benefits of improved clarity in how their security constraints are structured. This will enable more straightforward audits in the future and simplify the ongoing maintenance of security policies across their organization.","title":"iii. Liberty modernized code"},{"location":"appmod/7/#iv-hands-on-with-wca","text":"SECTION IV. TERMINOLOGY For the purposes of comparison and brevity, the WCA-generated Liberty code will be referred to simply as \" WCA \" and Lariat Corporation's best-practice modernized code will be referred to as \" Lariat \". In the following section, participants will have the opportunity to experiment with the watsonx Code Assistant ( WCA ) service set up in the IBM Cloud (SaaS) Configuration module . Using the Chat feature, which can be accessed via the WCA extension for Visual Studio Code (VS Code), you will first ask WCA convert the original WebSphere Application Service (WCA) code into a modernized equivalent for WebSphere Liberty . The lab guide documentation will then walk you through an analysis of the WCA-generated Liberty code and compare that to the best-practice Liberty code discussed previously in iii. Liberty modernized code . After comparing the two approaches to Liberty modernization, you will have the opportunity to continue tinkering with the WCA Chat service. Experimentation is encouraged. Try influencing WCA's generative AI recommendations by making further prompts or inquiries into the code responses it generates. When satisfied, you may proceed onwards to the next module. Log in to the WCA extension with VS Code . Once authenticated, proceed to Step 2. From the left taskbar, ensure that watsonx Code Assistant [A] extension is selected. Within the Chat Session window, click on the Enter / for commands prompt [B] as shown. Prime the service to be ready to intake legacy WAS code and modernize that into Liberty code. As a suggestion, copy the following prompt, paste it into the chat window, and hit Enter to execute the modernization request: I need to modernize code written for WebSphere Application Server into WebSphere Liberty. Can you help? TIP: You can increase the width of the Chat Session window by clicking and dragging the right-side of the window frame and pulling it towards the right of the screen. Now that WCA is primed to receive WAS code, copy and paste the following code block into the Chat Session , then Enter to execute. WEBSPHERE APPLICATION SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 <!-- web.xml --> <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> <login-config> <auth-method> FORM </auth-method> <form-login-config> <form-login-page> /login.jsp </form-login-page> <form-error-page> /error.jsp </form-error-page> </form-login-config> </login-config> <security-role> <role-name> admin </role-name> </security-role> After a few moments, WCA will return a combination of code blocks and explanations to the Chat session console. Cycle through the tab(s) below to examine the modernized, WCA-generated Liberty code . WCA LIBERTY web.xml Part 1 WCA LIBERTY web.xml Part 2 WCA LIBERTY web.xml Part 3 WCA LIBERTY web.xml Part 4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> <security-role> <role-name> admin </role-name> </security-role> <security-role-mapping> <role-name> admin </role-name> <user> adminUser </user> </security-role-mapping> 1 2 3 4 5 6 7 8 9 10 <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> <http-method> POST </http-method> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> 1 2 3 4 <login-config> <auth-method> BASIC </auth-method> <realm-name> MyRealm </realm-name> </login-config> 1 2 3 4 <error-page> <error-code> 401 </error-code> <location> /unauthorized.jsp </location> </error-page> With regards to granular control over security measures, WCA's recommendation provides much finer-grain control over the HTTP methods and URLs that are invoked by the Liberty code. Lariat's approach to modernized Liberty, by contrast, provides simpler endpoint-level restrictions. Examine the explicit security configuration recommended by WCA below: <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> </web-resource-collection> <auth-constraint> <role-name> admin </role-name> </auth-constraint> </security-constraint> WCA has defined clear security boundaries which align to enterprise standards. XML-based descriptors are often preferred within enterprise environments because those definitions are explicit, centralized, and easily audited. Changes made to Lariat's security policies can be applied quickly without needing to recompile and redeploy the code. Let's examine WCA's recommendations for fine-grained HTTP method control : <security-constraint> <web-resource-collection> <web-resource-name> SecureArea </web-resource-name> <url-pattern> /secured/* </url-pattern> <http-method> POST </http-method> </web-resource-collection> WCA's Liberty code allows Lariat to restrict specific HTTP methods (like POST , PUT , DELETE ) independently of GET methods. This is essential for scenarios where reading data (with GET ) might be broadly allowed by certain applications or users within the enterprise IT estate, but other restricted operations (like POST ) need to remain tightly controlled. Lastly, consider the explicit role-to-user mapping defined by WCA's recommendation: <security-role-mapping> <role-name> admin </role-name> <user> adminUser </user> </security-role-mapping> Once again, this recommendation has been specifically tailored for enterprise use cases. WCA's defines which set of users belong to which roles \u2014 reflecting the need that Lariat, and many other enterprise organizations, have for transparency in user-role assignments. Explicit definitions such as these ensure that the modernized Liberty code is easily managed and tightly controlled by Lariat's developers.","title":"iv. Hands-on with WCA"},{"location":"appmod/7/#v-conclusion","text":"Full-stack modernization requires access to the entire application code base of libraries, dependencies, compiled assets, and the contents of the application's directory structure \u2014 combined as well with the transformation guidance that is built out using IBM Cloud Transformation Advisor . Out of context fragments of application code cannot convey that level of information and complexity. Techniques for full-stack application modernization will be explored in following section.","title":"v. Conclusion"},{"location":"appmod/8/","text":"Full stack modernization Application Modernization - WebSphere to Liberty i. Objectives As a capstone to the experimentation and feature-exploration conducted with IBM watsonx Code Assistant ( WCA ) in the previous modules of this lab, participants will conclude the Application Modernization topic with a hands-on opportunity: modernization of a full-stack WebSphere Application Service (WAS) application into WebSphere Liberty. Participants will be tasked with: Explaining the purpose of the legacy WAS code and detailing the necessary transformations Modernizing legacy packages and libraries from WAS to Liberty Upgrading Java versions from Java 8 to Java 21 Code recommendations will be generated using WCA Chat , as in the previous modules, alongside the Modernize and Java Upgrade capabilities built into WCA Standard plans The culmination of this work will be a fully modernized and interactive web application that tangibly demonstrates the benefits of the techniques discussed throughout this lab. ii. Setting up Return to the Visual Studio Code (VS Code) application. It should already be signed in and authenticated with the WCA service on IBM Cloud \u2014 if it's not, follow the instructions in the IBM Cloud (SaaS) Configuration lab. Ensure that the Explorer tab is cleared of any previously-opened folders or files before continuing. With the VS Code Explorer tab selected and open, click File > Close Folder from the top taskbar. Additional software must be prepared within VS Code before continuing with WCA Standard Plan's enterprise capabilities for WebSphere modernization. INCOMPATIBILITY WITH JDK 24 Note that the Full stack modernization module in Application Modernization - WebSphere to Liberty will encounter compatibility errors with JDK 24 drivers when attempting to Explain or Modernize the source application. This is owing to a deprecation of sun.misc.Unsafe method as of March 2025. Additional details may be found here. As a result, participants in this lab should ensure they are running JDK 21 (or as early as JDK 11), but specifically not JDK 24. If you are running JDK 24, you should uninstall the JDK from your machine and reinstall with the links provided in Configure the enterprise Java environment . From the left-hand side of the VS Code interface, click the Extensions tab Within the Extensions: Marketplace search bar , search for Liberty Tools Click the blue Install button to the right of the Liberty Tools tile Dismiss any \"Welcome\" splash screens Once the install is complete, return to the Extensions tab again Within the Extensions: Marketplace search bar , search Extension Pack for Java Click the blue Install to the right of the Extension Pack for Java tile Wait for the install to complete and dismiss any \"Welcome\" splash screens Next, participants must download the WebSphere Application Server (WAS) assets that are to be modernized. The assets will be retrieved from the linked application repository: wca-assets-2025.zip URL: https://ibm.box.com/s/ps65ax6mupmwx3pww2b2ylvc9ed18njp Save the wca-assets-2025.zip file to your local machine and unzip the contents Open the Explorer tab from the VS Code interface Click the blue Open Folder button and select the unzipped wca-assets-2025 directory The wca-assets-2025 contents will automatically open within Explorer iii. Deploy the application Participants now need to build the application Project . Open a Terminal within VS Code (if you haven't already) by clicking Terminal > New Terminal from the top taskbar. Navigate using the Terminal to the folder where wca-assets-2025 was saved in Step 3 and drill down /1-java-modernization/modresorts-twas-j8/was_dependency directory Attention: Substitute the <REPLACE> placeholder with the path to your directory cd <REPLACE>/wca-assets-2025/1-java-modernization/modresorts-twas-j8/was_dependency Source the ~/.zshrc PATH and JAVA_HOME variables (set up previously in the Configure the enterprise Java environment module) by executing the following: source ~/.zshrc The necessary Maven dependencies must be prepared within the was_dependency directory before the application can be deployed. Using a Terminal, execute the following instruction: mvn install:install-file -Dfile = was_public.jar -DpomFile = was_public-9.0.0.pom WINDOWS USERS Windows users might need to provide the full path for the build files was_public.jar and was_public-9.0.0.pom , for example: mvm install:install-file -Dfile = C: \\U sers \\A dministrator.CE-APAC-WIND202 \\D ocuments \\w ca4ej-workshop \\m odresorts \\t was \\j 8 \\w as_dependency \\w as_public.jar -Dpom-File = C: \\U sers \\A dministrator.CE-APAC-WIND202 \\D ocuments \\w ca4ej-workshop \\m odresorts-twas-j8 \\w as_dependency \\w as_public-9.0.0.pom With the was_dependency folder now prepared with the necessary drivers, you are ready to build and deploy the application project into a live web application Open the Explorer tab from the left-hand side of the VS Code interface Below the list of assets belonging the modresorts-twas-j8 directory, locate and toggle the LIBERTY DASHBOARD [A] drop-down panel amongst the tabs If modresorts is not displayed, click the Add project to Liberty Dashboard [B] and press Enter when prompted to select the modresorts-twas-j8 project [C] Within the LIBERTY DASHBOARD , a modresorts app will show up under the Liberty Dashboard panel. Right click on the modresorts project name to open the drop-down menu of options Click Start to initialize the project VS Code will automatically download the necessary packages (you can trace the progress within the Terminal console) Wait until the initialization process has finished and the console has returned a Source compilation was successful message Copy and record the Web application available (default host): ... address returned by the Terminal console ( http://localhost:9080/resorts or similar) Record the value of the Liberty Debug Port to a notepad for reference later. Open a new web browser tab and visit the Web application URL recorded in Step 7. Explore and familiarize yourself with the various tabs and pages built into the legacy web application. ERRORS AND BROKEN WEB LINKS As the legacy application has been built for WebSphere Application Server (WAS) using Java 8 , but the deployment generated in Step 7 was intended for WebSphere Liberty using Java 21 , there are a number of pages within the app that will produce an \"Error\" \u2014 for example, the location information module. These will be aspects of the application that you will remedy as part of the modernization steps that follow. iv. Explain the project code Let's better understand the entirety of the project by using the explainability features built into watsonx Code Assistant. Open the Explorer tab from the left-hand interface to view the contents of the modresorts-twas-j8 project Right-click anywhere inside the modresorts-twas-j8 workspace [A] to open a drop-down menu of options Hover over the watsonx Code Assistant option and then select Explain Application [B] When prompted, click Proceed with code analysis Wait 1-2 minutes for the analysis to complete, at which time a pop-up will appear in the bottom-right corner of VS Code stating that The explanation has been completed Click the Open explanation button within the pop-up to open and peruse the report Record the entire output of the Explain Application report to a notepad for reference later. v. Build a modernization plan Before modernizing the WAS application into Liberty, you'll need to scope out the necessary changes and level of effort required to do so. To obtain that understanding, you will need to generate a modernization plan using IBM Cloud Transformation Advisor . For the purposes of this lab, one such plan has been prepared ahead of time and included within the modresorts-twas-j8 project folder. Open the Explore tab of VS Code and right-click anywhere inside the modresorts-twas-j8 workspace. Then hover over watsonx Code Assistant and select Modernize to Liberty . A Modernize to Liberty tab will open within the VS Code interface As the modernization plan prepared earlier by IBM Cloud Transformation Advisor has not yet been uploaded to WCA at this stage, the modernization recommendations proposed currently by the service are less granular and contextualized than they will be after uploading the migration bundle. This presents an interesting opportunity to compare the before and after impacts of the migration bundle on the WCA modernization plan. Before uploading the migration bundle , take note of the following information and record it to a notepad for reference later: how many proposed fixes are suggested for Automated Fixes , Assisted Fixes , and Self-Directed Fixes ? To supply the migration bundle, click the Return to Upload / analyze button in the top-right corner of the Modernize to Liberty panel Click the Upload migration bundle button When prompted, specify modresorts-twas-j8/migration-bundle/modresorts.ear_migrationBundle.zip as the location of the migration bundle Observe the state of the Selected files to be added to the project before making any adjustments or selections. Record these observations to a notepad for reference later. Be sure that both the server.xml and Containerfile assets are selected, then click Proceed to continue Analysis will take a few moments to complete. When ready, the Modernize panel will generate a report that identifies issues with the application that need to be fixed. Some of these can be automatically repaired, while others will require a degree of manual intervention. Under the Issues header, click the Automated fixes to pull open the list of issues that can be automated Inspect each of the automated fix suggestions, including their titles and the contents within the expandable tabs. These details should be recorded to a notepad for reference later. See more details about each by clicking the drop-down error to the right of the issue Click the Run automated fixes button at the bottom of the page to execute the automated fixes to Liberty After receiving a BUILD SUCCESS message from the console: Record details about the Estimate of time saved included in the console read-out Take note of how many Java source files were modified as a result of the automated fixes. Save this information to a notepad for reference later. View details about the fix(es) requiring a degree of manual intervention by clicking the Assisted fixes tab. Record the total number of Assisted fixes , Self-directed fixes , and Additional information suggestions to a notepad for future reference. Along the top of the tab, left-click the grey Instructions [A] panel to reveal the WCA-generated guidance on how to resolve the migration problems. In this example, the WebSphere Servlet API was superseded by a newer implementation that uses Servlet 3.0 functionality and as such a trio of packages used by the WAS app will no longer be available for use with Liberty Further down the panel, impacted file(s) in the legacy application code will be provided Click [B] the drop-down arrow to the right of the impacted file to reveal a detailed set of instructions for how to improve the code Afterwards, click [C] the name of the impacted file to inspect its source code in a new editor window: src/main/java/com/acme/modres/UpperServlet.java An editor window will open on the right side of VS Code, displaying the contents of UpperServlet.java for editing. The next set of instructions will follow along with the guidance recommended by the Modernize panel (in the center of the VS Code interface): Select [A] all of the class that uses the ResponseUtils.encodeDataString() method, beginning on Line 14 from @WebServlet(\"/resorts/upper\") and ending on Line 27 (an empty newline) Record the text (if any) that appears directly above Line 14 within the open UpperServlet.java file contents window. Save this information to a notepad for reference later. With the relevant code selected, click the Help me [B] button in the Modernize panel WCA will engage a Chat session and generate within the conversation TWO sets of code fixes that can be added to the legacy code in order to remedy the issue. Recommendation 1: The first fix will be a substitute of the lines of code for UpperServlet.java , beginning on Line 23 and ending on Line 26 . A new line will also need to be added to the import statements at the beginning of the file. // Assisted by watsonx Code Assistant import org.apache.commons.text.StringEscapeUtils ; @WebServlet ( \"/resorts/upper\" ) public class UpperServlet extends HttpServlet { private static final long serialVersionUID = 1L ; @Override protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { response . setContentType ( \"text/html\" ); String originalStr = request . getParameter ( \"input\" ); if ( originalStr == null ) { originalStr = \"\" ; } String escapedStr = StringEscapeUtils . escapeHtml4 ( originalStr ); newStr = StringEscapeUtils . escapeHtml4 ( newStr ); PrintWriter out = response . getWriter (); out . print ( \"<br/><b>capitalized input \" + newStr + \"</b>\" ); } } Recommendation 2: The second fix will be new lines of code that are to be added to the pom.xml file. < dependency > < groupId > org . apache . commons </ groupId > < artifactId > commons - text </ a > < version > 1.12.0 </ version > </ dependency > Edit the contents of UpperServlet.java by replacing the highlighted lines of code as instructed in Step 14 with the WCA-generated Recommendation 1 code. Save the changes to the file ( File > Save ). Locate the pom.xml file from the list of assets under the Explorer tab. Double-click on the filename to edit the contents Scroll down until you reach Level 58 ( </dependency> ) and place your cursor at the end of the line, then hit Enter to create a new line Beginning on the new Line 59 of the pom.xml contents, add the contents of WCA's Recommendation 2 (the second code block of Step 14 ) to the file The new lines of code should now occupy Lines 59-63 of the modified pom.xml code Ensure that the indentation lines up with other <dependency> declarations within the parent <dependencies> nesting Save the changes to the file ( File > Save ) With the application code now modified\u2014 by a combination of automated fixes and manual interventions \u2014the original deployment launched in Step 4 will need to be re-deployed. Return to the open VS Code Terminal Press Ctrl + C to terminate the application Record the message returned by the console after terminating the application. Save this information to a notebook for reference later. To re-deploy the application, return to the Modernize panel (right hand side). Take note of the fact that all Issues previously reported by the tool have been resolved. Click the Rebuild and refresh button to re-deploy the modernized application Wait for the Modernize ModResorts summary to refresh: it should now should only 1 Automated fix (optional and can be ignore) and 0 Assisted fixes are recommended Open the Explorer tab and locate the LIBERTY DASHBOARD drop-down Right click on modresorts , click Start , and wait for the console to report a successful deployment Refresh the tab of the web application to inspect the modernized Liberty application Previously broken features, such as the Logout button, should now be fully operable Click the Logout button on the redeployed ModResorts page. Wait for the page to refresh and then record the message on the page to a notepad for reference later. vi. Java version upgrades Recall from before that the application's version of Java code was originally written for Java 8 . However, to be compliant with modern versions of Liberty, that Java code will need to be upgraded to Java 21 . With the Explorer tab active, right click on the modresorts-twas-j8 directory to expose a drop-down menu. Hover over watsonx Code Assistant Left click Upgrade Java Version to continue A new Upgrade panel will open as a tab alongside the Modernize panel. WCA will automatically detect that the code Source is designed for IBM Java 8 Set the Target parameter equal to Java 21 (LTS) When ready, click the Build and analyze button Similar to the Modernize steps previously, the Upgrade automation will generate a new Issues tab containing a list of potential fixes required before continuing with the Java version upgrade. Some of these tasks can be handled fully by automation; others will require some degree of manual intervention. Select the Automated fixes tab first to identify three issues that can be resolved without human intervention Click any of the recommended fixes to pull down additional information on what changes will be performed by the automation When ready, click the Run automated fixes button to perform the tasks Completion of the tasks may take several minutes to conclude To examine the Upgrade tasks requiring human intervention, click the Assisted fixes tab. Similarly to the Modernization panel, a description of the issue and detailed recommendations on how to perform the code fixes are listed within the tab Click the name of the problematic file ( src/main/java/acme/modres/mbean/DMBeanUtils.java ) to open DMBeanUtils.java for editing and modification According to WCA, there is an incompatibility with the getOps method within the DMBeanUtils.java codebase \u2014 specifically with the MBeanOperationInfo constructor that the method calls on line 28. Click the Help me button to engage a new WCA Chat session WCA will generate code recommendations within the Chat panel that can substitute the problematic legacy code Copy the full public final class DMBeanUtils {...} code recommendation from the Chat panel to a clipboard Replace the entire contents of the DMBeanUtils.java file with the recommendation from WCA Save the changes to the file ( File > Save ) There is a second optional recommendation available within the Issues tab of the Upgrade panel, but this can be safely ignored for now as it only relates to a deprecation warning. With the application's Java version now upgraded to Java 21 by a combination of automated fixes and manual interventions \u2014the application will once again need to be redeployed to reflect the changes. Return to the open VS Code Terminal Press Ctrl + C to terminate the application To re-deploy the application, return to the Upgrade panel (right hand side). Take note of the fact that all Issues previously reported by the tool have been resolved. Click the Rebuild and refresh button to re-deploy the application Wait for the Terminal to report a successful deployment Refresh the tab of the web application to inspect the modernized Liberty application Previously broken features, such as the Location module, should now be fully operable vii. Conclusion Having concluded the Application Modernization - WebSphere to Liberty hands-on modules, participants should now complete the corresponding Evaluation quiz and then continue with the remainder of the Level 4 curriculum.","title":"8. Full stack modernization"},{"location":"appmod/8/#full-stack-modernizationapplication-modernization-websphere-to-liberty","text":"","title":"Full stack modernizationApplication Modernization - WebSphere to Liberty"},{"location":"appmod/8/#i-objectives","text":"As a capstone to the experimentation and feature-exploration conducted with IBM watsonx Code Assistant ( WCA ) in the previous modules of this lab, participants will conclude the Application Modernization topic with a hands-on opportunity: modernization of a full-stack WebSphere Application Service (WAS) application into WebSphere Liberty. Participants will be tasked with: Explaining the purpose of the legacy WAS code and detailing the necessary transformations Modernizing legacy packages and libraries from WAS to Liberty Upgrading Java versions from Java 8 to Java 21 Code recommendations will be generated using WCA Chat , as in the previous modules, alongside the Modernize and Java Upgrade capabilities built into WCA Standard plans The culmination of this work will be a fully modernized and interactive web application that tangibly demonstrates the benefits of the techniques discussed throughout this lab.","title":"i. Objectives"},{"location":"appmod/8/#ii-setting-up","text":"Return to the Visual Studio Code (VS Code) application. It should already be signed in and authenticated with the WCA service on IBM Cloud \u2014 if it's not, follow the instructions in the IBM Cloud (SaaS) Configuration lab. Ensure that the Explorer tab is cleared of any previously-opened folders or files before continuing. With the VS Code Explorer tab selected and open, click File > Close Folder from the top taskbar. Additional software must be prepared within VS Code before continuing with WCA Standard Plan's enterprise capabilities for WebSphere modernization. INCOMPATIBILITY WITH JDK 24 Note that the Full stack modernization module in Application Modernization - WebSphere to Liberty will encounter compatibility errors with JDK 24 drivers when attempting to Explain or Modernize the source application. This is owing to a deprecation of sun.misc.Unsafe method as of March 2025. Additional details may be found here. As a result, participants in this lab should ensure they are running JDK 21 (or as early as JDK 11), but specifically not JDK 24. If you are running JDK 24, you should uninstall the JDK from your machine and reinstall with the links provided in Configure the enterprise Java environment . From the left-hand side of the VS Code interface, click the Extensions tab Within the Extensions: Marketplace search bar , search for Liberty Tools Click the blue Install button to the right of the Liberty Tools tile Dismiss any \"Welcome\" splash screens Once the install is complete, return to the Extensions tab again Within the Extensions: Marketplace search bar , search Extension Pack for Java Click the blue Install to the right of the Extension Pack for Java tile Wait for the install to complete and dismiss any \"Welcome\" splash screens Next, participants must download the WebSphere Application Server (WAS) assets that are to be modernized. The assets will be retrieved from the linked application repository: wca-assets-2025.zip URL: https://ibm.box.com/s/ps65ax6mupmwx3pww2b2ylvc9ed18njp Save the wca-assets-2025.zip file to your local machine and unzip the contents Open the Explorer tab from the VS Code interface Click the blue Open Folder button and select the unzipped wca-assets-2025 directory The wca-assets-2025 contents will automatically open within Explorer","title":"ii. Setting up"},{"location":"appmod/8/#iii-deploy-the-application","text":"Participants now need to build the application Project . Open a Terminal within VS Code (if you haven't already) by clicking Terminal > New Terminal from the top taskbar. Navigate using the Terminal to the folder where wca-assets-2025 was saved in Step 3 and drill down /1-java-modernization/modresorts-twas-j8/was_dependency directory Attention: Substitute the <REPLACE> placeholder with the path to your directory cd <REPLACE>/wca-assets-2025/1-java-modernization/modresorts-twas-j8/was_dependency Source the ~/.zshrc PATH and JAVA_HOME variables (set up previously in the Configure the enterprise Java environment module) by executing the following: source ~/.zshrc The necessary Maven dependencies must be prepared within the was_dependency directory before the application can be deployed. Using a Terminal, execute the following instruction: mvn install:install-file -Dfile = was_public.jar -DpomFile = was_public-9.0.0.pom WINDOWS USERS Windows users might need to provide the full path for the build files was_public.jar and was_public-9.0.0.pom , for example: mvm install:install-file -Dfile = C: \\U sers \\A dministrator.CE-APAC-WIND202 \\D ocuments \\w ca4ej-workshop \\m odresorts \\t was \\j 8 \\w as_dependency \\w as_public.jar -Dpom-File = C: \\U sers \\A dministrator.CE-APAC-WIND202 \\D ocuments \\w ca4ej-workshop \\m odresorts-twas-j8 \\w as_dependency \\w as_public-9.0.0.pom With the was_dependency folder now prepared with the necessary drivers, you are ready to build and deploy the application project into a live web application Open the Explorer tab from the left-hand side of the VS Code interface Below the list of assets belonging the modresorts-twas-j8 directory, locate and toggle the LIBERTY DASHBOARD [A] drop-down panel amongst the tabs If modresorts is not displayed, click the Add project to Liberty Dashboard [B] and press Enter when prompted to select the modresorts-twas-j8 project [C] Within the LIBERTY DASHBOARD , a modresorts app will show up under the Liberty Dashboard panel. Right click on the modresorts project name to open the drop-down menu of options Click Start to initialize the project VS Code will automatically download the necessary packages (you can trace the progress within the Terminal console) Wait until the initialization process has finished and the console has returned a Source compilation was successful message Copy and record the Web application available (default host): ... address returned by the Terminal console ( http://localhost:9080/resorts or similar) Record the value of the Liberty Debug Port to a notepad for reference later. Open a new web browser tab and visit the Web application URL recorded in Step 7. Explore and familiarize yourself with the various tabs and pages built into the legacy web application. ERRORS AND BROKEN WEB LINKS As the legacy application has been built for WebSphere Application Server (WAS) using Java 8 , but the deployment generated in Step 7 was intended for WebSphere Liberty using Java 21 , there are a number of pages within the app that will produce an \"Error\" \u2014 for example, the location information module. These will be aspects of the application that you will remedy as part of the modernization steps that follow.","title":"iii. Deploy the application"},{"location":"appmod/8/#iv-explain-the-project-code","text":"Let's better understand the entirety of the project by using the explainability features built into watsonx Code Assistant. Open the Explorer tab from the left-hand interface to view the contents of the modresorts-twas-j8 project Right-click anywhere inside the modresorts-twas-j8 workspace [A] to open a drop-down menu of options Hover over the watsonx Code Assistant option and then select Explain Application [B] When prompted, click Proceed with code analysis Wait 1-2 minutes for the analysis to complete, at which time a pop-up will appear in the bottom-right corner of VS Code stating that The explanation has been completed Click the Open explanation button within the pop-up to open and peruse the report Record the entire output of the Explain Application report to a notepad for reference later.","title":"iv. Explain the project code"},{"location":"appmod/8/#v-build-a-modernization-plan","text":"Before modernizing the WAS application into Liberty, you'll need to scope out the necessary changes and level of effort required to do so. To obtain that understanding, you will need to generate a modernization plan using IBM Cloud Transformation Advisor . For the purposes of this lab, one such plan has been prepared ahead of time and included within the modresorts-twas-j8 project folder. Open the Explore tab of VS Code and right-click anywhere inside the modresorts-twas-j8 workspace. Then hover over watsonx Code Assistant and select Modernize to Liberty . A Modernize to Liberty tab will open within the VS Code interface As the modernization plan prepared earlier by IBM Cloud Transformation Advisor has not yet been uploaded to WCA at this stage, the modernization recommendations proposed currently by the service are less granular and contextualized than they will be after uploading the migration bundle. This presents an interesting opportunity to compare the before and after impacts of the migration bundle on the WCA modernization plan. Before uploading the migration bundle , take note of the following information and record it to a notepad for reference later: how many proposed fixes are suggested for Automated Fixes , Assisted Fixes , and Self-Directed Fixes ? To supply the migration bundle, click the Return to Upload / analyze button in the top-right corner of the Modernize to Liberty panel Click the Upload migration bundle button When prompted, specify modresorts-twas-j8/migration-bundle/modresorts.ear_migrationBundle.zip as the location of the migration bundle Observe the state of the Selected files to be added to the project before making any adjustments or selections. Record these observations to a notepad for reference later. Be sure that both the server.xml and Containerfile assets are selected, then click Proceed to continue Analysis will take a few moments to complete. When ready, the Modernize panel will generate a report that identifies issues with the application that need to be fixed. Some of these can be automatically repaired, while others will require a degree of manual intervention. Under the Issues header, click the Automated fixes to pull open the list of issues that can be automated Inspect each of the automated fix suggestions, including their titles and the contents within the expandable tabs. These details should be recorded to a notepad for reference later. See more details about each by clicking the drop-down error to the right of the issue Click the Run automated fixes button at the bottom of the page to execute the automated fixes to Liberty After receiving a BUILD SUCCESS message from the console: Record details about the Estimate of time saved included in the console read-out Take note of how many Java source files were modified as a result of the automated fixes. Save this information to a notepad for reference later. View details about the fix(es) requiring a degree of manual intervention by clicking the Assisted fixes tab. Record the total number of Assisted fixes , Self-directed fixes , and Additional information suggestions to a notepad for future reference. Along the top of the tab, left-click the grey Instructions [A] panel to reveal the WCA-generated guidance on how to resolve the migration problems. In this example, the WebSphere Servlet API was superseded by a newer implementation that uses Servlet 3.0 functionality and as such a trio of packages used by the WAS app will no longer be available for use with Liberty Further down the panel, impacted file(s) in the legacy application code will be provided Click [B] the drop-down arrow to the right of the impacted file to reveal a detailed set of instructions for how to improve the code Afterwards, click [C] the name of the impacted file to inspect its source code in a new editor window: src/main/java/com/acme/modres/UpperServlet.java An editor window will open on the right side of VS Code, displaying the contents of UpperServlet.java for editing. The next set of instructions will follow along with the guidance recommended by the Modernize panel (in the center of the VS Code interface): Select [A] all of the class that uses the ResponseUtils.encodeDataString() method, beginning on Line 14 from @WebServlet(\"/resorts/upper\") and ending on Line 27 (an empty newline) Record the text (if any) that appears directly above Line 14 within the open UpperServlet.java file contents window. Save this information to a notepad for reference later. With the relevant code selected, click the Help me [B] button in the Modernize panel WCA will engage a Chat session and generate within the conversation TWO sets of code fixes that can be added to the legacy code in order to remedy the issue. Recommendation 1: The first fix will be a substitute of the lines of code for UpperServlet.java , beginning on Line 23 and ending on Line 26 . A new line will also need to be added to the import statements at the beginning of the file. // Assisted by watsonx Code Assistant import org.apache.commons.text.StringEscapeUtils ; @WebServlet ( \"/resorts/upper\" ) public class UpperServlet extends HttpServlet { private static final long serialVersionUID = 1L ; @Override protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { response . setContentType ( \"text/html\" ); String originalStr = request . getParameter ( \"input\" ); if ( originalStr == null ) { originalStr = \"\" ; } String escapedStr = StringEscapeUtils . escapeHtml4 ( originalStr ); newStr = StringEscapeUtils . escapeHtml4 ( newStr ); PrintWriter out = response . getWriter (); out . print ( \"<br/><b>capitalized input \" + newStr + \"</b>\" ); } } Recommendation 2: The second fix will be new lines of code that are to be added to the pom.xml file. < dependency > < groupId > org . apache . commons </ groupId > < artifactId > commons - text </ a > < version > 1.12.0 </ version > </ dependency > Edit the contents of UpperServlet.java by replacing the highlighted lines of code as instructed in Step 14 with the WCA-generated Recommendation 1 code. Save the changes to the file ( File > Save ). Locate the pom.xml file from the list of assets under the Explorer tab. Double-click on the filename to edit the contents Scroll down until you reach Level 58 ( </dependency> ) and place your cursor at the end of the line, then hit Enter to create a new line Beginning on the new Line 59 of the pom.xml contents, add the contents of WCA's Recommendation 2 (the second code block of Step 14 ) to the file The new lines of code should now occupy Lines 59-63 of the modified pom.xml code Ensure that the indentation lines up with other <dependency> declarations within the parent <dependencies> nesting Save the changes to the file ( File > Save ) With the application code now modified\u2014 by a combination of automated fixes and manual interventions \u2014the original deployment launched in Step 4 will need to be re-deployed. Return to the open VS Code Terminal Press Ctrl + C to terminate the application Record the message returned by the console after terminating the application. Save this information to a notebook for reference later. To re-deploy the application, return to the Modernize panel (right hand side). Take note of the fact that all Issues previously reported by the tool have been resolved. Click the Rebuild and refresh button to re-deploy the modernized application Wait for the Modernize ModResorts summary to refresh: it should now should only 1 Automated fix (optional and can be ignore) and 0 Assisted fixes are recommended Open the Explorer tab and locate the LIBERTY DASHBOARD drop-down Right click on modresorts , click Start , and wait for the console to report a successful deployment Refresh the tab of the web application to inspect the modernized Liberty application Previously broken features, such as the Logout button, should now be fully operable Click the Logout button on the redeployed ModResorts page. Wait for the page to refresh and then record the message on the page to a notepad for reference later.","title":"v. Build a modernization plan"},{"location":"appmod/8/#vi-java-version-upgrades","text":"Recall from before that the application's version of Java code was originally written for Java 8 . However, to be compliant with modern versions of Liberty, that Java code will need to be upgraded to Java 21 . With the Explorer tab active, right click on the modresorts-twas-j8 directory to expose a drop-down menu. Hover over watsonx Code Assistant Left click Upgrade Java Version to continue A new Upgrade panel will open as a tab alongside the Modernize panel. WCA will automatically detect that the code Source is designed for IBM Java 8 Set the Target parameter equal to Java 21 (LTS) When ready, click the Build and analyze button Similar to the Modernize steps previously, the Upgrade automation will generate a new Issues tab containing a list of potential fixes required before continuing with the Java version upgrade. Some of these tasks can be handled fully by automation; others will require some degree of manual intervention. Select the Automated fixes tab first to identify three issues that can be resolved without human intervention Click any of the recommended fixes to pull down additional information on what changes will be performed by the automation When ready, click the Run automated fixes button to perform the tasks Completion of the tasks may take several minutes to conclude To examine the Upgrade tasks requiring human intervention, click the Assisted fixes tab. Similarly to the Modernization panel, a description of the issue and detailed recommendations on how to perform the code fixes are listed within the tab Click the name of the problematic file ( src/main/java/acme/modres/mbean/DMBeanUtils.java ) to open DMBeanUtils.java for editing and modification According to WCA, there is an incompatibility with the getOps method within the DMBeanUtils.java codebase \u2014 specifically with the MBeanOperationInfo constructor that the method calls on line 28. Click the Help me button to engage a new WCA Chat session WCA will generate code recommendations within the Chat panel that can substitute the problematic legacy code Copy the full public final class DMBeanUtils {...} code recommendation from the Chat panel to a clipboard Replace the entire contents of the DMBeanUtils.java file with the recommendation from WCA Save the changes to the file ( File > Save ) There is a second optional recommendation available within the Issues tab of the Upgrade panel, but this can be safely ignored for now as it only relates to a deprecation warning. With the application's Java version now upgraded to Java 21 by a combination of automated fixes and manual interventions \u2014the application will once again need to be redeployed to reflect the changes. Return to the open VS Code Terminal Press Ctrl + C to terminate the application To re-deploy the application, return to the Upgrade panel (right hand side). Take note of the fact that all Issues previously reported by the tool have been resolved. Click the Rebuild and refresh button to re-deploy the application Wait for the Terminal to report a successful deployment Refresh the tab of the web application to inspect the modernized Liberty application Previously broken features, such as the Location module, should now be fully operable","title":"vi. Java version upgrades"},{"location":"appmod/8/#vii-conclusion","text":"Having concluded the Application Modernization - WebSphere to Liberty hands-on modules, participants should now complete the corresponding Evaluation quiz and then continue with the remainder of the Level 4 curriculum.","title":"vii. Conclusion"},{"location":"on-premises/1/","text":"Objectives and requirements On-Premises Installation and Deployment i. About this lab The On-Premises Installation and Deployment module provides comprehensive instructions for how to prepare, configure, and deploy a simulated on-premises cluster for IBM watsonx Code Assistant (WCA) on environments hosted by IBM Technology Zone (ITZ). By completing this module, participants will have learned and applied the skills necessary for deploying WCA on a client's on-premises infrastructure. The complete stack of technologies and services that you will deploy include: Red Hat OpenShift Container Platform v4.18 : a unified application development platform that lets clients build, modernize, and deploy applications at scale on their choice of hybrid cloud infrastructure. IBM Cloud Pak for Data v5.1.x : a set of services comprising a data fabric solution for data governance, data engineering, data analysis, and AI lifecycle tasks. IBM Software Hub v5.1 : a cloud-native solution that clients use to install, manage, and monitor IBM solutions on Red Hat OpenShift Container Platform (OCP). IBM watsonx Code Assistant v5.1 : a generative AI coding companion that provides contextually aware assistance for programming languages. Special acknowledgement and thanks to IBM colleagues Coralie Jonvel, Nelson Nunes, and Noe Samaille for adaptation of their deployment instructions for watsonx.ai on Red Hat OpenShift. GPUs NOT SUPPORTED FOR L4 ON-PREMISES DEPLOYMENTS Resource and budget constraints for IBM Technology Zone and the IBM Enablement teams means that GPUs are unavailable for the on-premises portion of the Level 4 curriculum. The NVIDIA A100 or H100 GPUs required are simply too cost-prohibitive to be made available for individual IBMers and business partners. GPUs cannot be shared in a multi-tenant access pattern for IBM watsonx Code Assistant \u2014 and, as such, at minimum two cards would need to be made available for every L4 reservation. These costs are beyond the scope of what can be supported by this training. Participants will have access to GPUs for the IBM Cloud (SaaS) portion of the Level 4 curriculum. ii. Infrastructure and resource requirements Requirements specific to the hands-on environment are outlined in the section below. Comprehensive details about the hardware requirements for x86_64 cluster services are available from IBM Software Hub documentation. Although the hands-on environment that will be provisioned in this module utilizes a templated, pre-defined ITZ infrastructure configuration, it will be useful for those enrolled to understand the resources required to reproduce a similar cluster in real-world client scenarios. This includes details about the CPU, memory, GPU, and other hardware components required to support the necessary cluster services. IBM Software Hub platform Additional details available from IBM Documentation Node Role Number of Services Minimum Available vCPU Minimum Memory Minimum Storage Control plane 3 (for high availability) 4 vCPU per node (This configuration supports up to 24 worker nodes.) 16 GB RAM per node. This configuration supports up to 24 worker nodes. No additional storage is needed for IBM Software Hub. Infra 3 (recommended) 4 vCPU per node. This configuration supports up to 27 worker nodes. 24 GB RAM per node (This configuration supports up to 27 worker nodes.) See the Red Hat OpenShift Container Platform documentation for sizing guidance. Worker (compute) 3 or more worker (compute) nodes 16 vCPU per node Minimum : 64 GB RAM per node Recommended : 128 GB RAM per node 300 GB of storage space per node for storing container images locally. If you plan to install watsonx.ai, increase the storage to 500 GB per node. Load balancer 2 load balancer nodes 2 vCPU per node 4 GB RAM per node. Add another 4 GB of RAM for access restrictions and security control. Add 100 GB of root storage for access restrictions and security control. IBM Cloud Pak Foundational Services Additional details available from IBM Documentation vCPU Memory Storage Notes 4 vCPU 5 GB RAM Reference the v4.10 hardware requirements and recommendations . Required. IBM Cloud Pak Foundational Services are installed once for each instance of IBM Software Hub on the cluster. Red Hat OpenShift Container Platform (single node) Additional details available from IBM Documentation VM Role Minimum Available vCPU Minimum Memory Minimum Storage Bastion node 4 vCPU 8 GB RAM Allocate a minimum of 500 GB of disk space. The disk can be: in the same disk as the general bastion node storage; in a separate disk on the bastion node; or on external storage. Worker (compute) 16 vCPU 64 GB RAM Allocate a minimum of 300 GB of disk space on the node for image storage. IBM watsonx Code Assistant Additional details available from IBM Documentation vCPU Memory Storage Notes Operator pods: 0.1 vCPU Operator pods: 0.256 GB RAM Persistent storage: 120 GB Minimum resources for an installation with a single replica per service Catalog pods: 0.01 vCPU Catalog pods: 0.05 GB RAM Ephemeral storage: 0.4 GB The service requires at least two GPUs Operand: 7 vCPU Operand: 25 GB RAM Image storage: Up to 107 GB with all models GPU support is limited to: NVIDIA H100 GPUs with 80 GB RAM iii. Prerequisites checklist Register for an IBM Technology Zone account Participants require access to ITZ in order to reserve an environment and complete the hands-on work. If you do not yet have an account with the ITZ, you will need to register for one . Obtain an IBM Entitlement API key Participants require an entitlement API key to proceed with the on-premises installation. In order to retrieve the key: Use your IBMid and password to log in to the Container Software Library . Click the Entitlement keys [A] tab from the navigation menu. Click Add new key [B] to generate a new entitlement key. Select Copy [C] to capture the entitlement key to the clipboard. Paste and save the entitlement key to a text file on your local machine. iv. Troubleshooting and support If you require assistance or run into issues with the hands-on lab, help is available. Environment issues: The lab environment is managed by IBM Technology Zone. Opening a support case ticket is recommended for issues related to the hands-on environment (provisioning, running, and so on.) Product questions: For questions related to IBM watsonx Code Assistant capabilities, sales opportunities, roadmap, and other such matters, open a thread on the #watsonx-code-assistant Slack channel. v. Next steps In the following module, you will provision an OpenShift Container Platform cluster via IBM Technology Zone, which will serve as the basis for the on-premises environment.","title":"1. Objectives and requirements"},{"location":"on-premises/1/#objectives-and-requirementson-premises-installation-and-deployment","text":"","title":"Objectives and requirementsOn-Premises Installation and Deployment"},{"location":"on-premises/1/#i-about-this-lab","text":"The On-Premises Installation and Deployment module provides comprehensive instructions for how to prepare, configure, and deploy a simulated on-premises cluster for IBM watsonx Code Assistant (WCA) on environments hosted by IBM Technology Zone (ITZ). By completing this module, participants will have learned and applied the skills necessary for deploying WCA on a client's on-premises infrastructure. The complete stack of technologies and services that you will deploy include: Red Hat OpenShift Container Platform v4.18 : a unified application development platform that lets clients build, modernize, and deploy applications at scale on their choice of hybrid cloud infrastructure. IBM Cloud Pak for Data v5.1.x : a set of services comprising a data fabric solution for data governance, data engineering, data analysis, and AI lifecycle tasks. IBM Software Hub v5.1 : a cloud-native solution that clients use to install, manage, and monitor IBM solutions on Red Hat OpenShift Container Platform (OCP). IBM watsonx Code Assistant v5.1 : a generative AI coding companion that provides contextually aware assistance for programming languages. Special acknowledgement and thanks to IBM colleagues Coralie Jonvel, Nelson Nunes, and Noe Samaille for adaptation of their deployment instructions for watsonx.ai on Red Hat OpenShift. GPUs NOT SUPPORTED FOR L4 ON-PREMISES DEPLOYMENTS Resource and budget constraints for IBM Technology Zone and the IBM Enablement teams means that GPUs are unavailable for the on-premises portion of the Level 4 curriculum. The NVIDIA A100 or H100 GPUs required are simply too cost-prohibitive to be made available for individual IBMers and business partners. GPUs cannot be shared in a multi-tenant access pattern for IBM watsonx Code Assistant \u2014 and, as such, at minimum two cards would need to be made available for every L4 reservation. These costs are beyond the scope of what can be supported by this training. Participants will have access to GPUs for the IBM Cloud (SaaS) portion of the Level 4 curriculum.","title":"i. About this lab"},{"location":"on-premises/1/#ii-infrastructure-and-resource-requirements","text":"Requirements specific to the hands-on environment are outlined in the section below. Comprehensive details about the hardware requirements for x86_64 cluster services are available from IBM Software Hub documentation. Although the hands-on environment that will be provisioned in this module utilizes a templated, pre-defined ITZ infrastructure configuration, it will be useful for those enrolled to understand the resources required to reproduce a similar cluster in real-world client scenarios. This includes details about the CPU, memory, GPU, and other hardware components required to support the necessary cluster services. IBM Software Hub platform Additional details available from IBM Documentation Node Role Number of Services Minimum Available vCPU Minimum Memory Minimum Storage Control plane 3 (for high availability) 4 vCPU per node (This configuration supports up to 24 worker nodes.) 16 GB RAM per node. This configuration supports up to 24 worker nodes. No additional storage is needed for IBM Software Hub. Infra 3 (recommended) 4 vCPU per node. This configuration supports up to 27 worker nodes. 24 GB RAM per node (This configuration supports up to 27 worker nodes.) See the Red Hat OpenShift Container Platform documentation for sizing guidance. Worker (compute) 3 or more worker (compute) nodes 16 vCPU per node Minimum : 64 GB RAM per node Recommended : 128 GB RAM per node 300 GB of storage space per node for storing container images locally. If you plan to install watsonx.ai, increase the storage to 500 GB per node. Load balancer 2 load balancer nodes 2 vCPU per node 4 GB RAM per node. Add another 4 GB of RAM for access restrictions and security control. Add 100 GB of root storage for access restrictions and security control. IBM Cloud Pak Foundational Services Additional details available from IBM Documentation vCPU Memory Storage Notes 4 vCPU 5 GB RAM Reference the v4.10 hardware requirements and recommendations . Required. IBM Cloud Pak Foundational Services are installed once for each instance of IBM Software Hub on the cluster. Red Hat OpenShift Container Platform (single node) Additional details available from IBM Documentation VM Role Minimum Available vCPU Minimum Memory Minimum Storage Bastion node 4 vCPU 8 GB RAM Allocate a minimum of 500 GB of disk space. The disk can be: in the same disk as the general bastion node storage; in a separate disk on the bastion node; or on external storage. Worker (compute) 16 vCPU 64 GB RAM Allocate a minimum of 300 GB of disk space on the node for image storage. IBM watsonx Code Assistant Additional details available from IBM Documentation vCPU Memory Storage Notes Operator pods: 0.1 vCPU Operator pods: 0.256 GB RAM Persistent storage: 120 GB Minimum resources for an installation with a single replica per service Catalog pods: 0.01 vCPU Catalog pods: 0.05 GB RAM Ephemeral storage: 0.4 GB The service requires at least two GPUs Operand: 7 vCPU Operand: 25 GB RAM Image storage: Up to 107 GB with all models GPU support is limited to: NVIDIA H100 GPUs with 80 GB RAM","title":"ii. Infrastructure and resource requirements"},{"location":"on-premises/1/#iii-prerequisites-checklist","text":"Register for an IBM Technology Zone account Participants require access to ITZ in order to reserve an environment and complete the hands-on work. If you do not yet have an account with the ITZ, you will need to register for one . Obtain an IBM Entitlement API key Participants require an entitlement API key to proceed with the on-premises installation. In order to retrieve the key: Use your IBMid and password to log in to the Container Software Library . Click the Entitlement keys [A] tab from the navigation menu. Click Add new key [B] to generate a new entitlement key. Select Copy [C] to capture the entitlement key to the clipboard. Paste and save the entitlement key to a text file on your local machine.","title":"iii. Prerequisites checklist"},{"location":"on-premises/1/#iv-troubleshooting-and-support","text":"If you require assistance or run into issues with the hands-on lab, help is available. Environment issues: The lab environment is managed by IBM Technology Zone. Opening a support case ticket is recommended for issues related to the hands-on environment (provisioning, running, and so on.) Product questions: For questions related to IBM watsonx Code Assistant capabilities, sales opportunities, roadmap, and other such matters, open a thread on the #watsonx-code-assistant Slack channel.","title":"iv. Troubleshooting and support"},{"location":"on-premises/1/#v-next-steps","text":"In the following module, you will provision an OpenShift Container Platform cluster via IBM Technology Zone, which will serve as the basis for the on-premises environment.","title":"v. Next steps"},{"location":"on-premises/2/","text":"Reserve an environment On-Premises Installation and Deployment i. Configuring the IBM Technology Zone reservation The foundation for the on-premises environment utilizes the OpenShift Cluster (VMware on IBM Cloud) - UPI - Public template from the collection of IBM Technology Zone (ITZ) Certified Base Images . Click the link below to request a reservation directly from ITZ: URL: https://techzone.ibm.com/my/reservations/create/63a3a25a3a4689001740dbb3 From the Single environment reservation options , select Reserve now [A] . Supply additional details about the ITZ reservation request: RESERVATON POLICY NOTICE After selecting Education for the Purpose field, you may receive a pop-up notification stating that this environment is now being redirected to the OCP base image hosted On-Prem for Education and Test . You can safely ignore this notice and close it by clicking the X in the top-right corner. Do not configure using the Poughkeepsie-based resource that the notice attempts to redirect you to \u2014 it will not allow you to configure the necessary hardware specifications. Continue with the ITZ reservation request form as detailed below. If the pop-up appears again later in the configuration steps, continue to disregard the notice. Field Value Name Give the reservation a unique name. Purpose Education Purpose Description Give the reservation a unique description. Preferred Geography Select the region and data center geographically closest to your location. End Date and Time Select a time and date for when the reservation will expire. OpenShift Version 4.16 Worker Node Count 3 Worker Node Flavor 32 vCPU x 128 GB - 300 GB ephemeral storage Storage ODF - 2 TB OCP/Kubernetes Cluster Network 10.128.0.0/14 OCP/Kubernetes Service Network 172.30.0.0/16 Enable nested hardware virtualization on workers No When satisfied, verify that you agree to the Terms and Conditions for the environment and finalize your reservation request by clicking Submit . Navigate to the My Reservations tab of the ITZ to monitor the progress of your reservation. While \"Provisioning\" [A] , the reservation will be marked with a yellow tile. Wait for the ITZ reservation to be marked as \"Ready\" [B] before continuing. PROVISIONING TIMES This operation will take approximately 90 - 120 minutes to complete. ii. Accessing the cluster Once the cluster has been successfully deployed, you will receive an email with the header: Reservation Ready on IBM Technology Zone . Confirm that the ITZ email states that Status Update: Ready [A] . Follow the link provided in the email, or access the My Reservations tab on ITZ to access your reservation. Scroll down the page until you reach the Reservation Details section. Record the following connection details for the OpenShift Container Platform (OCP) cluster to a notepad: Desktop URL (interchangeable with OCP Dashboard URL ) [A] Cluster Admin Username [B] Cluster Admin Password [C] API URL [D] Bastion Username [E] Bastion Password [F] Bastion SSH Connection [G] Click the blue Open your IBM Cloud environment button at the top of the page to launch a new browser window for accessing the OCP cluster. Choose the kube:admin log in option and then provide the following credentials: Username: kubeadmin Password: Cluster Admin Password recorded in Step 6 At this stage, you should have successfully logged in to the OCP Dashboard. iii. Next steps In the following module, you will access and configure the cluster's bastion node.","title":"2. Reserve an environment"},{"location":"on-premises/2/#reserve-an-environmenton-premises-installation-and-deployment","text":"","title":"Reserve an environmentOn-Premises Installation and Deployment"},{"location":"on-premises/2/#i-configuring-the-ibm-technology-zone-reservation","text":"The foundation for the on-premises environment utilizes the OpenShift Cluster (VMware on IBM Cloud) - UPI - Public template from the collection of IBM Technology Zone (ITZ) Certified Base Images . Click the link below to request a reservation directly from ITZ: URL: https://techzone.ibm.com/my/reservations/create/63a3a25a3a4689001740dbb3 From the Single environment reservation options , select Reserve now [A] . Supply additional details about the ITZ reservation request: RESERVATON POLICY NOTICE After selecting Education for the Purpose field, you may receive a pop-up notification stating that this environment is now being redirected to the OCP base image hosted On-Prem for Education and Test . You can safely ignore this notice and close it by clicking the X in the top-right corner. Do not configure using the Poughkeepsie-based resource that the notice attempts to redirect you to \u2014 it will not allow you to configure the necessary hardware specifications. Continue with the ITZ reservation request form as detailed below. If the pop-up appears again later in the configuration steps, continue to disregard the notice. Field Value Name Give the reservation a unique name. Purpose Education Purpose Description Give the reservation a unique description. Preferred Geography Select the region and data center geographically closest to your location. End Date and Time Select a time and date for when the reservation will expire. OpenShift Version 4.16 Worker Node Count 3 Worker Node Flavor 32 vCPU x 128 GB - 300 GB ephemeral storage Storage ODF - 2 TB OCP/Kubernetes Cluster Network 10.128.0.0/14 OCP/Kubernetes Service Network 172.30.0.0/16 Enable nested hardware virtualization on workers No When satisfied, verify that you agree to the Terms and Conditions for the environment and finalize your reservation request by clicking Submit . Navigate to the My Reservations tab of the ITZ to monitor the progress of your reservation. While \"Provisioning\" [A] , the reservation will be marked with a yellow tile. Wait for the ITZ reservation to be marked as \"Ready\" [B] before continuing. PROVISIONING TIMES This operation will take approximately 90 - 120 minutes to complete.","title":"i. Configuring the IBM Technology Zone reservation"},{"location":"on-premises/2/#ii-accessing-the-cluster","text":"Once the cluster has been successfully deployed, you will receive an email with the header: Reservation Ready on IBM Technology Zone . Confirm that the ITZ email states that Status Update: Ready [A] . Follow the link provided in the email, or access the My Reservations tab on ITZ to access your reservation. Scroll down the page until you reach the Reservation Details section. Record the following connection details for the OpenShift Container Platform (OCP) cluster to a notepad: Desktop URL (interchangeable with OCP Dashboard URL ) [A] Cluster Admin Username [B] Cluster Admin Password [C] API URL [D] Bastion Username [E] Bastion Password [F] Bastion SSH Connection [G] Click the blue Open your IBM Cloud environment button at the top of the page to launch a new browser window for accessing the OCP cluster. Choose the kube:admin log in option and then provide the following credentials: Username: kubeadmin Password: Cluster Admin Password recorded in Step 6 At this stage, you should have successfully logged in to the OCP Dashboard.","title":"ii. Accessing the cluster"},{"location":"on-premises/2/#_1","text":"","title":""},{"location":"on-premises/2/#iii-next-steps","text":"In the following module, you will access and configure the cluster's bastion node.","title":"iii. Next steps"},{"location":"on-premises/3/","text":"Bastion host setup On-Premises Installation and Deployment The following section is based off of IBM Documentation detailing how to install IBM Software Hub on a Red Hat OpenShift Container Platform cluster. Reference the instructions in full at the following resource: Installing the IBM Software Hub command-line interface . i. Connect to the bastion host To access and configure the bastion host node, open a Terminal (Windows Terminal or the Terminal built into VS Code are good alternatives if you're on a PC). Copy the Bastion SSH Connection recorded in Step 6 of the previous module and paste it into the terminal console. Hit Enter to create an SSH connection to the bastion host. When prompted Are you sure you want to continue connecting (yes/no/fingerprint)? , enter yes and hit Enter to proceed. The console will return a Welcome to IBM Technology Zone once connected to the bastion host, at which point you must authenticate. Authenticate when prompted to do so by providing the Bastion Password . If the console now reads [itzuser@localhost ~]$ then you have successfully accessed the bastion host. ii. OpenShift command line interface (oc) Next, install the OpenShift Command Line Interface (CLI), designated oc , to programmatically perform work with the bastion node. ELEVATED PERMISSIONS Execute the following command in the Terminal console to ensure that subsequent actions taken via the Terminal console are done with elevated permissions. This will save you needing to re-authenticate again for future commands. sudo bash Retrieve the OCP Dashboard URL (recorded in Step 6 of the previous module). Obtain the OpenShift Base Domain by extracting the portion of the URL that matches the position highlighted in the sample URL below. Extract the characters following .apps. up to and including .com . Do not include the /dashboards addendum. https://console-openshift-console.apps. 678a250b79141644e78804e0.ocp.techzone.ibm.com In this example, the value of the OpenShift base domain is 678a250b79141644e78804e0.ocp.techzone.ibm.com Record your OCP cluster's value to a notepad for future reference. The following instruction set, when executed within a Terminal window, will install the OpenShift CLI on the bastion host node. However, the instructions require some modification before they will successfully execute. Install OpenShift CLI export OPENSHIFT_BASE_DOMAIN = <CHANGE_ME> wget --no-check-certificate https://downloads-openshift-console.apps. ${ OPENSHIFT_BASE_DOMAIN } /amd64/linux/oc.tar tar -xvf oc.tar chmod +x oc sudo mv oc /usr/local/bin/oc Copy the instructions above and paste into a notepad. Replace the highlighted <CHANGE_ME> text with the OpenShift base domain value recorded in Step 2. Copy the modified notepad instructions to your clipboard and paste into your Terminal console. Press Enter to execute the instructions. The setup should only take a moment to complete. Once finished, try typing oc into the console window and hit Enter . The console output should verify that oc (the OpenShift CLI) has been successfully installed on the bastion host. iii. Podman install IBM Cloud Pak for Data (CP4D)'s installer requires containers, for which you will need to install Podman on the cluster nodes via the bastion host. Using the connected Terminal console, execute the following instruction to install Podman: sudo yum install -y podman The operation will take approximately 2 minutes to complete. After a successful operation, the console will return the message Complete! alongside a summary of the installed components. iv. Environment variables Set the environment variables needed for installation of CP4D on the cluster. The list is quite extensive and long, so rather than set these one at a time it's recommended that you first compile them into a single file on the bastion host. Afterwards, you can set all the variables automatically using the single file. Below is a code block containing all of the necessary CP4D environment variables. Copy the contents of the entire block to your clipboard and paste into a notepad. CP4D Environment Variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #=============================================================================== # Cloud Pak for Data installation variables #=============================================================================== #------------------------------------------------------------------------------ # Client workstation #------------------------------------------------------------------------------ # Set the following variables if you want to override the default behavior of the Cloud Pak for Data CLI. # # To export these variables, you must uncomment each command in this section. #export CPD_CLI_MANAGE_WORKSPACE=<enter a fully qualified directory> # following lines could be used for environment with self-signed certificates and hostnames not resolved by DNS server #export OLM_UTILS_LAUNCH_ARGS=\"-v ./api-wxai.pem:/etc/k8scert --env K8S_AUTH_SSL_CA_CERT=/etc/k8scert --add-host oauth-openshift.apps.ocpinstall.gym.lan:192.168.252.4 --add-host api.ocpinstall.gym.lan:192.168.252.3\" export PATH = \"/home/itzuser/cpd-cli-linux-EE-14.1.0-1189\" : $PATH #----------------------------------------------------------------------------- # Cluster #------------------------------------------------------------------------------ export OCP_URL = api.<REPLACE THIS VALUE>:6443 #export OPENSHIFT_TYPE=<enter your deployment type> #export IMAGE_ARCH=amd64 export OCP_USERNAME = kubeadmin export OCP_PASSWORD = <REPLACE THIS VALUE> # export OCP_TOKEN=<enter your token> export SERVER_ARGUMENTS = \"--server= ${ OCP_URL } \" export LOGIN_ARGUMENTS = \"--username= ${ OCP_USERNAME } --password= ${ OCP_PASSWORD } \" # export LOGIN_ARGUMENTS=\"--token=${OCP_TOKEN}\" export CPDM_OC_LOGIN = \"cpd-cli manage login-to-ocp ${ SERVER_ARGUMENTS } ${ LOGIN_ARGUMENTS } \" export OC_LOGIN = \"oc login ${ OCP_URL } ${ LOGIN_ARGUMENTS } \" #------------------------------------------------------------------------------ # Projects #------------------------------------------------------------------------------ export PROJECT_LICENSE_SERVICE = cpd-license export PROJECT_SCHEDULING_SERVICE = cpd-scheduling export PROJECT_CPD_INST_OPERATORS = cpd-operators export PROJECT_CPD_INST_OPERANDS = cpd-watsonx # export PROJECT_CPD_INSTANCE_TETHERED=<enter your tethered project> # export PROJECT_CPD_INSTANCE_TETHERED_LIST=<a comma-separated list of tethered projects> #------------------------------------------------------------------------------ # Storage #------------------------------------------------------------------------------ export STG_CLASS_BLOCK = ocs-storagecluster-ceph-rbd export STG_CLASS_FILE = ocs-storagecluster-cephfs #------------------------------------------------------------------------------ # IBM Entitled Registry #------------------------------------------------------------------------------ export IBM_ENTITLEMENT_KEY = <REPLACE THIS VALUE> #------------------------------------------------------------------------------ # Cloud Pak for Data version #------------------------------------------------------------------------------ export VERSION = 5 .1.0 #------------------------------------------------------------------------------ # Components #------------------------------------------------------------------------------ #export COMPONENTS=ibm-cert-manager,ibm-licensing,scheduler,cpfs,cpd_plat-form # export COMPONENTS_TO_SKIP=<component-ID-1>,<component-ID-2> #export COMPONENTS=ibm-cert-manager,ibm-licensing,cpfs,scheduler,cpd_plat-form,wml,ws,watsonx_ai export COMPONENTS = cpd_platform,wca You must make modifications to Line 19 , Line 23 , and Line 49 of the CP4D Environment Variables to tailor the variables to your specific cluster. Line 19: substitute the <REPLACE THIS VALUE> placeholder for export OCP_URL= with to the value of OpenShift Base Domain that was recorded in Step 2. Do not replace the .api. or :6443: components , as these are required. Your modified Line 19 should resemble the following: export OCP_URL = api.678a250b79141644e78804e0.ocp.techzone.ibm.com:6443 Line 23: set the value of export OCP_PASSWORD= equal to the value of Cluster Admin Password recorded in Step 6 of the previous module. For example: export OCP_PASSWORD = password1234 Line 49: set the value of export IBM_ENTITLEMENT_KEY= equal to the value of the key specific to your IBM account. Reference the IBM Entitlement API Key that was generated in the iii. Prerequisites checklist section of Module 1 (Objectives and Requirements) . Instructions for how to generate an IBM Entitlement API Key are provided in that section. For example: export IBM_ENTITLEMENT_KEY = verylongAPIkey1234 With a Terminal console, execute the following instruction to open the vi editor (or a different editor of your choosing) and create a shell script named cpd_vars.sh on the bastion host: vi cpd_vars.sh Copy the modified CP4D Environment Variables contents from the notepad (Step 7) to your machine's clipboard. Switch back to the Terminal where the VI editor is now open and press the I key to enable inserting text. Press Cmd + V (or Ctrl + V ) to paste the contents from your clipboard. To save, press Esc and then type :wq followed by Enter to write the file and exit the editor. v. Cloud Pak for Data command line interface (cpd-cli) Now that the environment variables have been set, the next step towards installing CP4D is preparing the command line interface ( cpd-cli ). Copy the following code block and execute it within the console to install cpd-cli : wget https://github.com/IBM/cpd-cli/releases/download/v14.1.0/cpd-cli-linux-EE-14.1.0.tgz tar -xzf cpd-cli-linux-EE-14.1.0.tgz export PATH = \" $( pwd ) /cpd-cli-linux-EE-14.1.0-1189\" : $PATH The operation will take approximately 1 minute to complete. Verify that the CLI has been successfully integrated with the following command: cpd-cli The output from the console should resemble the screenshot below. Verify the status of the restarted container by typing podman ps and Enter , which should return the result of a single container running on the bastion host. echo $PATH cpd-cli manage restart-container The operation will take approximately 1 minute to complete. After a successful operation, the console will return a pair of messages that resemble the following: [ SUCCESS ] 2025 -03-19T17:51:35.317974Z Successfully started the container <container_name> [ SUCCESS ] 2025 -03-19T17:51:35.318017Z Container <container_name> has been re-created Record the name of the restarted container to a notepad for reference later. Source the newly-configured environment variables with the following command: source cpd_vars.sh Test that the login for oc command line is now functioning properly: oc login ${ OCP_URL } ${ LOGIN_ARGUMENTS } The command line should return back with a prompt describing You have access to ... projects which indicates that oc and the environment variables have been configured. vi. Next steps At this stage the bastion host node has been fully configured ahead of installing the necessary software, which will be covered in the subsequent modules. TROUBLESHOOTING: LOGGING IN AND SESSION TIMEOUTS Be aware that SSH connections made over Terminal will time out after a long period of inactivity or due to a connection error. If you need to log back into the bastion terminal, follow the procedure below. Replace the <BASTION_PWD> placeholder with the password specific to your environment. Log back into the bastion node: ssh itzuser@api.67828ca5e432cac47ccc4230.ocp.techzone.ibm.com -p 40222 <BASTION_PWD> Engage the sudo (privileged access) session: sudo bash Source the environment variables stored in cpd_vars.sh : source cpd_vars.sh Log back into OpenShift: ${ OC_LOGIN } Log back into cpd-cli : ${ CPDM_OC_LOGIN }","title":"3. Bastion host setup"},{"location":"on-premises/3/#bastion-host-setupon-premises-installation-and-deployment","text":"The following section is based off of IBM Documentation detailing how to install IBM Software Hub on a Red Hat OpenShift Container Platform cluster. Reference the instructions in full at the following resource: Installing the IBM Software Hub command-line interface .","title":"Bastion host setupOn-Premises Installation and Deployment"},{"location":"on-premises/3/#i-connect-to-the-bastion-host","text":"To access and configure the bastion host node, open a Terminal (Windows Terminal or the Terminal built into VS Code are good alternatives if you're on a PC). Copy the Bastion SSH Connection recorded in Step 6 of the previous module and paste it into the terminal console. Hit Enter to create an SSH connection to the bastion host. When prompted Are you sure you want to continue connecting (yes/no/fingerprint)? , enter yes and hit Enter to proceed. The console will return a Welcome to IBM Technology Zone once connected to the bastion host, at which point you must authenticate. Authenticate when prompted to do so by providing the Bastion Password . If the console now reads [itzuser@localhost ~]$ then you have successfully accessed the bastion host.","title":"i. Connect to the bastion host"},{"location":"on-premises/3/#ii-openshift-command-line-interface-oc","text":"Next, install the OpenShift Command Line Interface (CLI), designated oc , to programmatically perform work with the bastion node. ELEVATED PERMISSIONS Execute the following command in the Terminal console to ensure that subsequent actions taken via the Terminal console are done with elevated permissions. This will save you needing to re-authenticate again for future commands. sudo bash Retrieve the OCP Dashboard URL (recorded in Step 6 of the previous module). Obtain the OpenShift Base Domain by extracting the portion of the URL that matches the position highlighted in the sample URL below. Extract the characters following .apps. up to and including .com . Do not include the /dashboards addendum. https://console-openshift-console.apps. 678a250b79141644e78804e0.ocp.techzone.ibm.com In this example, the value of the OpenShift base domain is 678a250b79141644e78804e0.ocp.techzone.ibm.com Record your OCP cluster's value to a notepad for future reference. The following instruction set, when executed within a Terminal window, will install the OpenShift CLI on the bastion host node. However, the instructions require some modification before they will successfully execute. Install OpenShift CLI export OPENSHIFT_BASE_DOMAIN = <CHANGE_ME> wget --no-check-certificate https://downloads-openshift-console.apps. ${ OPENSHIFT_BASE_DOMAIN } /amd64/linux/oc.tar tar -xvf oc.tar chmod +x oc sudo mv oc /usr/local/bin/oc Copy the instructions above and paste into a notepad. Replace the highlighted <CHANGE_ME> text with the OpenShift base domain value recorded in Step 2. Copy the modified notepad instructions to your clipboard and paste into your Terminal console. Press Enter to execute the instructions. The setup should only take a moment to complete. Once finished, try typing oc into the console window and hit Enter . The console output should verify that oc (the OpenShift CLI) has been successfully installed on the bastion host.","title":"ii. OpenShift command line interface (oc)"},{"location":"on-premises/3/#iii-podman-install","text":"IBM Cloud Pak for Data (CP4D)'s installer requires containers, for which you will need to install Podman on the cluster nodes via the bastion host. Using the connected Terminal console, execute the following instruction to install Podman: sudo yum install -y podman The operation will take approximately 2 minutes to complete. After a successful operation, the console will return the message Complete! alongside a summary of the installed components.","title":"iii. Podman install"},{"location":"on-premises/3/#iv-environment-variables","text":"Set the environment variables needed for installation of CP4D on the cluster. The list is quite extensive and long, so rather than set these one at a time it's recommended that you first compile them into a single file on the bastion host. Afterwards, you can set all the variables automatically using the single file. Below is a code block containing all of the necessary CP4D environment variables. Copy the contents of the entire block to your clipboard and paste into a notepad. CP4D Environment Variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #=============================================================================== # Cloud Pak for Data installation variables #=============================================================================== #------------------------------------------------------------------------------ # Client workstation #------------------------------------------------------------------------------ # Set the following variables if you want to override the default behavior of the Cloud Pak for Data CLI. # # To export these variables, you must uncomment each command in this section. #export CPD_CLI_MANAGE_WORKSPACE=<enter a fully qualified directory> # following lines could be used for environment with self-signed certificates and hostnames not resolved by DNS server #export OLM_UTILS_LAUNCH_ARGS=\"-v ./api-wxai.pem:/etc/k8scert --env K8S_AUTH_SSL_CA_CERT=/etc/k8scert --add-host oauth-openshift.apps.ocpinstall.gym.lan:192.168.252.4 --add-host api.ocpinstall.gym.lan:192.168.252.3\" export PATH = \"/home/itzuser/cpd-cli-linux-EE-14.1.0-1189\" : $PATH #----------------------------------------------------------------------------- # Cluster #------------------------------------------------------------------------------ export OCP_URL = api.<REPLACE THIS VALUE>:6443 #export OPENSHIFT_TYPE=<enter your deployment type> #export IMAGE_ARCH=amd64 export OCP_USERNAME = kubeadmin export OCP_PASSWORD = <REPLACE THIS VALUE> # export OCP_TOKEN=<enter your token> export SERVER_ARGUMENTS = \"--server= ${ OCP_URL } \" export LOGIN_ARGUMENTS = \"--username= ${ OCP_USERNAME } --password= ${ OCP_PASSWORD } \" # export LOGIN_ARGUMENTS=\"--token=${OCP_TOKEN}\" export CPDM_OC_LOGIN = \"cpd-cli manage login-to-ocp ${ SERVER_ARGUMENTS } ${ LOGIN_ARGUMENTS } \" export OC_LOGIN = \"oc login ${ OCP_URL } ${ LOGIN_ARGUMENTS } \" #------------------------------------------------------------------------------ # Projects #------------------------------------------------------------------------------ export PROJECT_LICENSE_SERVICE = cpd-license export PROJECT_SCHEDULING_SERVICE = cpd-scheduling export PROJECT_CPD_INST_OPERATORS = cpd-operators export PROJECT_CPD_INST_OPERANDS = cpd-watsonx # export PROJECT_CPD_INSTANCE_TETHERED=<enter your tethered project> # export PROJECT_CPD_INSTANCE_TETHERED_LIST=<a comma-separated list of tethered projects> #------------------------------------------------------------------------------ # Storage #------------------------------------------------------------------------------ export STG_CLASS_BLOCK = ocs-storagecluster-ceph-rbd export STG_CLASS_FILE = ocs-storagecluster-cephfs #------------------------------------------------------------------------------ # IBM Entitled Registry #------------------------------------------------------------------------------ export IBM_ENTITLEMENT_KEY = <REPLACE THIS VALUE> #------------------------------------------------------------------------------ # Cloud Pak for Data version #------------------------------------------------------------------------------ export VERSION = 5 .1.0 #------------------------------------------------------------------------------ # Components #------------------------------------------------------------------------------ #export COMPONENTS=ibm-cert-manager,ibm-licensing,scheduler,cpfs,cpd_plat-form # export COMPONENTS_TO_SKIP=<component-ID-1>,<component-ID-2> #export COMPONENTS=ibm-cert-manager,ibm-licensing,cpfs,scheduler,cpd_plat-form,wml,ws,watsonx_ai export COMPONENTS = cpd_platform,wca You must make modifications to Line 19 , Line 23 , and Line 49 of the CP4D Environment Variables to tailor the variables to your specific cluster. Line 19: substitute the <REPLACE THIS VALUE> placeholder for export OCP_URL= with to the value of OpenShift Base Domain that was recorded in Step 2. Do not replace the .api. or :6443: components , as these are required. Your modified Line 19 should resemble the following: export OCP_URL = api.678a250b79141644e78804e0.ocp.techzone.ibm.com:6443 Line 23: set the value of export OCP_PASSWORD= equal to the value of Cluster Admin Password recorded in Step 6 of the previous module. For example: export OCP_PASSWORD = password1234 Line 49: set the value of export IBM_ENTITLEMENT_KEY= equal to the value of the key specific to your IBM account. Reference the IBM Entitlement API Key that was generated in the iii. Prerequisites checklist section of Module 1 (Objectives and Requirements) . Instructions for how to generate an IBM Entitlement API Key are provided in that section. For example: export IBM_ENTITLEMENT_KEY = verylongAPIkey1234 With a Terminal console, execute the following instruction to open the vi editor (or a different editor of your choosing) and create a shell script named cpd_vars.sh on the bastion host: vi cpd_vars.sh Copy the modified CP4D Environment Variables contents from the notepad (Step 7) to your machine's clipboard. Switch back to the Terminal where the VI editor is now open and press the I key to enable inserting text. Press Cmd + V (or Ctrl + V ) to paste the contents from your clipboard. To save, press Esc and then type :wq followed by Enter to write the file and exit the editor.","title":"iv. Environment variables"},{"location":"on-premises/3/#v-cloud-pak-for-data-command-line-interface-cpd-cli","text":"Now that the environment variables have been set, the next step towards installing CP4D is preparing the command line interface ( cpd-cli ). Copy the following code block and execute it within the console to install cpd-cli : wget https://github.com/IBM/cpd-cli/releases/download/v14.1.0/cpd-cli-linux-EE-14.1.0.tgz tar -xzf cpd-cli-linux-EE-14.1.0.tgz export PATH = \" $( pwd ) /cpd-cli-linux-EE-14.1.0-1189\" : $PATH The operation will take approximately 1 minute to complete. Verify that the CLI has been successfully integrated with the following command: cpd-cli The output from the console should resemble the screenshot below. Verify the status of the restarted container by typing podman ps and Enter , which should return the result of a single container running on the bastion host. echo $PATH cpd-cli manage restart-container The operation will take approximately 1 minute to complete. After a successful operation, the console will return a pair of messages that resemble the following: [ SUCCESS ] 2025 -03-19T17:51:35.317974Z Successfully started the container <container_name> [ SUCCESS ] 2025 -03-19T17:51:35.318017Z Container <container_name> has been re-created Record the name of the restarted container to a notepad for reference later. Source the newly-configured environment variables with the following command: source cpd_vars.sh Test that the login for oc command line is now functioning properly: oc login ${ OCP_URL } ${ LOGIN_ARGUMENTS } The command line should return back with a prompt describing You have access to ... projects which indicates that oc and the environment variables have been configured.","title":"v. Cloud Pak for Data command line interface (cpd-cli)"},{"location":"on-premises/3/#vi-next-steps","text":"At this stage the bastion host node has been fully configured ahead of installing the necessary software, which will be covered in the subsequent modules. TROUBLESHOOTING: LOGGING IN AND SESSION TIMEOUTS Be aware that SSH connections made over Terminal will time out after a long period of inactivity or due to a connection error. If you need to log back into the bastion terminal, follow the procedure below. Replace the <BASTION_PWD> placeholder with the password specific to your environment. Log back into the bastion node: ssh itzuser@api.67828ca5e432cac47ccc4230.ocp.techzone.ibm.com -p 40222 <BASTION_PWD> Engage the sudo (privileged access) session: sudo bash Source the environment variables stored in cpd_vars.sh : source cpd_vars.sh Log back into OpenShift: ${ OC_LOGIN } Log back into cpd-cli : ${ CPDM_OC_LOGIN }","title":"vi. Next steps"},{"location":"on-premises/4/","text":"Cluster preparation On-Premises Installation and Deployment The following section is based off of IBM Documentation for preparing an OpenShift cluster for IBM Cloud Pak for Data. Reference the instructions in full at the following resource: Preparing Your Cluster for IBM Software Hub . i. Change process IDs limit With a newly installed cluster, a KubeletConfig will need to be manually created before the cluster's process IDs can be modified. This file will define the podPidsLimit and maxPods variables for the environment. Copy the contents of the following code block and then execute within your Terminal console to generate a new KubeletConfig file: oc apply -f - << EOF apiVersion: machineconfiguration.openshift.io/v1 kind: KubeletConfig metadata: name: cpd-watsonx-kubeletconfig spec: kubeletConfig: podPidsLimit: 16384 podsPerCore: 0 maxPods: 500 machineConfigPoolSelector: matchExpressions: - key: pools.operator.machineconfiguration.openshift.io/worker operator: Exists EOF KUBELETCONFIG TEST You can test whether a KubeletConfig file exists on the system by executing the following command: oc get kubeletconfig Record the output returned by the console and save this information to a notepad for reference later. Use the CP4D command line ( cpd-cli ) to log into OCP by executing the following code: cpd-cli manage login-to-ocp \\ --username = ${ OCP_USERNAME } \\ --password = ${ OCP_PASSWORD } \\ --server = ${ OCP_URL } The operation will take approximately 1 minute to complete. After a successful run, the console should return a pair of messages that resemble the following: [ SUCCESS ] 2025 -03-19T18:04:23.978349Z You may find output and logs in the /home/itzuser/cpd-cli-workspace/olm-utils-workspace/work directory. [ SUCCESS ] 2025 -03-19T18:04:23.978412Z The login-to-ocp command ran successfully. ii. Update the cluster's global pull secret Use cpd-cli to manage the creation or updating of the global image pull secret via the add-icr-cred-to-global-pull-secret command. Execute the following command within the Terminal console: cpd-cli manage add-icr-cred-to-global-pull-secret --entitled_registry_key = ${ IBM_ENTITLEMENT_KEY } The console will return two [SUCCESS] statements indicating a successful run. Now you must update all nodes across the cluster using OpenShift command line ( oc ). Execute the following instructions via the Terminal console: oc login ${ OCP_URL } --username = ${ OCP_USERNAME } --password = ${ OCP_PASSWORD } oc get mcp Once completed, execute the following statement to check the status of the cluster nodes (this can be performed periodically to track the progress of the node updates): cpd-cli manage oc get nodes Wait until the STATUS returns for all nodes (3 master nodes, 3 storage nodes, and 3 worker nodes) all report as Ready . iii. Next steps In the following module, you will install the necessary prerequisite software required to deploy IBM Cloud Pak for Data and IBM watsonx Code Assistant. TROUBLESHOOTING: LOGGING IN AND SESSION TIMEOUTS Be aware that SSH connections made over Terminal will time out after a long period of inactivity or due to a connection error. If you need to log back into the bastion terminal, follow the procedure below. Replace the <BASTION_PWD> placeholder with the password specific to your environment. Log back into the bastion node: ssh itzuser@api.67828ca5e432cac47ccc4230.ocp.techzone.ibm.com -p 40222 <BASTION_PWD> Engage the sudo (privileged access) session: sudo bash Source the environment variables stored in cpd_vars.sh : source cpd_vars.sh Log back into OpenShift: ${ OC_LOGIN } Log back into cpd-cli : ${ CPDM_OC_LOGIN }","title":"4. Cluster preparation"},{"location":"on-premises/4/#cluster-preparationon-premises-installation-and-deployment","text":"The following section is based off of IBM Documentation for preparing an OpenShift cluster for IBM Cloud Pak for Data. Reference the instructions in full at the following resource: Preparing Your Cluster for IBM Software Hub .","title":"Cluster preparationOn-Premises Installation and Deployment"},{"location":"on-premises/4/#i-change-process-ids-limit","text":"With a newly installed cluster, a KubeletConfig will need to be manually created before the cluster's process IDs can be modified. This file will define the podPidsLimit and maxPods variables for the environment. Copy the contents of the following code block and then execute within your Terminal console to generate a new KubeletConfig file: oc apply -f - << EOF apiVersion: machineconfiguration.openshift.io/v1 kind: KubeletConfig metadata: name: cpd-watsonx-kubeletconfig spec: kubeletConfig: podPidsLimit: 16384 podsPerCore: 0 maxPods: 500 machineConfigPoolSelector: matchExpressions: - key: pools.operator.machineconfiguration.openshift.io/worker operator: Exists EOF KUBELETCONFIG TEST You can test whether a KubeletConfig file exists on the system by executing the following command: oc get kubeletconfig Record the output returned by the console and save this information to a notepad for reference later. Use the CP4D command line ( cpd-cli ) to log into OCP by executing the following code: cpd-cli manage login-to-ocp \\ --username = ${ OCP_USERNAME } \\ --password = ${ OCP_PASSWORD } \\ --server = ${ OCP_URL } The operation will take approximately 1 minute to complete. After a successful run, the console should return a pair of messages that resemble the following: [ SUCCESS ] 2025 -03-19T18:04:23.978349Z You may find output and logs in the /home/itzuser/cpd-cli-workspace/olm-utils-workspace/work directory. [ SUCCESS ] 2025 -03-19T18:04:23.978412Z The login-to-ocp command ran successfully.","title":"i. Change process IDs limit"},{"location":"on-premises/4/#ii-update-the-clusters-global-pull-secret","text":"Use cpd-cli to manage the creation or updating of the global image pull secret via the add-icr-cred-to-global-pull-secret command. Execute the following command within the Terminal console: cpd-cli manage add-icr-cred-to-global-pull-secret --entitled_registry_key = ${ IBM_ENTITLEMENT_KEY } The console will return two [SUCCESS] statements indicating a successful run. Now you must update all nodes across the cluster using OpenShift command line ( oc ). Execute the following instructions via the Terminal console: oc login ${ OCP_URL } --username = ${ OCP_USERNAME } --password = ${ OCP_PASSWORD } oc get mcp Once completed, execute the following statement to check the status of the cluster nodes (this can be performed periodically to track the progress of the node updates): cpd-cli manage oc get nodes Wait until the STATUS returns for all nodes (3 master nodes, 3 storage nodes, and 3 worker nodes) all report as Ready .","title":"ii. Update the cluster's global pull secret"},{"location":"on-premises/4/#iii-next-steps","text":"In the following module, you will install the necessary prerequisite software required to deploy IBM Cloud Pak for Data and IBM watsonx Code Assistant. TROUBLESHOOTING: LOGGING IN AND SESSION TIMEOUTS Be aware that SSH connections made over Terminal will time out after a long period of inactivity or due to a connection error. If you need to log back into the bastion terminal, follow the procedure below. Replace the <BASTION_PWD> placeholder with the password specific to your environment. Log back into the bastion node: ssh itzuser@api.67828ca5e432cac47ccc4230.ocp.techzone.ibm.com -p 40222 <BASTION_PWD> Engage the sudo (privileged access) session: sudo bash Source the environment variables stored in cpd_vars.sh : source cpd_vars.sh Log back into OpenShift: ${ OC_LOGIN } Log back into cpd-cli : ${ CPDM_OC_LOGIN }","title":"iii. Next steps"},{"location":"on-premises/5/","text":"Install prerequisite software On-Premises Installation and Deployment Review the latest documentation on IBM Software Hub to determine the appropriate version needed for your client opportunity and OpenShift cluster version. The following module follows the documentation for installing IBM Software Hub's cert-manager-operator.v.13.0 for OpenShift Container Platform (OCP) v4.16. i. Install the Red Hat OpenShift cert-manager After the release of IBM Software Hub , previous methods for installing IBM Cloud Pak for Data (CP4D) that relied on IBM Cert Manager are no longer required. IBM Software Hub is now the recommended path and will be the method adhered to in the following section. First create the prerequisite project namespace by executing the following instruction: oc new-project cert-manager-operator Afterwards, return to your web browser and open the OCP Dashboard ( Step 8 of Module 2 ). From the left-hand navigation menu, navigate to Operators > OperatorHub [A] . Into the filter box [B] , type cert-manager Operator for Red Hat OpenShift and click [C] the filtered result with the same name. From the configuration screen, select the following options: Channel [A] : stable-v1.13 Version [B] : 1.13.0 When ready, click the blue Install [C] button A new page will load, summarizing the settings of the proposed Operator. Verify that the details are correct: Update channel [A] : stable-v1.13 Version [B] : 1.13.0 Installation mode [C] : A specific namespace on the cluster Installed namespace [D] : Operator recommended Namespace: cert-manager-operator Update approval [E] : Manual When ready, scroll down to the bottom of the page and click the blue Install [F] button. The page will refresh periodically as the Operator is installed on the cluster. This may take several minutes to complete. When prompted with a Manual approval required splashscreen, click Approve [G] Wait until the page refreshes with the message Installed operator: ready for use and then click View Operator [H] to view the finalized Operator You can also track the progress of the Operator installation by drilling down into Operators > Installed Operators from the left-hand side of the OCP Dashboard. Scroll down until you locate the cert-manager Operator for Red Hat OpenShift entry in the table. Monitor the progress by observing changes to the fourth column of the table. Wait until Operator shows a status of Succeeded . On the OCP Dashboard, make sure you are under the Operators > Installed Operators view. Click the title of the cert-manager-Operator for Red Hat OpenShift to open the details panel From the tabs along the top of the page, click Subscription [A] Under the Subscription details header, there are three panels: Update channel , Update approval , and Update status Click the hyperlinked 1 requires approval [B] text next to the Update Status panel A new page, InstallPlan details for install-12xyz , will load. The string 12xyz appended to install- is randomized. Your OCP cert-manager will have a unique name to the one in this example. Click the blue Preview InstallPlan [A] button When the panel refreshes, click the blue Approve button to begin updating to v1.13.1 Wait for the status to the right of install-12xyz to read Complete [B] After the status of the install-12xyz InstallPlan reads as Complete , the OCP dashboard will automatically refresh to display cert-manager-operator.v1.13.1 's multiple components and services. These can also be viewed again later by drilling down into Operators > Installed Operators > cert-manager-operator.v1.13.1 from the left-hand interface. Record the Name of the component where the Kind value set to ServiceAccount . Save this information to a notepad for future reference. From the left-hand navigation bar of the OCP Dashboard, once again navigate into Operators > Installed Operators to watch the progress of the update. The cert-manager Operator for Red Hat OpenShift will show a Status of Installing while the update is underway. Wait until the status changes to Succeeded [A] . Verify that cert-manager pods are up and running by executing the following command with your Terminal console: oc get pods -n cert-manager The console should return output closely resembling the following: NAME READY STATUS RESTARTS AGE cert-manager-bd7fbb9fc-wvbbt 1 /1 Running 0 3m39s cert-manager-cainjector-56cc5f9868-7g9z7 1 /1 Running 0 4m5s cert-manager-webhook-d4f79d7f7-9dg9w 1 /1 Running 0 4m9s At this point, the OpenShift cert-manager has been successfully deployed on the cluster. ii. Operators for GPUs GPUs NOT SUPPORTED FOR L4 ON-PREMISES DEPLOYMENTS Resource and budget constraints for IBM Technology Zone and the IBM Enablement teams means that GPUs are unavailable for the on-premises portion of the Level 4 curriculum. The NVIDIA A100 or H100 GPUs required are simply too cost-prohibitive to be made available for individual IBMers and business partners. GPUs cannot be shared in a multi-tenant access pattern for IBM watsonx Code Assistant \u2014 and, as such, at minimum two cards would need to be made available for every L4 reservation. These costs are beyond the scope of what can be supported by this training. Participants will have access to GPUs for the IBM Cloud (SaaS) portion of the Level 4 curriculum. Although GPUs will not be available to deploy or interact with for the On-Premises Installation and Deployment L4 training modules, participants will still be able to practice and learn the skills needed to prepare a cluster for GPUs. This section will cover all of the necessary configuration and setup required to make GPUs available to an IBM watsonx Code Assitant service \u2014 shy of actually getting to use the GPUs with the on-premises deployment. Participants will still be able to interact with GPU-powered instances in the latter IBM Cloud (SaaS) modules of the L4 curriculum. Services such as IBM watsonx Code Assistant (on-premises), which requires access to GPUs, need to install several Operators on the OpenShift cluster to support the management of NVIDIA software components. Those components, in turn, are needed to integrate the GPUs for access by the cluster. IBM watsonx Code Assistant requires that the following Operators be installed: - Node Feature Discovery Operator : within the openshift-nfd namespace - NVIDIA GPU Operator : within the nvidia-gpu-operator namespace - Red Hat OpenShift AI iii. Install the Node Feature Discovery Operator The following section is based off a selection of the complete IBM Documentation available for Installing operators for services that require GPUs . The following section will provide the instructions necessary to replicate the procedure of integrating NVIDIA GPUs with the OCP cluster. Participants are welcome to practice this with the L4 environment provided \u2014 just be aware that no physical GPU hardware will be available or connected at the conclusion of these steps. Use a Terminal console to programmatically create a namespace openshift-nfd for the Node Feature Discovery (NDF) Operator. The following instruction set will create a namespace Custom Resource (CR) that defines the openshift-ndf namespace and then saves the YAML file to nfd-namespace.yaml . Copy and paste the following code block into the Terminal console, then hit Enter : oc apply -f - <<EOF apiVersion: v1 kind: Namespace metadata: name: openshift-nfd labels: name: openshift-nfd openshift.io/cluster-monitoring: \"true\" EOF Install the NDF Operator within the openshift-nfd namespace that was created in Step 11 by defining the following objects. This will create an OperatorGroup CR and subsequently save the YAML file to operatorgroup.yaml . Copy and paste the following code block into the Terminal console, then hit Enter : oc apply -f - <<EOF apiVersion: operators.coreos.com/v1 kind: OperatorGroup metadata: generateName: openshift-nfd- name: openshift-nfd namespace: openshift-nfd spec: targetNamespaces: - openshift-nfd EOF Create a Subscription CR and save the YAML file to nfd-sub.yaml . Copy and paste the following code block into the Terminal console, then hit Enter : oc apply -f - <<EOF apiVersion: operators.coreos.com/v1alpha1 kind: Subscription metadata: name: nfd namespace: openshift-nfd spec: channel: \"stable\" installPlanApproval: Automatic name: nfd source: redhat-operators sourceNamespace: openshift-marketplace EOF Check on the status of the OpenShift pods with the following command: oc get pods -n openshift-nfd TROUBLESHOOTING: No resources found in openshift-ndf namespace. Initially, the console may return a response such as No resources found in openshift-ndf namespace. This likely is because the pod is still provisioning. Use the OCP Dashboard to monitor the progress of the pod deployments: Return to the OCP Dashboard and navigate to Operators > Installed Operators [A] Within the table, look for a resource named nfd [B] If the code from Step 13 was only recently executed, the Managed Namespaces of this resource may be showing as None and the Status as Unknown [C] Wait a few moments (and refresh the page if you wish) until the nfd resource is replaced by Node Feature Discovery Operator [D] , which should then belong to the openshift-nfd Managed Namespace and have a Succeeded Status [E] This operation will take approximately 2 minutes to complete. Wait and then execute the previous command from Step 14 a second time within the Terminal console. Observe the updated pod status. The console should report back the following to indicate that the Operator was successfully deployed: NAME READY STATUS RESTARTS AGE nfd-controller-manager-7f4c4cf577-wn96r 2 /2 Running 0 3m10s Create a NodeFeatureDiscovery CR and save the YAML file to NodeFeatureDiscovery.yaml . Copy and paste the following code block into the Terminal console, then hit Enter : oc apply -f - <<EOF apiVersion: nfd.openshift.io/v1 kind: NodeFeatureDiscovery metadata: name: nfd-instance namespace: openshift-nfd spec: instance: \"\" # instance is empty by default operand: image: registry.redhat.io/openshift4/ose-node-feature-discovery-rhel9:v4.16 imagePullPolicy: Always workerConfig: configData: | core: # labelWhiteList: # noPublish: false sleepInterval: 60s # sources: [all] # klog: # addDirHeader: false # alsologtostderr: false # logBacktraceAt: # logtostderr: true # skipHeaders: false # stderrthreshold: 2 # v: 0 # vmodule: ## NOTE: the following options are not dynamically run-time configurable ## and require a nfd-worker restart to take effect after being changed # logDir: # logFile: # logFileMaxSize: 1800 # skipLogHeaders: false sources: cpu: cpuid: # NOTE: whitelist has priority over blacklist attributeBlacklist: - \"BMI1\" - \"BMI2\" - \"CLMUL\" - \"CMOV\" - \"CX16\" - \"ERMS\" - \"F16C\" - \"HTT\" - \"LZCNT\" - \"MMX\" - \"MMXEXT\" - \"NX\" - \"POPCNT\" - \"RDRAND\" - \"RDSEED\" - \"RDTSCP\" - \"SGX\" - \"SSE\" - \"SSE2\" - \"SSE3\" - \"SSE4.1\" - \"SSE4.2\" - \"SSSE3\" attributeWhitelist: kernel: kconfigFile: \"/path/to/kconfig\" configOpts: - \"NO_HZ\" - \"X86\" - \"DMI\" pci: deviceClassWhitelist: - \"0200\" - \"03\" - \"12\" deviceLabelFields: - \"class\" - \"vendor\" EOF As before, check on the status of the OpenShift pods with the following command: oc get pods -n openshift-nfd This operation will take approximately 1 minutes to complete. Wait until all pods return a status of Running before continuing to Step 17. iv. Install the NVIDIA GPU Operator The following section is based off a selection of the complete NVIDIA Corporation documentation for Installing the NVIDIA GPU Operator on OpenShift . Create the nvidia-gpu-operator namespace by executing the following code block with a Terminal console: oc apply -f - <<EOF apiVersion: v1 kind: Namespace metadata: name: nvidia-gpu-operator EOF Define the OperatorGroup within the same namespace: oc apply -f - <<EOF apiVersion: operators.coreos.com/v1 kind: OperatorGroup metadata: name: nvidia-gpu-operator-group namespace: nvidia-gpu-operator spec: targetNamespaces: - nvidia-gpu-operator EOF Execute the following code block within a Terminal console to get the channel version (required for Step 20), as well as create the gpu-operator-certified Operator within the nvidia-gpu-operator namespace: export CHANNEL = $( oc get packagemanifest gpu-operator-certified -n openshift-marketplace -o jsonpath = '{.status.defaultChannel}' ; echo ) export CURRENT_CSV = $( oc get packagemanifests/gpu-operator-certified -n openshift-marketplace -ojson | jq -r '.status.channels[] | select(.name == \"' $CHANNEL '\") | .currentCSV' ; echo ) oc apply -f - <<EOF apiVersion: operators.coreos.com/v1alpha1 kind: Subscription metadata: name: gpu-operator-certified namespace: nvidia-gpu-operator spec: channel: \"${CHANNEL}\" installPlanApproval: Manual name: gpu-operator-certified source: certified-operators sourceNamespace: openshift-marketplace startingCSV: \"${CURRENT_CSV}\" EOF Execute the following command to verify the status of the install plan: oc get installplan -n nvidia-gpu-operator TROUBLESHOOTING: No resources found in nvidia-gpu-operator namespace. The nvidia-gpu-operator namespace is still being deployed. Wait for 1 minute and then try executing Step 20 again. The console will return a statement that Operator's APPROVAL status is currently set to Manual and incomplete ( APPROVED state is set to false ). NAME CSV APPROVAL APPROVED install-4rq4j gpu-operator-certified.v24.9.2 Manual false Therefore, you will need to approve the install plan by executing the following command: export INSTALL_PLAN = $( oc get installplan -n nvidia-gpu-operator -oname ) oc patch $INSTALL_PLAN -n nvidia-gpu-operator --type merge --patch '{\"spec\":{\"approved\":true }}' Return to the OCP Dashboard and drill down into Operators > Installed Operators to monitor the progress of the update. Wait until the NVIDIA GPU Operator [A] appears in the table with Status set to Succeeded before continuing. Create a ClusterPolicy by executing the following instructions: oc get csv -n nvidia-gpu-operator ${ CURRENT_CSV } -ojsonpath ={ .metadata.annotations.alm-examples } | jq . [ 0 ] > clusterpolicy.json oc apply -f clusterpolicy.json Record the status message returned by the console to a notepad for reference later. Check the status of the pods. If GPUs are detected within the cluster, they will be included in the read-out. As the Level 4 demonstration environment is not equipped with GPU hardware, no GPU resources will be discovered by the oc get command. Execute the following command with the Terminal console: oc get pods -n nvidia-gpu-operator v. Install Red Hat OpenShift AI The following steps are extracted from the complete documentation available from IBM Documentation for Installing Red Hat OpenShift AI . IBM watsonx Code Assistant (on-premises) requires installation and configuration of Red Hat OpenShift AI on the OCP cluster. In the following section, you will: Install the Operator for Red Hat OpenShift AI (v2.13) Create a DSCInitialization instance Create a DataScienceCluster instance Edit the model inferencing configuration Create the redhat-ods-operator Project on the OCP cluster with the following command: oc new-project redhat-ods-operator Define the rhods-operator Operator Group within the project defined in Step 23: cat <<EOF |oc apply -f - apiVersion: operators.coreos.com/v1 kind: OperatorGroup metadata: name: rhods-operator namespace: redhat-ods-operator EOF Create the Operator Subscription for rhods-operator within the same project: cat <<EOF |oc apply -f - apiVersion: operators.coreos.com/v1alpha1 kind: Subscription metadata: name: rhods-operator namespace: redhat-ods-operator spec: name: rhods-operator channel: stable-2.13 source: redhat-operators sourceNamespace: openshift-marketplace config: env: - name: \"DISABLE_DSC_CONFIG\" EOF This operation will take approximately 5 minutes to complete. Return to the OCP Dashboard and drill down into Operators > Installed Operators to monitor the progress of the Red Hat OpenShift AI [A] Operator deployment. Create a DSCInitialization object default-dsci in redhat-ods-monitoring project: cat <<EOF |oc apply -f - apiVersion: dscinitialization.opendatahub.io/v1 kind: DSCInitialization metadata: name: default-dsci spec: applicationsNamespace: redhat-ods-applications monitoring: managementState: Managed namespace: redhat-ods-monitoring serviceMesh: managementState: Removed trustedCABundle: managementState: Managed customCABundle: \"\" EOF Monitor the progress of the DSCInitialization object by executing the following command: oc get dscinitialization This operation will take approximately 2 minutes to complete. Wait for the DSCInitialization object ( dscinitialization ) to return a Ready status before continuing on to Step 27. Create a DataScienceCluster object named default-dsc within the same project: cat <<EOF |oc apply -f - apiVersion: datasciencecluster.opendatahub.io/v1 kind: DataScienceCluster metadata: name: default-dsc spec: components: codeflare: managementState: Removed dashboard: managementState: Removed datasciencepipelines: managementState: Removed kserve: managementState: Managed defaultDeploymentMode: RawDeployment serving: managementState: Removed name: knative-serving kueue: managementState: Removed modelmeshserving: managementState: Removed ray: managementState: Removed trainingoperator: managementState: Managed trustyai: managementState: Removed workbenches: managementState: Removed EOF The Red Hat OpenShift AI Operator automatically installs and manages services that are listed as Managed . Services with a status of Removed are ignored and will not be installed. This operation will take approximately 2-3 minutes to complete. Execute the following instruction to check the status of pods within the redhat-ods-applications project: oc get pods -n redhat-ods-applications If no pods are detected, wait an additional 3 minutes and try again. Confirm that ALL FIVE of the following pods are deployed with a Running status before continuing to Step 29 . NAME READY STATUS RESTARTS AGE kserve-controller-manager-7b745757cb-wx7qc 1 /1 Running 0 42s kubeflow-<REDACTED>-659b5dcb99-5t8vt 1 /1 Running 0 56s odh-model-controller-b774fb859-2b4b4 1 /1 Running 0 117s odh-model-controller-b774fb859-4gxhv 1 /1 Running 0 117s odh-model-controller-b774fb859-fpnrl 1 /1 Running 0 117s Record the full name of the kubeflow-... pod to a notepad for reference later. Edit the inferenceservice-config configuration map within the redhat-ods-applications project. This is best achieved by using the OCP Dashboard via a web browser. From the OCP Dashboard, navigate into Workloads > Configmaps [A] From the Project [B] drop-down list, select redhat-ods-applications [C] Click the inferenceservice-config resource [D] and open the YAML tab [E] In the metadata.annotations section [F] (Lines 4-5) of the file, add a new Line 8 [G] which reads opendatahub.io/managed: 'false' Do not save the changes yet (there are more changes in Step 30 to perform before saving the YAML file) The resulting YAML file should resemble the following: metadata : annotations : internal.config.kubernetes.io/previousKinds : ConfigMap internal.config.kubernetes.io/previousNames : inferenceservice-config internal.config.kubernetes.io/previousNamespaces : opendatahub opendatahub.io/managed : 'false' Within the same YAML file, look for Line 379 under the ingress section [A] : \"domainTemplate\" : \"{ .Name }-{ .Namespace }.{ .IngressDomain }\" , Replace Line 379 with the following (be sure to include the last , character) [B] : \"domainTemplate\" : \"example.com\" , Click Save [C] (bottom-left) to finalize the changes to the YAML file. If prompted with a Managed resource warning, click Save [D] again to confirm. Copy and paste the full contents of the inferenceservice-config YAML file to a text editor. Search for the the following: datasciencecluster Record the full value of the apiVersion: attribute containing this value and save the information to a notepad for reference later. vi. Next steps At this stage, all of the necessary prerequisites have been installed and you are ready to begin installation of an IBM Software Hub instance on the OCP cluster. TROUBLESHOOTING: LOGGING IN AND SESSION TIMEOUTS Be aware that SSH connections made over Terminal will time out after a long period of inactivity or due to a connection error. If you need to log back into the bastion terminal, follow the procedure below. Replace the <BASTION_PWD> placeholder with the password specific to your environment. Log back into the bastion node: ssh itzuser@api.67828ca5e432cac47ccc4230.ocp.techzone.ibm.com -p 40222 <BASTION_PWD> Engage the sudo (privileged access) session: sudo bash Source the environment variables stored in cpd_vars.sh : source cpd_vars.sh Log back into OpenShift: ${ OC_LOGIN } Log back into cpd-cli : ${ CPDM_OC_LOGIN }","title":"5. Install prerequisite software"},{"location":"on-premises/5/#install-prerequisite-softwareon-premises-installation-and-deployment","text":"Review the latest documentation on IBM Software Hub to determine the appropriate version needed for your client opportunity and OpenShift cluster version. The following module follows the documentation for installing IBM Software Hub's cert-manager-operator.v.13.0 for OpenShift Container Platform (OCP) v4.16.","title":"Install prerequisite softwareOn-Premises Installation and Deployment"},{"location":"on-premises/5/#i-install-the-red-hat-openshift-cert-manager","text":"After the release of IBM Software Hub , previous methods for installing IBM Cloud Pak for Data (CP4D) that relied on IBM Cert Manager are no longer required. IBM Software Hub is now the recommended path and will be the method adhered to in the following section. First create the prerequisite project namespace by executing the following instruction: oc new-project cert-manager-operator Afterwards, return to your web browser and open the OCP Dashboard ( Step 8 of Module 2 ). From the left-hand navigation menu, navigate to Operators > OperatorHub [A] . Into the filter box [B] , type cert-manager Operator for Red Hat OpenShift and click [C] the filtered result with the same name. From the configuration screen, select the following options: Channel [A] : stable-v1.13 Version [B] : 1.13.0 When ready, click the blue Install [C] button A new page will load, summarizing the settings of the proposed Operator. Verify that the details are correct: Update channel [A] : stable-v1.13 Version [B] : 1.13.0 Installation mode [C] : A specific namespace on the cluster Installed namespace [D] : Operator recommended Namespace: cert-manager-operator Update approval [E] : Manual When ready, scroll down to the bottom of the page and click the blue Install [F] button. The page will refresh periodically as the Operator is installed on the cluster. This may take several minutes to complete. When prompted with a Manual approval required splashscreen, click Approve [G] Wait until the page refreshes with the message Installed operator: ready for use and then click View Operator [H] to view the finalized Operator You can also track the progress of the Operator installation by drilling down into Operators > Installed Operators from the left-hand side of the OCP Dashboard. Scroll down until you locate the cert-manager Operator for Red Hat OpenShift entry in the table. Monitor the progress by observing changes to the fourth column of the table. Wait until Operator shows a status of Succeeded . On the OCP Dashboard, make sure you are under the Operators > Installed Operators view. Click the title of the cert-manager-Operator for Red Hat OpenShift to open the details panel From the tabs along the top of the page, click Subscription [A] Under the Subscription details header, there are three panels: Update channel , Update approval , and Update status Click the hyperlinked 1 requires approval [B] text next to the Update Status panel A new page, InstallPlan details for install-12xyz , will load. The string 12xyz appended to install- is randomized. Your OCP cert-manager will have a unique name to the one in this example. Click the blue Preview InstallPlan [A] button When the panel refreshes, click the blue Approve button to begin updating to v1.13.1 Wait for the status to the right of install-12xyz to read Complete [B] After the status of the install-12xyz InstallPlan reads as Complete , the OCP dashboard will automatically refresh to display cert-manager-operator.v1.13.1 's multiple components and services. These can also be viewed again later by drilling down into Operators > Installed Operators > cert-manager-operator.v1.13.1 from the left-hand interface. Record the Name of the component where the Kind value set to ServiceAccount . Save this information to a notepad for future reference. From the left-hand navigation bar of the OCP Dashboard, once again navigate into Operators > Installed Operators to watch the progress of the update. The cert-manager Operator for Red Hat OpenShift will show a Status of Installing while the update is underway. Wait until the status changes to Succeeded [A] . Verify that cert-manager pods are up and running by executing the following command with your Terminal console: oc get pods -n cert-manager The console should return output closely resembling the following: NAME READY STATUS RESTARTS AGE cert-manager-bd7fbb9fc-wvbbt 1 /1 Running 0 3m39s cert-manager-cainjector-56cc5f9868-7g9z7 1 /1 Running 0 4m5s cert-manager-webhook-d4f79d7f7-9dg9w 1 /1 Running 0 4m9s At this point, the OpenShift cert-manager has been successfully deployed on the cluster.","title":"i. Install the Red Hat OpenShift cert-manager"},{"location":"on-premises/5/#ii-operators-for-gpus","text":"GPUs NOT SUPPORTED FOR L4 ON-PREMISES DEPLOYMENTS Resource and budget constraints for IBM Technology Zone and the IBM Enablement teams means that GPUs are unavailable for the on-premises portion of the Level 4 curriculum. The NVIDIA A100 or H100 GPUs required are simply too cost-prohibitive to be made available for individual IBMers and business partners. GPUs cannot be shared in a multi-tenant access pattern for IBM watsonx Code Assistant \u2014 and, as such, at minimum two cards would need to be made available for every L4 reservation. These costs are beyond the scope of what can be supported by this training. Participants will have access to GPUs for the IBM Cloud (SaaS) portion of the Level 4 curriculum. Although GPUs will not be available to deploy or interact with for the On-Premises Installation and Deployment L4 training modules, participants will still be able to practice and learn the skills needed to prepare a cluster for GPUs. This section will cover all of the necessary configuration and setup required to make GPUs available to an IBM watsonx Code Assitant service \u2014 shy of actually getting to use the GPUs with the on-premises deployment. Participants will still be able to interact with GPU-powered instances in the latter IBM Cloud (SaaS) modules of the L4 curriculum. Services such as IBM watsonx Code Assistant (on-premises), which requires access to GPUs, need to install several Operators on the OpenShift cluster to support the management of NVIDIA software components. Those components, in turn, are needed to integrate the GPUs for access by the cluster. IBM watsonx Code Assistant requires that the following Operators be installed: - Node Feature Discovery Operator : within the openshift-nfd namespace - NVIDIA GPU Operator : within the nvidia-gpu-operator namespace - Red Hat OpenShift AI","title":"ii. Operators for GPUs"},{"location":"on-premises/5/#iii-install-the-node-feature-discovery-operator","text":"The following section is based off a selection of the complete IBM Documentation available for Installing operators for services that require GPUs . The following section will provide the instructions necessary to replicate the procedure of integrating NVIDIA GPUs with the OCP cluster. Participants are welcome to practice this with the L4 environment provided \u2014 just be aware that no physical GPU hardware will be available or connected at the conclusion of these steps. Use a Terminal console to programmatically create a namespace openshift-nfd for the Node Feature Discovery (NDF) Operator. The following instruction set will create a namespace Custom Resource (CR) that defines the openshift-ndf namespace and then saves the YAML file to nfd-namespace.yaml . Copy and paste the following code block into the Terminal console, then hit Enter : oc apply -f - <<EOF apiVersion: v1 kind: Namespace metadata: name: openshift-nfd labels: name: openshift-nfd openshift.io/cluster-monitoring: \"true\" EOF Install the NDF Operator within the openshift-nfd namespace that was created in Step 11 by defining the following objects. This will create an OperatorGroup CR and subsequently save the YAML file to operatorgroup.yaml . Copy and paste the following code block into the Terminal console, then hit Enter : oc apply -f - <<EOF apiVersion: operators.coreos.com/v1 kind: OperatorGroup metadata: generateName: openshift-nfd- name: openshift-nfd namespace: openshift-nfd spec: targetNamespaces: - openshift-nfd EOF Create a Subscription CR and save the YAML file to nfd-sub.yaml . Copy and paste the following code block into the Terminal console, then hit Enter : oc apply -f - <<EOF apiVersion: operators.coreos.com/v1alpha1 kind: Subscription metadata: name: nfd namespace: openshift-nfd spec: channel: \"stable\" installPlanApproval: Automatic name: nfd source: redhat-operators sourceNamespace: openshift-marketplace EOF Check on the status of the OpenShift pods with the following command: oc get pods -n openshift-nfd TROUBLESHOOTING: No resources found in openshift-ndf namespace. Initially, the console may return a response such as No resources found in openshift-ndf namespace. This likely is because the pod is still provisioning. Use the OCP Dashboard to monitor the progress of the pod deployments: Return to the OCP Dashboard and navigate to Operators > Installed Operators [A] Within the table, look for a resource named nfd [B] If the code from Step 13 was only recently executed, the Managed Namespaces of this resource may be showing as None and the Status as Unknown [C] Wait a few moments (and refresh the page if you wish) until the nfd resource is replaced by Node Feature Discovery Operator [D] , which should then belong to the openshift-nfd Managed Namespace and have a Succeeded Status [E] This operation will take approximately 2 minutes to complete. Wait and then execute the previous command from Step 14 a second time within the Terminal console. Observe the updated pod status. The console should report back the following to indicate that the Operator was successfully deployed: NAME READY STATUS RESTARTS AGE nfd-controller-manager-7f4c4cf577-wn96r 2 /2 Running 0 3m10s Create a NodeFeatureDiscovery CR and save the YAML file to NodeFeatureDiscovery.yaml . Copy and paste the following code block into the Terminal console, then hit Enter : oc apply -f - <<EOF apiVersion: nfd.openshift.io/v1 kind: NodeFeatureDiscovery metadata: name: nfd-instance namespace: openshift-nfd spec: instance: \"\" # instance is empty by default operand: image: registry.redhat.io/openshift4/ose-node-feature-discovery-rhel9:v4.16 imagePullPolicy: Always workerConfig: configData: | core: # labelWhiteList: # noPublish: false sleepInterval: 60s # sources: [all] # klog: # addDirHeader: false # alsologtostderr: false # logBacktraceAt: # logtostderr: true # skipHeaders: false # stderrthreshold: 2 # v: 0 # vmodule: ## NOTE: the following options are not dynamically run-time configurable ## and require a nfd-worker restart to take effect after being changed # logDir: # logFile: # logFileMaxSize: 1800 # skipLogHeaders: false sources: cpu: cpuid: # NOTE: whitelist has priority over blacklist attributeBlacklist: - \"BMI1\" - \"BMI2\" - \"CLMUL\" - \"CMOV\" - \"CX16\" - \"ERMS\" - \"F16C\" - \"HTT\" - \"LZCNT\" - \"MMX\" - \"MMXEXT\" - \"NX\" - \"POPCNT\" - \"RDRAND\" - \"RDSEED\" - \"RDTSCP\" - \"SGX\" - \"SSE\" - \"SSE2\" - \"SSE3\" - \"SSE4.1\" - \"SSE4.2\" - \"SSSE3\" attributeWhitelist: kernel: kconfigFile: \"/path/to/kconfig\" configOpts: - \"NO_HZ\" - \"X86\" - \"DMI\" pci: deviceClassWhitelist: - \"0200\" - \"03\" - \"12\" deviceLabelFields: - \"class\" - \"vendor\" EOF As before, check on the status of the OpenShift pods with the following command: oc get pods -n openshift-nfd This operation will take approximately 1 minutes to complete. Wait until all pods return a status of Running before continuing to Step 17.","title":"iii. Install the Node Feature Discovery Operator"},{"location":"on-premises/5/#iv-install-the-nvidia-gpu-operator","text":"The following section is based off a selection of the complete NVIDIA Corporation documentation for Installing the NVIDIA GPU Operator on OpenShift . Create the nvidia-gpu-operator namespace by executing the following code block with a Terminal console: oc apply -f - <<EOF apiVersion: v1 kind: Namespace metadata: name: nvidia-gpu-operator EOF Define the OperatorGroup within the same namespace: oc apply -f - <<EOF apiVersion: operators.coreos.com/v1 kind: OperatorGroup metadata: name: nvidia-gpu-operator-group namespace: nvidia-gpu-operator spec: targetNamespaces: - nvidia-gpu-operator EOF Execute the following code block within a Terminal console to get the channel version (required for Step 20), as well as create the gpu-operator-certified Operator within the nvidia-gpu-operator namespace: export CHANNEL = $( oc get packagemanifest gpu-operator-certified -n openshift-marketplace -o jsonpath = '{.status.defaultChannel}' ; echo ) export CURRENT_CSV = $( oc get packagemanifests/gpu-operator-certified -n openshift-marketplace -ojson | jq -r '.status.channels[] | select(.name == \"' $CHANNEL '\") | .currentCSV' ; echo ) oc apply -f - <<EOF apiVersion: operators.coreos.com/v1alpha1 kind: Subscription metadata: name: gpu-operator-certified namespace: nvidia-gpu-operator spec: channel: \"${CHANNEL}\" installPlanApproval: Manual name: gpu-operator-certified source: certified-operators sourceNamespace: openshift-marketplace startingCSV: \"${CURRENT_CSV}\" EOF Execute the following command to verify the status of the install plan: oc get installplan -n nvidia-gpu-operator TROUBLESHOOTING: No resources found in nvidia-gpu-operator namespace. The nvidia-gpu-operator namespace is still being deployed. Wait for 1 minute and then try executing Step 20 again. The console will return a statement that Operator's APPROVAL status is currently set to Manual and incomplete ( APPROVED state is set to false ). NAME CSV APPROVAL APPROVED install-4rq4j gpu-operator-certified.v24.9.2 Manual false Therefore, you will need to approve the install plan by executing the following command: export INSTALL_PLAN = $( oc get installplan -n nvidia-gpu-operator -oname ) oc patch $INSTALL_PLAN -n nvidia-gpu-operator --type merge --patch '{\"spec\":{\"approved\":true }}' Return to the OCP Dashboard and drill down into Operators > Installed Operators to monitor the progress of the update. Wait until the NVIDIA GPU Operator [A] appears in the table with Status set to Succeeded before continuing. Create a ClusterPolicy by executing the following instructions: oc get csv -n nvidia-gpu-operator ${ CURRENT_CSV } -ojsonpath ={ .metadata.annotations.alm-examples } | jq . [ 0 ] > clusterpolicy.json oc apply -f clusterpolicy.json Record the status message returned by the console to a notepad for reference later. Check the status of the pods. If GPUs are detected within the cluster, they will be included in the read-out. As the Level 4 demonstration environment is not equipped with GPU hardware, no GPU resources will be discovered by the oc get command. Execute the following command with the Terminal console: oc get pods -n nvidia-gpu-operator","title":"iv. Install the NVIDIA GPU Operator"},{"location":"on-premises/5/#v-install-red-hat-openshift-ai","text":"The following steps are extracted from the complete documentation available from IBM Documentation for Installing Red Hat OpenShift AI . IBM watsonx Code Assistant (on-premises) requires installation and configuration of Red Hat OpenShift AI on the OCP cluster. In the following section, you will: Install the Operator for Red Hat OpenShift AI (v2.13) Create a DSCInitialization instance Create a DataScienceCluster instance Edit the model inferencing configuration Create the redhat-ods-operator Project on the OCP cluster with the following command: oc new-project redhat-ods-operator Define the rhods-operator Operator Group within the project defined in Step 23: cat <<EOF |oc apply -f - apiVersion: operators.coreos.com/v1 kind: OperatorGroup metadata: name: rhods-operator namespace: redhat-ods-operator EOF Create the Operator Subscription for rhods-operator within the same project: cat <<EOF |oc apply -f - apiVersion: operators.coreos.com/v1alpha1 kind: Subscription metadata: name: rhods-operator namespace: redhat-ods-operator spec: name: rhods-operator channel: stable-2.13 source: redhat-operators sourceNamespace: openshift-marketplace config: env: - name: \"DISABLE_DSC_CONFIG\" EOF This operation will take approximately 5 minutes to complete. Return to the OCP Dashboard and drill down into Operators > Installed Operators to monitor the progress of the Red Hat OpenShift AI [A] Operator deployment. Create a DSCInitialization object default-dsci in redhat-ods-monitoring project: cat <<EOF |oc apply -f - apiVersion: dscinitialization.opendatahub.io/v1 kind: DSCInitialization metadata: name: default-dsci spec: applicationsNamespace: redhat-ods-applications monitoring: managementState: Managed namespace: redhat-ods-monitoring serviceMesh: managementState: Removed trustedCABundle: managementState: Managed customCABundle: \"\" EOF Monitor the progress of the DSCInitialization object by executing the following command: oc get dscinitialization This operation will take approximately 2 minutes to complete. Wait for the DSCInitialization object ( dscinitialization ) to return a Ready status before continuing on to Step 27. Create a DataScienceCluster object named default-dsc within the same project: cat <<EOF |oc apply -f - apiVersion: datasciencecluster.opendatahub.io/v1 kind: DataScienceCluster metadata: name: default-dsc spec: components: codeflare: managementState: Removed dashboard: managementState: Removed datasciencepipelines: managementState: Removed kserve: managementState: Managed defaultDeploymentMode: RawDeployment serving: managementState: Removed name: knative-serving kueue: managementState: Removed modelmeshserving: managementState: Removed ray: managementState: Removed trainingoperator: managementState: Managed trustyai: managementState: Removed workbenches: managementState: Removed EOF The Red Hat OpenShift AI Operator automatically installs and manages services that are listed as Managed . Services with a status of Removed are ignored and will not be installed. This operation will take approximately 2-3 minutes to complete. Execute the following instruction to check the status of pods within the redhat-ods-applications project: oc get pods -n redhat-ods-applications If no pods are detected, wait an additional 3 minutes and try again. Confirm that ALL FIVE of the following pods are deployed with a Running status before continuing to Step 29 . NAME READY STATUS RESTARTS AGE kserve-controller-manager-7b745757cb-wx7qc 1 /1 Running 0 42s kubeflow-<REDACTED>-659b5dcb99-5t8vt 1 /1 Running 0 56s odh-model-controller-b774fb859-2b4b4 1 /1 Running 0 117s odh-model-controller-b774fb859-4gxhv 1 /1 Running 0 117s odh-model-controller-b774fb859-fpnrl 1 /1 Running 0 117s Record the full name of the kubeflow-... pod to a notepad for reference later. Edit the inferenceservice-config configuration map within the redhat-ods-applications project. This is best achieved by using the OCP Dashboard via a web browser. From the OCP Dashboard, navigate into Workloads > Configmaps [A] From the Project [B] drop-down list, select redhat-ods-applications [C] Click the inferenceservice-config resource [D] and open the YAML tab [E] In the metadata.annotations section [F] (Lines 4-5) of the file, add a new Line 8 [G] which reads opendatahub.io/managed: 'false' Do not save the changes yet (there are more changes in Step 30 to perform before saving the YAML file) The resulting YAML file should resemble the following: metadata : annotations : internal.config.kubernetes.io/previousKinds : ConfigMap internal.config.kubernetes.io/previousNames : inferenceservice-config internal.config.kubernetes.io/previousNamespaces : opendatahub opendatahub.io/managed : 'false' Within the same YAML file, look for Line 379 under the ingress section [A] : \"domainTemplate\" : \"{ .Name }-{ .Namespace }.{ .IngressDomain }\" , Replace Line 379 with the following (be sure to include the last , character) [B] : \"domainTemplate\" : \"example.com\" , Click Save [C] (bottom-left) to finalize the changes to the YAML file. If prompted with a Managed resource warning, click Save [D] again to confirm. Copy and paste the full contents of the inferenceservice-config YAML file to a text editor. Search for the the following: datasciencecluster Record the full value of the apiVersion: attribute containing this value and save the information to a notepad for reference later.","title":"v. Install Red Hat OpenShift AI"},{"location":"on-premises/5/#vi-next-steps","text":"At this stage, all of the necessary prerequisites have been installed and you are ready to begin installation of an IBM Software Hub instance on the OCP cluster. TROUBLESHOOTING: LOGGING IN AND SESSION TIMEOUTS Be aware that SSH connections made over Terminal will time out after a long period of inactivity or due to a connection error. If you need to log back into the bastion terminal, follow the procedure below. Replace the <BASTION_PWD> placeholder with the password specific to your environment. Log back into the bastion node: ssh itzuser@api.67828ca5e432cac47ccc4230.ocp.techzone.ibm.com -p 40222 <BASTION_PWD> Engage the sudo (privileged access) session: sudo bash Source the environment variables stored in cpd_vars.sh : source cpd_vars.sh Log back into OpenShift: ${ OC_LOGIN } Log back into cpd-cli : ${ CPDM_OC_LOGIN }","title":"vi. Next steps"},{"location":"on-premises/6/","text":"Install IBM Software Hub On-Premises Installation and Deployment The following section is based off of IBM Documentation for Preparing to install an instance of IBM Software Hub . i. Install shared components Before an instance of IBM Software Hub can be installed, you need to install a set of shared services on the OpenShift Container Platform (OCP) cluster: a license service and a scheduler . Three environment variables were set earlier in this lab, which are pertinent now to the license service (as well as the scheduler) that IBM Software Hub requires. These include: $PROJECT_LICENSE_SERVICE $PROJECT_SCHEDULING_SERVICE $VERSION Refresh yourself on these variable's values by executing the following: echo $PROJECT_LICENSE_SERVICE echo $PROJECT_SCHEDULING_SERVICE echo $VERSION These variables were defined within the Cloud Pak for Data (CP4D) Environment Variable ( Step 8 of Module 3 ) on Lines 35, 36, and 53, respectively. Install the license service components by executing the following command: cpd-cli manage apply-cluster-components \\ --release = ${ VERSION } \\ --license_acceptance = true --licensing_ns = ${ PROJECT_LICENSE_SERVICE } This operation will take approximately 10 minutes to complete. After a successful operation, the console will return the following statements: [ \u2714 ] Cert manager is ready. [ SUCCESS ] 2025 -03-19T18:58:58.400864Z You may find output and logs in the <REDACTED> directory. [ SUCCESS ] 2025 -03-19T18:58:58.400949Z The apply-cluster-components command ran successfully. Record the full directory address reported by the [SUCCESS] statement that reads You may find output and logs in the... directory. Save this information to a notepad for future reference. Install the scheduling service by executing the following command: cpd-cli manage apply-scheduler \\ --release = ${ VERSION } \\ --license_acceptance = true \\ --scheduler_ns = ${ PROJECT_SCHEDULING_SERVICE } This operation will take approximately 10 minutes to complete. After a successful operation, the console will return the following statements: [ SUCCESS ] 2025 -03-19T19:14:17.855196Z You may find output and logs in the <REDACTED> directory. [ SUCCESS ] 2025 -03-19T19:14:17.855280Z The apply-scheduler command ran successfully. ii. Install an instance of IBM Software Hub Finally, the cluster has been prepared to a state where it is ready to install an instance of IBM Software Hub. Although the following section requires relatively few inputs from the participant, it will take approximately 45 minutes for the installation process to complete. Create the two new projects that will host your instance by executing the following instructions within a Terminal console: oc new-project ${ PROJECT_CPD_INST_OPERATORS } oc new-project ${ PROJECT_CPD_INST_OPERANDS } Apply the required permissions for an instance of IBM Software Hub: cpd-cli manage authorize-instance-topology \\ --cpd_operator_ns = ${ PROJECT_CPD_INST_OPERATORS } \\ --cpd_instance_ns = ${ PROJECT_CPD_INST_OPERANDS } This operation will take approximately 2 minutes to complete. After a successful operation, the console will return the following statements: [ SUCCESS ] 2025 -03-19T19:17:06.452627Z You may find output and logs in the <REDACTED> directory. [ SUCCESS ] 2025 -03-19T19:17:06.453087Z The authorize-instance-topology command ran successfully. Create the instance by executing the following code block: cpd-cli manage setup-instance \\ --release = ${ VERSION } \\ --license_acceptance = true \\ --cpd_operator_ns = ${ PROJECT_CPD_INST_OPERATORS } \\ --cpd_instance_ns = ${ PROJECT_CPD_INST_OPERANDS } \\ --block_storage_class = ${ STG_CLASS_BLOCK } \\ --file_storage_class = ${ STG_CLASS_FILE } \\ --run_storage_tests = true This operation will take approximately 45 minutes to complete, after which the console will return: [ SUCCESS ] The cpd management server was successfully created in the cpd-watsonx project [ SUCCESS ] 2025 -03-18T00:09:51.194282Z You may find output and logs in the <REDACTED> directory. [ SUCCESS ] 2025 -03-18T00:09:51.194342Z The setup-instance command ran successfully. Examine the last series of console messages just prior to the three [SUCCESS] statements made after the execution of Step 6 . Record the name of the last deployment made to the cluster just prior to those [SUCCESS] statements. Save this information to a notepad for future reference. iii. Next steps With IBM Software Hub now successfully deployed on the OCP cluster, the environment is primed for the installation of IBM watsonx Code Assistant. TROUBLESHOOTING: LOGGING IN AND SESSION TIMEOUTS Be aware that SSH connections made over Terminal will time out after a long period of inactivity or due to a connection error. If you need to log back into the bastion terminal, follow the procedure below. Replace the <BASTION_PWD> placeholder with the password specific to your environment. Log back into the bastion node: ssh itzuser@api.67828ca5e432cac47ccc4230.ocp.techzone.ibm.com -p 40222 <BASTION_PWD> Engage the sudo (privileged access) session: sudo bash Source the environment variables stored in cpd_vars.sh : source cpd_vars.sh Log back into OpenShift: ${ OC_LOGIN } Log back into cpd-cli : ${ CPDM_OC_LOGIN }","title":"6. Install IBM Software Hub"},{"location":"on-premises/6/#install-ibm-software-hubon-premises-installation-and-deployment","text":"The following section is based off of IBM Documentation for Preparing to install an instance of IBM Software Hub .","title":"Install IBM Software HubOn-Premises Installation and Deployment"},{"location":"on-premises/6/#i-install-shared-components","text":"Before an instance of IBM Software Hub can be installed, you need to install a set of shared services on the OpenShift Container Platform (OCP) cluster: a license service and a scheduler . Three environment variables were set earlier in this lab, which are pertinent now to the license service (as well as the scheduler) that IBM Software Hub requires. These include: $PROJECT_LICENSE_SERVICE $PROJECT_SCHEDULING_SERVICE $VERSION Refresh yourself on these variable's values by executing the following: echo $PROJECT_LICENSE_SERVICE echo $PROJECT_SCHEDULING_SERVICE echo $VERSION These variables were defined within the Cloud Pak for Data (CP4D) Environment Variable ( Step 8 of Module 3 ) on Lines 35, 36, and 53, respectively. Install the license service components by executing the following command: cpd-cli manage apply-cluster-components \\ --release = ${ VERSION } \\ --license_acceptance = true --licensing_ns = ${ PROJECT_LICENSE_SERVICE } This operation will take approximately 10 minutes to complete. After a successful operation, the console will return the following statements: [ \u2714 ] Cert manager is ready. [ SUCCESS ] 2025 -03-19T18:58:58.400864Z You may find output and logs in the <REDACTED> directory. [ SUCCESS ] 2025 -03-19T18:58:58.400949Z The apply-cluster-components command ran successfully. Record the full directory address reported by the [SUCCESS] statement that reads You may find output and logs in the... directory. Save this information to a notepad for future reference. Install the scheduling service by executing the following command: cpd-cli manage apply-scheduler \\ --release = ${ VERSION } \\ --license_acceptance = true \\ --scheduler_ns = ${ PROJECT_SCHEDULING_SERVICE } This operation will take approximately 10 minutes to complete. After a successful operation, the console will return the following statements: [ SUCCESS ] 2025 -03-19T19:14:17.855196Z You may find output and logs in the <REDACTED> directory. [ SUCCESS ] 2025 -03-19T19:14:17.855280Z The apply-scheduler command ran successfully.","title":"i. Install shared components"},{"location":"on-premises/6/#ii-install-an-instance-of-ibm-software-hub","text":"Finally, the cluster has been prepared to a state where it is ready to install an instance of IBM Software Hub. Although the following section requires relatively few inputs from the participant, it will take approximately 45 minutes for the installation process to complete. Create the two new projects that will host your instance by executing the following instructions within a Terminal console: oc new-project ${ PROJECT_CPD_INST_OPERATORS } oc new-project ${ PROJECT_CPD_INST_OPERANDS } Apply the required permissions for an instance of IBM Software Hub: cpd-cli manage authorize-instance-topology \\ --cpd_operator_ns = ${ PROJECT_CPD_INST_OPERATORS } \\ --cpd_instance_ns = ${ PROJECT_CPD_INST_OPERANDS } This operation will take approximately 2 minutes to complete. After a successful operation, the console will return the following statements: [ SUCCESS ] 2025 -03-19T19:17:06.452627Z You may find output and logs in the <REDACTED> directory. [ SUCCESS ] 2025 -03-19T19:17:06.453087Z The authorize-instance-topology command ran successfully. Create the instance by executing the following code block: cpd-cli manage setup-instance \\ --release = ${ VERSION } \\ --license_acceptance = true \\ --cpd_operator_ns = ${ PROJECT_CPD_INST_OPERATORS } \\ --cpd_instance_ns = ${ PROJECT_CPD_INST_OPERANDS } \\ --block_storage_class = ${ STG_CLASS_BLOCK } \\ --file_storage_class = ${ STG_CLASS_FILE } \\ --run_storage_tests = true This operation will take approximately 45 minutes to complete, after which the console will return: [ SUCCESS ] The cpd management server was successfully created in the cpd-watsonx project [ SUCCESS ] 2025 -03-18T00:09:51.194282Z You may find output and logs in the <REDACTED> directory. [ SUCCESS ] 2025 -03-18T00:09:51.194342Z The setup-instance command ran successfully. Examine the last series of console messages just prior to the three [SUCCESS] statements made after the execution of Step 6 . Record the name of the last deployment made to the cluster just prior to those [SUCCESS] statements. Save this information to a notepad for future reference.","title":"ii. Install an instance of IBM Software Hub"},{"location":"on-premises/6/#iii-next-steps","text":"With IBM Software Hub now successfully deployed on the OCP cluster, the environment is primed for the installation of IBM watsonx Code Assistant. TROUBLESHOOTING: LOGGING IN AND SESSION TIMEOUTS Be aware that SSH connections made over Terminal will time out after a long period of inactivity or due to a connection error. If you need to log back into the bastion terminal, follow the procedure below. Replace the <BASTION_PWD> placeholder with the password specific to your environment. Log back into the bastion node: ssh itzuser@api.67828ca5e432cac47ccc4230.ocp.techzone.ibm.com -p 40222 <BASTION_PWD> Engage the sudo (privileged access) session: sudo bash Source the environment variables stored in cpd_vars.sh : source cpd_vars.sh Log back into OpenShift: ${ OC_LOGIN } Log back into cpd-cli : ${ CPDM_OC_LOGIN }","title":"iii. Next steps"},{"location":"on-premises/7/","text":"Install IBM watsonx Code Assistant On-Premises Installation and Deployment The following section is based off of IBM Documentation for Installing watsonx Code Assistant v5.1.x . i. User responsibilities Following the release of IBM Software Hub v5.x , watsonx Code Assistant (WCA) administrators need to only specify the watsonx-code-assistant component in order for the Software Hub to automatically fetch the required dependencies. To install WCA on-premises, you must be an instance administrator with permissions to install software in the following Red Hat OpenShift projects: The operators project for the instance: Operators for this instance of WCA are installed in the operators project. In the installation commands, the ${PROJECT_CPD_INST_OPERATORS} environment variable refers to the operators project. The operands project for the instance: The custom resources for the control plane and WCA are installed in the operands project. In the installation commands, the ${PROJECT_CPD_INST_OPERANDS} environment variable refers to the operands project. ii. System requirements Participants are encouraged to review the following requirements again before continuing with the install to verify that all the components are in place and to reinforce their understanding as to why such components are needed. IBM SOFTWARE HUB VERSIONING All of the components that are associated with an instance of IBM Software Hub must be installed at the same release version. For example, if the IBM Software Hub control plane is installed at Version 5.1.0 , you must install WCA at Version 5.1.0 as well. ENVIRONMENT VARIABLES The commands in this task use environment variables so that you can run the commands exactly as written. In the case of this lab, those variables are defined within the cpd_vars.sh manifest that was created in Module 3 . If you want to read more about how to structure scripts like cpd_vars.sh , which define environment variables within a single source of truth, review the IBM Documentation . To use the environment variables from the script, you must source the environment variables before you run the commands in this task. For example, run: source cpd_vars.sh SECURITY CONTEXT CONSTRAINT WCA works with the default Red Hat OpenShift\u00ae Container Platform security context constraint, restricted-v2 . COMMON CORE SERVICES WCA requires the availability of IBM Software Hub common core services. If the common core services are not installed in the operands project for the instance, the common core services are automatically installed when you install WCA. The common core services installation increases the amount of time the installation takes to complete. STORAGE Storage classes must be specified ahead of time when installing WCA. The following storage classes are recommended. However, if you don't use these particular storage classes on future cluster deployments, ensure that you specify a storage class with an equivalent definition. Storage Notes Storage Classes OpenShift Data Foundation When you install the service, specify file storage and block storage. File storage: ocs-storagecluster-cephfs Block storage: ocs-storagecluster-ceph-rbd IBM Fusion Data Foundation When you install the service, specify file storage and block storage. File storage: ocs-storagecluster-cephfs Block storage: ocs-storagecluster-ceph-rbd IBM Fusion Global Data Platform When you install the service, specify the same storage class for both file storage and block storage. File storage: ibm-spectrum-scale-sc or ibm-storage-fusion-cp-sc Block storage: ibm-spectrum-scale-sc or ibm-storage-fusion-cp-sc IBM Storage Scale Container Native When you install the service, specify the same storage class for both file storage and block storage. File storage: ibm-spectrum-scale-sc Block storage: ibm-spectrum-scale-sc Portworx When you install the service, the --storage_vendor=portworx option ensures that the service uses the correct storage classes. File storage: portworx-shared-gp3 Block storage: portworx-elastic-sc NFS When you install the service, specify the same storage class for both file storage and block storage. File storage: managed-nfs-storage Block storage: managed-nfs-storage Amazon Elastic storage When you install the service, specify file storage and block storage. File storage is provided by Amazon Elastic File System. Block storage is provided by Amazon Elastic Block Store. File storage: efs-nfs-client Block storage: gp2-csi or gp3-csi NetApp Trident When you install the service, specify the same storage class for both file storage and block storage. File storage: ontap-nas Block storage: ontap-nas Nutanix Not supported. Not applicable. iii. Deployment checklist To review, the following tasks need to be completed before installing WCA on-premises. The various modules of this hands-on lab have already covered those applicable to the environment you are about to deploy. However, keep this checklist handy for future deployments you will be making with clients and in the field. Prerequisite Documentation The cluster meets the minimum requirements for installing WCA. System requirements The workstation from which you will run the installation is set up as a client workstation and includes the following command-line interfaces: IBM Software Hub CLI ( cpd-cli ) and OpenShift CLI ( oc ) Setting up a client workstation The IBM Software Hub control plane is installed. Installing an instance of IBM Software Hub For environments that use a private container registry, such as air-gapped environments, the WCA software images are mirrored to the private container registry. Mirroring images to a private container registry For environments that use a private container registry, such as air-gapped environments, the cpd-cli is configured to pull the olm-utils-v3 image from the private container registry. Pulling the olm-utils-v3 image from the private container registry The operators that are required to use GPUs are installed. Installing operators for services that require GPUs Red Hat OpenShift AI is installed. Installing Red Hat OpenShift AI iv. Fetching dependencies In the following section, participants will assume the role of an instance administrator and install WCA using the IBM Software Hub components set up in the previous module. Apply the entitlement for WCA by executing the following code block: cpd-cli manage apply-entitlement \\ --cpd_instance_ns = ${ PROJECT_CPD_INST_OPERANDS } \\ --entitlement = watsonx-code-assistant \\ --production = true Completion of this operation will take approximately 1 minute , after which the console will return: [ SUCCESS ] 2025 -03-19T23:02:06.847686Z You may find output and logs in the <REDACTED> directory. [ SUCCESS ] 2025 -03-19T23:02:06.847741Z The apply-entitlement command ran successfully. Now that the components have been defined, install the services Operators by executing the following code block: cpd-cli manage apply-olm \\ --release = ${ VERSION } \\ --cpd_operator_ns = ${ PROJECT_CPD_INST_OPERATORS } \\ --components = ${ COMPONENTS } Completion of this operation will take approximately 15 minutes , after which the console will return: [ SUCCESS ] 2025 -03-19T23:16:42.690505Z You may find output and logs in the <REDACTED> directory. [ SUCCESS ] 2025 -03-19T23:16:42.690774Z The apply-olm command ran successfully. Record the final automation task performed just prior to (the line before) the two [SUCCESS] messages returned by the console. Save this information to a notepad for future reference. v. Installing software Creating the custom resources for watsonx Code Assistant and kicking off the installation process is achieved with relatively few inputs from the administrator, but will still require several hours to resolve. Start the installation process for WCA by executing the following code block: cpd-cli manage apply-cr \\ --release = ${ VERSION } \\ --cpd_instance_ns = ${ PROJECT_CPD_INST_OPERANDS } \\ --components = ${ COMPONENTS } \\ --block_storage_class = ${ STG_CLASS_BLOCK } \\ --file_storage_class = ${ STG_CLASS_FILE } \\ --license_acceptance = true Completion of this operation may take up to 2 hours , after which the console will return: [ SUCCESS ] ... The apply-cr command ran successfully TROUBLESHOOTING: CONNECTION TIMED OUT The time needed for the operation to complete means that participant's Terminal connections to the OCP cluster will likely time out (due to inactivity) before the installation and deployment have concluded. Do not worry - the installation will continue even if the SSH connection with Terminal is interrupted. To re-authenticate with the cluster, follow the Troubleshooting: Logging in and session timeouts instructions below. Once the installation procedure of Step 3 has wrapped up, retrieve the details about the WCA instance by executing the following: cpd-cli manage get-cpd-instance-details \\ --cpd_instance_ns = ${ PROJECT_CPD_INST_OPERANDS } \\ --get_admin_initial_credentials = true The console will return multiple lines. Take note of the lines with headers CPD Url , CPD Username , and CPD Password . These have been highlighted in the code sample below. Copy the three variables from your Terminal's output to a notepad for reference later. [ INFO ] 2025 -03-20T03:20:17.481851Z Run command: podman exec -it olm-utils-play-v3 get-cpd-instance-details --cpd_instance_ns = cpd-watsonx --get_admin_initial_credentials = true CPD Url: cpd-cpd-watsonx.apps.67da04cc1b2e441b1d48a668.ocp.techzone.ibm.com CPD Username: cpadmin CPD Password: xEhwFROJ5rAL4DZ3ggTNKzlREXDYDYHU [ SUCCESS ] 2025 -03-20T03:20:18.949702Z You may find output and logs in the <REDACTED> directory. [ SUCCESS ] 2025 -03-20T03:20:18.949759Z The get-cpd-instance-details command ran successfully. Using a web browser, navigate to the address specified by CPU Url . A page will load for the Administration Console which allows administrators to manage both their IBM Software Hub (CP4D) and IBM watsonx Code Assistant environments. Supply the CPD Username [A] and CPD Password [B] values recorded in Step 4 Click Login in [C] to proceed The web browser will load the IBM Software Hub dashboard, from which a number of administrative and monitoring options are available for you to inspect Verify that the IBM watsonx Code Assistant service was successfully installed: From the dashboard's navigation menu, drill down into Services > Services catalog [A] Search for the IBM watsonx Code Assistant service tile and confirm it is marked with a status of Enabled Click [B] on the tile to preview the service The web browser will load what essentially resembles the \"catalog\" view you might encounter on a online store portal such as IBM Cloud \u2014 this is not the administrative portal used for managing the WCA service To access the WCA management console, look to the top-right corner of the IBM Software Hub dashboard and click [A] the rectangular-dot icon. This will allow you to toggle between the Software Hub and WCA administrative portals. Click [B] the IBM watsonx Code Assistant button to switch portals The administrative portal for WCA will load within the web browser vi. Conclusion Congratulations \u2014 you have successfully completed the installation of IBM watsonx Code Assistant within an on-premises environment! Explore and inspect various aspects of the on-premises environment as you wish, but keep in mind that without GPUs attached to the environment you will be significantly restricted in terms of usability. Some features may be unavailable or broken without such hardware. That is why for the Application Modernization hands-on modules, you will have full GPU access via the provided IBM Cloud environments. Those modules will delve deeply into the administrative and developer-oriented tasks that are limited for the on-premises environment. GPUs NOT SUPPORTED FOR L4 ON-PREMISES DEPLOYMENTS Resource and budget constraints for IBM Technology Zone and the IBM Enablement teams means that GPUs are unavailable for the on-premises portion of the Level 4 curriculum. The NVIDIA A100 or H100 GPUs required are simply too cost-prohibitive to be made available for individual IBMers and business partners. GPUs cannot be shared in a multi-tenant access pattern for IBM watsonx Code Assistant \u2014 and, as such, at minimum two cards would need to be made available for every L4 reservation. These costs are beyond the scope of what can be supported by this training. Participants will have access to GPUs for the IBM Cloud (SaaS) portion of the Level 4 curriculum. TROUBLESHOOTING: LOGGING IN AND SESSION TIMEOUTS Be aware that SSH connections made over Terminal will time out after a long period of inactivity or due to a connection error. If you need to log back into the bastion terminal, follow the procedure below. Replace the <BASTION_PWD> placeholder with the password specific to your environment. Log back into the bastion node: ssh itzuser@api.67828ca5e432cac47ccc4230.ocp.techzone.ibm.com -p 40222 <BASTION_PWD> Engage the sudo (privileged access) session: sudo bash Source the environment variables stored in cpd_vars.sh : source cpd_vars.sh Log back into OpenShift: ${ OC_LOGIN } Log back into cpd-cli : ${ CPDM_OC_LOGIN }","title":"7. Install watsonx Code Assistant"},{"location":"on-premises/7/#install-ibm-watsonx-code-assistanton-premises-installation-and-deployment","text":"The following section is based off of IBM Documentation for Installing watsonx Code Assistant v5.1.x .","title":"Install IBM watsonx Code AssistantOn-Premises Installation and Deployment"},{"location":"on-premises/7/#i-user-responsibilities","text":"Following the release of IBM Software Hub v5.x , watsonx Code Assistant (WCA) administrators need to only specify the watsonx-code-assistant component in order for the Software Hub to automatically fetch the required dependencies. To install WCA on-premises, you must be an instance administrator with permissions to install software in the following Red Hat OpenShift projects: The operators project for the instance: Operators for this instance of WCA are installed in the operators project. In the installation commands, the ${PROJECT_CPD_INST_OPERATORS} environment variable refers to the operators project. The operands project for the instance: The custom resources for the control plane and WCA are installed in the operands project. In the installation commands, the ${PROJECT_CPD_INST_OPERANDS} environment variable refers to the operands project.","title":"i. User responsibilities"},{"location":"on-premises/7/#ii-system-requirements","text":"Participants are encouraged to review the following requirements again before continuing with the install to verify that all the components are in place and to reinforce their understanding as to why such components are needed. IBM SOFTWARE HUB VERSIONING All of the components that are associated with an instance of IBM Software Hub must be installed at the same release version. For example, if the IBM Software Hub control plane is installed at Version 5.1.0 , you must install WCA at Version 5.1.0 as well. ENVIRONMENT VARIABLES The commands in this task use environment variables so that you can run the commands exactly as written. In the case of this lab, those variables are defined within the cpd_vars.sh manifest that was created in Module 3 . If you want to read more about how to structure scripts like cpd_vars.sh , which define environment variables within a single source of truth, review the IBM Documentation . To use the environment variables from the script, you must source the environment variables before you run the commands in this task. For example, run: source cpd_vars.sh SECURITY CONTEXT CONSTRAINT WCA works with the default Red Hat OpenShift\u00ae Container Platform security context constraint, restricted-v2 . COMMON CORE SERVICES WCA requires the availability of IBM Software Hub common core services. If the common core services are not installed in the operands project for the instance, the common core services are automatically installed when you install WCA. The common core services installation increases the amount of time the installation takes to complete. STORAGE Storage classes must be specified ahead of time when installing WCA. The following storage classes are recommended. However, if you don't use these particular storage classes on future cluster deployments, ensure that you specify a storage class with an equivalent definition. Storage Notes Storage Classes OpenShift Data Foundation When you install the service, specify file storage and block storage. File storage: ocs-storagecluster-cephfs Block storage: ocs-storagecluster-ceph-rbd IBM Fusion Data Foundation When you install the service, specify file storage and block storage. File storage: ocs-storagecluster-cephfs Block storage: ocs-storagecluster-ceph-rbd IBM Fusion Global Data Platform When you install the service, specify the same storage class for both file storage and block storage. File storage: ibm-spectrum-scale-sc or ibm-storage-fusion-cp-sc Block storage: ibm-spectrum-scale-sc or ibm-storage-fusion-cp-sc IBM Storage Scale Container Native When you install the service, specify the same storage class for both file storage and block storage. File storage: ibm-spectrum-scale-sc Block storage: ibm-spectrum-scale-sc Portworx When you install the service, the --storage_vendor=portworx option ensures that the service uses the correct storage classes. File storage: portworx-shared-gp3 Block storage: portworx-elastic-sc NFS When you install the service, specify the same storage class for both file storage and block storage. File storage: managed-nfs-storage Block storage: managed-nfs-storage Amazon Elastic storage When you install the service, specify file storage and block storage. File storage is provided by Amazon Elastic File System. Block storage is provided by Amazon Elastic Block Store. File storage: efs-nfs-client Block storage: gp2-csi or gp3-csi NetApp Trident When you install the service, specify the same storage class for both file storage and block storage. File storage: ontap-nas Block storage: ontap-nas Nutanix Not supported. Not applicable.","title":"ii. System requirements"},{"location":"on-premises/7/#iii-deployment-checklist","text":"To review, the following tasks need to be completed before installing WCA on-premises. The various modules of this hands-on lab have already covered those applicable to the environment you are about to deploy. However, keep this checklist handy for future deployments you will be making with clients and in the field. Prerequisite Documentation The cluster meets the minimum requirements for installing WCA. System requirements The workstation from which you will run the installation is set up as a client workstation and includes the following command-line interfaces: IBM Software Hub CLI ( cpd-cli ) and OpenShift CLI ( oc ) Setting up a client workstation The IBM Software Hub control plane is installed. Installing an instance of IBM Software Hub For environments that use a private container registry, such as air-gapped environments, the WCA software images are mirrored to the private container registry. Mirroring images to a private container registry For environments that use a private container registry, such as air-gapped environments, the cpd-cli is configured to pull the olm-utils-v3 image from the private container registry. Pulling the olm-utils-v3 image from the private container registry The operators that are required to use GPUs are installed. Installing operators for services that require GPUs Red Hat OpenShift AI is installed. Installing Red Hat OpenShift AI","title":"iii. Deployment checklist"},{"location":"on-premises/7/#iv-fetching-dependencies","text":"In the following section, participants will assume the role of an instance administrator and install WCA using the IBM Software Hub components set up in the previous module. Apply the entitlement for WCA by executing the following code block: cpd-cli manage apply-entitlement \\ --cpd_instance_ns = ${ PROJECT_CPD_INST_OPERANDS } \\ --entitlement = watsonx-code-assistant \\ --production = true Completion of this operation will take approximately 1 minute , after which the console will return: [ SUCCESS ] 2025 -03-19T23:02:06.847686Z You may find output and logs in the <REDACTED> directory. [ SUCCESS ] 2025 -03-19T23:02:06.847741Z The apply-entitlement command ran successfully. Now that the components have been defined, install the services Operators by executing the following code block: cpd-cli manage apply-olm \\ --release = ${ VERSION } \\ --cpd_operator_ns = ${ PROJECT_CPD_INST_OPERATORS } \\ --components = ${ COMPONENTS } Completion of this operation will take approximately 15 minutes , after which the console will return: [ SUCCESS ] 2025 -03-19T23:16:42.690505Z You may find output and logs in the <REDACTED> directory. [ SUCCESS ] 2025 -03-19T23:16:42.690774Z The apply-olm command ran successfully. Record the final automation task performed just prior to (the line before) the two [SUCCESS] messages returned by the console. Save this information to a notepad for future reference.","title":"iv. Fetching dependencies"},{"location":"on-premises/7/#v-installing-software","text":"Creating the custom resources for watsonx Code Assistant and kicking off the installation process is achieved with relatively few inputs from the administrator, but will still require several hours to resolve. Start the installation process for WCA by executing the following code block: cpd-cli manage apply-cr \\ --release = ${ VERSION } \\ --cpd_instance_ns = ${ PROJECT_CPD_INST_OPERANDS } \\ --components = ${ COMPONENTS } \\ --block_storage_class = ${ STG_CLASS_BLOCK } \\ --file_storage_class = ${ STG_CLASS_FILE } \\ --license_acceptance = true Completion of this operation may take up to 2 hours , after which the console will return: [ SUCCESS ] ... The apply-cr command ran successfully TROUBLESHOOTING: CONNECTION TIMED OUT The time needed for the operation to complete means that participant's Terminal connections to the OCP cluster will likely time out (due to inactivity) before the installation and deployment have concluded. Do not worry - the installation will continue even if the SSH connection with Terminal is interrupted. To re-authenticate with the cluster, follow the Troubleshooting: Logging in and session timeouts instructions below. Once the installation procedure of Step 3 has wrapped up, retrieve the details about the WCA instance by executing the following: cpd-cli manage get-cpd-instance-details \\ --cpd_instance_ns = ${ PROJECT_CPD_INST_OPERANDS } \\ --get_admin_initial_credentials = true The console will return multiple lines. Take note of the lines with headers CPD Url , CPD Username , and CPD Password . These have been highlighted in the code sample below. Copy the three variables from your Terminal's output to a notepad for reference later. [ INFO ] 2025 -03-20T03:20:17.481851Z Run command: podman exec -it olm-utils-play-v3 get-cpd-instance-details --cpd_instance_ns = cpd-watsonx --get_admin_initial_credentials = true CPD Url: cpd-cpd-watsonx.apps.67da04cc1b2e441b1d48a668.ocp.techzone.ibm.com CPD Username: cpadmin CPD Password: xEhwFROJ5rAL4DZ3ggTNKzlREXDYDYHU [ SUCCESS ] 2025 -03-20T03:20:18.949702Z You may find output and logs in the <REDACTED> directory. [ SUCCESS ] 2025 -03-20T03:20:18.949759Z The get-cpd-instance-details command ran successfully. Using a web browser, navigate to the address specified by CPU Url . A page will load for the Administration Console which allows administrators to manage both their IBM Software Hub (CP4D) and IBM watsonx Code Assistant environments. Supply the CPD Username [A] and CPD Password [B] values recorded in Step 4 Click Login in [C] to proceed The web browser will load the IBM Software Hub dashboard, from which a number of administrative and monitoring options are available for you to inspect Verify that the IBM watsonx Code Assistant service was successfully installed: From the dashboard's navigation menu, drill down into Services > Services catalog [A] Search for the IBM watsonx Code Assistant service tile and confirm it is marked with a status of Enabled Click [B] on the tile to preview the service The web browser will load what essentially resembles the \"catalog\" view you might encounter on a online store portal such as IBM Cloud \u2014 this is not the administrative portal used for managing the WCA service To access the WCA management console, look to the top-right corner of the IBM Software Hub dashboard and click [A] the rectangular-dot icon. This will allow you to toggle between the Software Hub and WCA administrative portals. Click [B] the IBM watsonx Code Assistant button to switch portals The administrative portal for WCA will load within the web browser","title":"v. Installing software"},{"location":"on-premises/7/#vi-conclusion","text":"Congratulations \u2014 you have successfully completed the installation of IBM watsonx Code Assistant within an on-premises environment! Explore and inspect various aspects of the on-premises environment as you wish, but keep in mind that without GPUs attached to the environment you will be significantly restricted in terms of usability. Some features may be unavailable or broken without such hardware. That is why for the Application Modernization hands-on modules, you will have full GPU access via the provided IBM Cloud environments. Those modules will delve deeply into the administrative and developer-oriented tasks that are limited for the on-premises environment. GPUs NOT SUPPORTED FOR L4 ON-PREMISES DEPLOYMENTS Resource and budget constraints for IBM Technology Zone and the IBM Enablement teams means that GPUs are unavailable for the on-premises portion of the Level 4 curriculum. The NVIDIA A100 or H100 GPUs required are simply too cost-prohibitive to be made available for individual IBMers and business partners. GPUs cannot be shared in a multi-tenant access pattern for IBM watsonx Code Assistant \u2014 and, as such, at minimum two cards would need to be made available for every L4 reservation. These costs are beyond the scope of what can be supported by this training. Participants will have access to GPUs for the IBM Cloud (SaaS) portion of the Level 4 curriculum. TROUBLESHOOTING: LOGGING IN AND SESSION TIMEOUTS Be aware that SSH connections made over Terminal will time out after a long period of inactivity or due to a connection error. If you need to log back into the bastion terminal, follow the procedure below. Replace the <BASTION_PWD> placeholder with the password specific to your environment. Log back into the bastion node: ssh itzuser@api.67828ca5e432cac47ccc4230.ocp.techzone.ibm.com -p 40222 <BASTION_PWD> Engage the sudo (privileged access) session: sudo bash Source the environment variables stored in cpd_vars.sh : source cpd_vars.sh Log back into OpenShift: ${ OC_LOGIN } Log back into cpd-cli : ${ CPDM_OC_LOGIN }","title":"vi. Conclusion"},{"location":"saas/1/","text":"Objectives and requirements IBM Cloud (SaaS) Configuration i. About this lab For the purposes of the Level 4 training curriculum, the hands-on components have been split across both on-premises and Software-as-a-Service (SaaS) environments on IBM Cloud. Both are supported by IBM Technology Zone (ITZ) infrastructure. The On-Premises Installation and Deployment modules extensively covers the process of preparing, installing, and deploying a full-stack IBM watsonx Code Assistant (WCA) service \"on-premises\" (OpenShift on VMware). However, resource and budget constraints for ITZ team means that GPUs are unavailable for on-premises training environments like the one deployed in those modules. The NVIDIA A100 or H100 GPUs required are simply too cost-prohibitive to be made available for individual IBMers and business partners. These costs are beyond the scope of what can be supported for training with on-premises environments. Fortunately, participants do have access to GPUs for SaaS training environments on IBM Cloud. The IBM Cloud (SaaS) Configuration module will guide participants through the process of reserving the necessary Standard plan of WCA via ITZ and configuring the environment for use. Other modules in the L4 curriculum ( Application Modernization ) will each leverage the SaaS environment configured in the following steps. There are two tiers of plans (editions) available for SaaS deployments of WCA: Plan Details Use Cases ESSENTIALS PLAN Accelerates software development, allowing developers to use WCA with integrated generative AI (gen AI) for coding. Generating, explaining, and documenting code. Creation of unit tests. STANDARD PLAN In addition to all the capabilities found in the Essentials plan, the Standard plan includes enterprise Java modernization capabilities, which will be of particular advantage for the Application Modernization modules of the Level 4 curriculum. Java upgrades, regardless of runtime. WebSphere to Liberty transformation. Enhanced unit test generation and code explanation. To ensure that participants have access to the enterprise Java modernization capabilities, the instructions of this module call for provisioning a WCA Standard Plan as the basis of the SaaS environment. ii. Prerequisites There are two high-level architectural components to WCA Standard Plan: WCA extension : The interface through which developers interact with WCA, in the form of an extension (sometimes called a \"plug-in\") running in an integrated development environment (IDE). The IDEs currently supported by WCA are Visual Studio Code (VS Code) and Eclipse. WCA service: The back-end WCA service, to which requests from the extension are made and the results returned to the participant's IDE. It is available as software-as-a-service (SaaS) on IBM Cloud and as deployable software for on-premises deployments. Participants require access to ITZ in order to reserve an environment and complete the hands-on work. If you do not yet have an account with the ITZ, you will need to register for one . iii. Troubleshooting and support If you require assistance or run into issues with the hands-on lab, help is available. Environment issues: The lab environment is managed by IBM Technology Zone. Opening a support case ticket is recommended for issues related to the hands-on environment (provisioning, running, and so on.) Product questions: For questions related to IBM watsonx Code Assistant capabilities, sales opportunities, roadmap, and other such matters, open a thread on the #watsonx-code-assistant Slack channel. iv. Next steps In the following section, participants will prepare the SaaS-based lab environment with the necessary services and configurations through IBM Technology Zone.","title":"1. Objectives and requirements"},{"location":"saas/1/#objectives-and-requirementsibm-cloud-saas-configuration","text":"","title":"Objectives and requirementsIBM Cloud (SaaS) Configuration"},{"location":"saas/1/#i-about-this-lab","text":"For the purposes of the Level 4 training curriculum, the hands-on components have been split across both on-premises and Software-as-a-Service (SaaS) environments on IBM Cloud. Both are supported by IBM Technology Zone (ITZ) infrastructure. The On-Premises Installation and Deployment modules extensively covers the process of preparing, installing, and deploying a full-stack IBM watsonx Code Assistant (WCA) service \"on-premises\" (OpenShift on VMware). However, resource and budget constraints for ITZ team means that GPUs are unavailable for on-premises training environments like the one deployed in those modules. The NVIDIA A100 or H100 GPUs required are simply too cost-prohibitive to be made available for individual IBMers and business partners. These costs are beyond the scope of what can be supported for training with on-premises environments. Fortunately, participants do have access to GPUs for SaaS training environments on IBM Cloud. The IBM Cloud (SaaS) Configuration module will guide participants through the process of reserving the necessary Standard plan of WCA via ITZ and configuring the environment for use. Other modules in the L4 curriculum ( Application Modernization ) will each leverage the SaaS environment configured in the following steps. There are two tiers of plans (editions) available for SaaS deployments of WCA: Plan Details Use Cases ESSENTIALS PLAN Accelerates software development, allowing developers to use WCA with integrated generative AI (gen AI) for coding. Generating, explaining, and documenting code. Creation of unit tests. STANDARD PLAN In addition to all the capabilities found in the Essentials plan, the Standard plan includes enterprise Java modernization capabilities, which will be of particular advantage for the Application Modernization modules of the Level 4 curriculum. Java upgrades, regardless of runtime. WebSphere to Liberty transformation. Enhanced unit test generation and code explanation. To ensure that participants have access to the enterprise Java modernization capabilities, the instructions of this module call for provisioning a WCA Standard Plan as the basis of the SaaS environment.","title":"i. About this lab"},{"location":"saas/1/#ii-prerequisites","text":"There are two high-level architectural components to WCA Standard Plan: WCA extension : The interface through which developers interact with WCA, in the form of an extension (sometimes called a \"plug-in\") running in an integrated development environment (IDE). The IDEs currently supported by WCA are Visual Studio Code (VS Code) and Eclipse. WCA service: The back-end WCA service, to which requests from the extension are made and the results returned to the participant's IDE. It is available as software-as-a-service (SaaS) on IBM Cloud and as deployable software for on-premises deployments. Participants require access to ITZ in order to reserve an environment and complete the hands-on work. If you do not yet have an account with the ITZ, you will need to register for one .","title":"ii. Prerequisites"},{"location":"saas/1/#iii-troubleshooting-and-support","text":"If you require assistance or run into issues with the hands-on lab, help is available. Environment issues: The lab environment is managed by IBM Technology Zone. Opening a support case ticket is recommended for issues related to the hands-on environment (provisioning, running, and so on.) Product questions: For questions related to IBM watsonx Code Assistant capabilities, sales opportunities, roadmap, and other such matters, open a thread on the #watsonx-code-assistant Slack channel.","title":"iii. Troubleshooting and support"},{"location":"saas/1/#iv-next-steps","text":"In the following section, participants will prepare the SaaS-based lab environment with the necessary services and configurations through IBM Technology Zone.","title":"iv. Next steps"},{"location":"saas/2/","text":"Reserve an environment IBM Cloud (SaaS) Configuration The following section is partially based on IBM Cloud Documentation for Setting up your watsonx Code Assistant service in IBM Cloud . Some of the configuration steps\u2014 such as creation of an access group and adding an access group to the deployment space -are automatically handled by IBM Technology Zone provisioning tasks. As such, if you are repeating this deployment for a client production environment, you may wish to reference the complete documentation set. i. IBM Technology Zone The following steps will guide participants through the process for requesting access to an IBM watsonx Code Assistant (WCA) Standard Plan environment from IBM Technology Zone (ITZ). Open the ITZ collection at the following address: URL: https://techzone.ibm.com/collection/wca/environments There are multiple templates and flavors of WCA available: Locate the Request watsonx Code Assistant - Standard [A] tile Hover over and click the IBM Cloud environment / Reserve It [B] button When prompted, click the Reserve an environment button Supply additional details about the ITZ reservation request: Field Value Name Assign the reservation a unique name. Purpose Education Purpose Description Assign the reservation a unique description. Preferred Geography Select the region and data center closest to your location. Start Date and Time Select a time and date for when the reservation will begin. End Date and Time Select a time and date for when the reservation will expire. When ready, verify that you agree to the Terms and Conditions for the environment and finalize your reservation request by clicking Submit [A] . Navigate to the My Reservations tab of the ITZ to monitor the progress. Initially, the request will be marked as Scheduled or Provisioning [A] . Wait for the ITZ reservation to be marked as Ready before continuing to Step 5 Scheduled: marked in grey, the reservation is awaiting approval from ITZ Provisioning: marked in yellow, the reservation is being deployed Ready: marked in green, the reservation has successfully deployed ii. Accessing the service details Once the WCA service has been provisioned, you will receive two emails with the following headers: Reservation Ready on IBM Technology Zone: indicates that the ITZ cluster has been successfully provisioned Account: Action required: You are invited to join an account in IBM Cloud: additional steps required by the administrator (you) in order to link the WCA service to IBM Cloud Steps must be taken to link the WCA service and IBM Cloud accounts at this time. Click the Join now [A] button within the body of the Account: Action required: You are invited to join an account in IBM Cloud email A web browser tab will launch and redirect to IBM Cloud Check the I accept the product Terms and Conditions of this registration form [A] box under the Account Notice header, then click Join account [B] to continue. You will be presented with a prompt asking for your permission to switch your personal IBM Cloud account's view into the WCA service (ITZ-provisioned) IBM Cloud account \u2014 which will resemble something like itz-watsonx-24 . Click Proceed [A] to confirm. LOCATING THE ITZ-PROVISIONED ACCOUNT NAME Participants can retrieve the name of the ITZ-provisioned WCA service account ( itz-watsonx-24 , etc.) by looking at the contents of the Account: Action required: You are invited to join an account in IBM Cloud email: IBM Technology Zone invited you to join the following IBM Cloud account: itz-watsonx-... The IBM Cloud dashboard will now load within your web browser. At this time, confirm you are logged in under the WCA service account by inspecting the drop-down menu [A] as shown in the screenshot below. SWITCHING BETWEEN IBM CLOUD ACCOUNTS You can toggle between various IBM Cloud accounts at-will. However, for the purposes of this lab it's best that you remain under the WCA service [B] account. Open a new web browser tab and navigate to the My Reservations ITZ page to inspect the details of your newly-provisioned service (or follow the link provided in the Reservation Ready on IBM Technology Zone ) email. Click on the newly-provisioned service's tile [A] to inspect the environment's access and authentication details. Scroll down the page to the Reservations Details section and locate the following values. You will need to record these to a notepad for future reference. IBM Cloud Service ID [A] IBM Cloud API key [B] WCA URL [C] Open a new browser tab and navigate to the WCA URL recorded in Step 10. A Resource list view on IBM Cloud will load Click the Launch watsonx Code Assistant [A] button to continue iii. Configuring the environment A new tab will load to present the WCA Dashboard , which for a first-time login will automatically prompt you to configure the environment. When presented with the Set up watsonx Code Assistant for Standard plan panel, click on the Set up [A] button to continue. Type of installation configuration options must be configured. Select Single user [A] . Having specified the installation type, more options will unlock further down the page under the Steps to complete header. Click the blue arrow [A] icon to the right of the Create a deployment space option. Configure the Create a deployment space page as follows: Name [A] : Assign a name of your choosing to the deployment space (e.g. wca-l4 ) Description [B] : Optional Select storage service [C] : Do not change. IBM Technology Zone has automatically assigned Cloud Object Storage space for this reservation. Code assistant service [D] : Click the drop-down menu and select the WCA service belonging to your account. All other fields can remain as their default values. When ready, click Create [E] and remain on the page for the deployment to finish. Once the deployment space has been prepared, a pop-up alert will display \"The space is ready\" . Click the X [A] icon in the top-right corner to dismiss the message and continue with the configuration steps. The web browser will return to the set up wizard, which now displays additional options under the Steps to complete section. Notice that the Create a deployment space step has been marked as complete. Click the blue arrow [A] icon to the right of the Select your license preference for response generations option to continue. The Display of Code Suggestions page permits users to configure how to display code suggestions returned by the WCA service. Do not change any of the settings, but you are welcome to review them if you wish Close the page and return to the set up wizard Check [A] the box to the left of the Select your license preference for response generations option to mark the task as complete. A prompt will appear to indicate that all setup tasks are now complete Click the Go to home page [B] button to conclude the setup iv. Create a service ID and API key Participants will use this API key later to enable Visual Studio Code extensions or Eclipse IDE plug-ins to communicate with the WCA service. Open a new web browser tab and navigate to the IBM Cloud Service IDs admin page. Verify that the Service IDs [A] tab is open and that the Resource Group [B] is set to the ITZ-provisioned WCA account (Steps 7-8) Click Create service ID [C] to continue Set the Name [A] field equal to IBM watsonx Code Assistant user or another name of your choosing. Click the Create [B] button to continue. From the tabs along the left side of the page, click API Keys [A] . Once it loads, click Create [B] to continue. Create a new IBM Cloud API Key with the following parameters: Name [A] : IBM watsonx Code Assistant API key Leaked action [B] : Disable the leaked key Session creation [C] : No When ready, click Create [D] to finalize the key A prompt will appear reporting that API key successfully created . Click the Copy [A] button and record the WCA API Key to your notebook for reference later It's recommended that you also Download the key as a redundancy When ready, close [B] the window v. Add the service ID to the WCA deployment space With the Service ID and WCA API Key now generated, they need to be associated with your WCA instance \u2014 specifically, the WCA Deployment Space . This will be the way in which the WCA extension (VS Code or Eclipse IDE) communicates with the WCA service. Return to the WCA Dashboard web browser tab (where you left off in Step 19). Click the stacked tiles [A] in the top-left corner of the dashboard to expand the menu items along the left-hand side Click on the Deployments [B] tab Within the table of existing deployments, click the wca-l4 [A] deployment (or whatever name you chose to assign the deployment created in Step 15). From the tabs along the top, click the Manage [A] tab. Then, from the left-hand side options, click the Access control [B] tab. Click the Add collaborators [A] button to expand a list of options, then click Add service IDs [B] to continue. Within the table of Service IDs , you should see 1 entry for the IBM watsonx Code Assistant user that was created in Step 21. Click [A] the box to the left of the ID Click [B] the Role box to the right of the ID and select Editor from the drop-down menu Click Add [C] to finalize the operation Confirm that the IBM watsonx Code Assistant user Service ID now appears within the list of approved Collaborators under the Access Control tab. vi. Next steps The deployment and initial configurations of the watsonx Code Assistant (SaaS) Standard Plan service on IBM Cloud is now complete. In the following modules, participants will prepare the WCA extensions and plug-ins for Visual Studio Code and Eclipse IDE, respectively.","title":"2. Reserve an environment"},{"location":"saas/2/#reserve-an-environmentibm-cloud-saas-configuration","text":"The following section is partially based on IBM Cloud Documentation for Setting up your watsonx Code Assistant service in IBM Cloud . Some of the configuration steps\u2014 such as creation of an access group and adding an access group to the deployment space -are automatically handled by IBM Technology Zone provisioning tasks. As such, if you are repeating this deployment for a client production environment, you may wish to reference the complete documentation set.","title":"Reserve an environmentIBM Cloud (SaaS) Configuration"},{"location":"saas/2/#i-ibm-technology-zone","text":"The following steps will guide participants through the process for requesting access to an IBM watsonx Code Assistant (WCA) Standard Plan environment from IBM Technology Zone (ITZ). Open the ITZ collection at the following address: URL: https://techzone.ibm.com/collection/wca/environments There are multiple templates and flavors of WCA available: Locate the Request watsonx Code Assistant - Standard [A] tile Hover over and click the IBM Cloud environment / Reserve It [B] button When prompted, click the Reserve an environment button Supply additional details about the ITZ reservation request: Field Value Name Assign the reservation a unique name. Purpose Education Purpose Description Assign the reservation a unique description. Preferred Geography Select the region and data center closest to your location. Start Date and Time Select a time and date for when the reservation will begin. End Date and Time Select a time and date for when the reservation will expire. When ready, verify that you agree to the Terms and Conditions for the environment and finalize your reservation request by clicking Submit [A] . Navigate to the My Reservations tab of the ITZ to monitor the progress. Initially, the request will be marked as Scheduled or Provisioning [A] . Wait for the ITZ reservation to be marked as Ready before continuing to Step 5 Scheduled: marked in grey, the reservation is awaiting approval from ITZ Provisioning: marked in yellow, the reservation is being deployed Ready: marked in green, the reservation has successfully deployed","title":"i. IBM Technology Zone"},{"location":"saas/2/#ii-accessing-the-service-details","text":"Once the WCA service has been provisioned, you will receive two emails with the following headers: Reservation Ready on IBM Technology Zone: indicates that the ITZ cluster has been successfully provisioned Account: Action required: You are invited to join an account in IBM Cloud: additional steps required by the administrator (you) in order to link the WCA service to IBM Cloud Steps must be taken to link the WCA service and IBM Cloud accounts at this time. Click the Join now [A] button within the body of the Account: Action required: You are invited to join an account in IBM Cloud email A web browser tab will launch and redirect to IBM Cloud Check the I accept the product Terms and Conditions of this registration form [A] box under the Account Notice header, then click Join account [B] to continue. You will be presented with a prompt asking for your permission to switch your personal IBM Cloud account's view into the WCA service (ITZ-provisioned) IBM Cloud account \u2014 which will resemble something like itz-watsonx-24 . Click Proceed [A] to confirm. LOCATING THE ITZ-PROVISIONED ACCOUNT NAME Participants can retrieve the name of the ITZ-provisioned WCA service account ( itz-watsonx-24 , etc.) by looking at the contents of the Account: Action required: You are invited to join an account in IBM Cloud email: IBM Technology Zone invited you to join the following IBM Cloud account: itz-watsonx-... The IBM Cloud dashboard will now load within your web browser. At this time, confirm you are logged in under the WCA service account by inspecting the drop-down menu [A] as shown in the screenshot below. SWITCHING BETWEEN IBM CLOUD ACCOUNTS You can toggle between various IBM Cloud accounts at-will. However, for the purposes of this lab it's best that you remain under the WCA service [B] account. Open a new web browser tab and navigate to the My Reservations ITZ page to inspect the details of your newly-provisioned service (or follow the link provided in the Reservation Ready on IBM Technology Zone ) email. Click on the newly-provisioned service's tile [A] to inspect the environment's access and authentication details. Scroll down the page to the Reservations Details section and locate the following values. You will need to record these to a notepad for future reference. IBM Cloud Service ID [A] IBM Cloud API key [B] WCA URL [C] Open a new browser tab and navigate to the WCA URL recorded in Step 10. A Resource list view on IBM Cloud will load Click the Launch watsonx Code Assistant [A] button to continue","title":"ii. Accessing the service details"},{"location":"saas/2/#iii-configuring-the-environment","text":"A new tab will load to present the WCA Dashboard , which for a first-time login will automatically prompt you to configure the environment. When presented with the Set up watsonx Code Assistant for Standard plan panel, click on the Set up [A] button to continue. Type of installation configuration options must be configured. Select Single user [A] . Having specified the installation type, more options will unlock further down the page under the Steps to complete header. Click the blue arrow [A] icon to the right of the Create a deployment space option. Configure the Create a deployment space page as follows: Name [A] : Assign a name of your choosing to the deployment space (e.g. wca-l4 ) Description [B] : Optional Select storage service [C] : Do not change. IBM Technology Zone has automatically assigned Cloud Object Storage space for this reservation. Code assistant service [D] : Click the drop-down menu and select the WCA service belonging to your account. All other fields can remain as their default values. When ready, click Create [E] and remain on the page for the deployment to finish. Once the deployment space has been prepared, a pop-up alert will display \"The space is ready\" . Click the X [A] icon in the top-right corner to dismiss the message and continue with the configuration steps. The web browser will return to the set up wizard, which now displays additional options under the Steps to complete section. Notice that the Create a deployment space step has been marked as complete. Click the blue arrow [A] icon to the right of the Select your license preference for response generations option to continue. The Display of Code Suggestions page permits users to configure how to display code suggestions returned by the WCA service. Do not change any of the settings, but you are welcome to review them if you wish Close the page and return to the set up wizard Check [A] the box to the left of the Select your license preference for response generations option to mark the task as complete. A prompt will appear to indicate that all setup tasks are now complete Click the Go to home page [B] button to conclude the setup","title":"iii. Configuring the environment"},{"location":"saas/2/#iv-create-a-service-id-and-api-key","text":"Participants will use this API key later to enable Visual Studio Code extensions or Eclipse IDE plug-ins to communicate with the WCA service. Open a new web browser tab and navigate to the IBM Cloud Service IDs admin page. Verify that the Service IDs [A] tab is open and that the Resource Group [B] is set to the ITZ-provisioned WCA account (Steps 7-8) Click Create service ID [C] to continue Set the Name [A] field equal to IBM watsonx Code Assistant user or another name of your choosing. Click the Create [B] button to continue. From the tabs along the left side of the page, click API Keys [A] . Once it loads, click Create [B] to continue. Create a new IBM Cloud API Key with the following parameters: Name [A] : IBM watsonx Code Assistant API key Leaked action [B] : Disable the leaked key Session creation [C] : No When ready, click Create [D] to finalize the key A prompt will appear reporting that API key successfully created . Click the Copy [A] button and record the WCA API Key to your notebook for reference later It's recommended that you also Download the key as a redundancy When ready, close [B] the window","title":"iv. Create a service ID and API key"},{"location":"saas/2/#v-add-the-service-id-to-the-wca-deployment-space","text":"With the Service ID and WCA API Key now generated, they need to be associated with your WCA instance \u2014 specifically, the WCA Deployment Space . This will be the way in which the WCA extension (VS Code or Eclipse IDE) communicates with the WCA service. Return to the WCA Dashboard web browser tab (where you left off in Step 19). Click the stacked tiles [A] in the top-left corner of the dashboard to expand the menu items along the left-hand side Click on the Deployments [B] tab Within the table of existing deployments, click the wca-l4 [A] deployment (or whatever name you chose to assign the deployment created in Step 15). From the tabs along the top, click the Manage [A] tab. Then, from the left-hand side options, click the Access control [B] tab. Click the Add collaborators [A] button to expand a list of options, then click Add service IDs [B] to continue. Within the table of Service IDs , you should see 1 entry for the IBM watsonx Code Assistant user that was created in Step 21. Click [A] the box to the left of the ID Click [B] the Role box to the right of the ID and select Editor from the drop-down menu Click Add [C] to finalize the operation Confirm that the IBM watsonx Code Assistant user Service ID now appears within the list of approved Collaborators under the Access Control tab.","title":"v. Add the service ID to the WCA deployment space"},{"location":"saas/2/#vi-next-steps","text":"The deployment and initial configurations of the watsonx Code Assistant (SaaS) Standard Plan service on IBM Cloud is now complete. In the following modules, participants will prepare the WCA extensions and plug-ins for Visual Studio Code and Eclipse IDE, respectively.","title":"vi. Next steps"},{"location":"saas/3/","text":"Configure the enterprise Java environment IBM Cloud (SaaS) Configuration i. Objectives and rationale As participants will be working with the IBM watsonx Code Assistant (WCA) Standard Plan and interacting with enterprise Java applications, they will need to perform some additional configuration of their Windows or MacOS machines before setting up the extensions (or plug-ins) to the WCA service. Locally you must install both Java and Apache Maven. Details and download links for the two are summarized in the table below. Java Requirements Distribution Details Resources Java Java SE 11 with Java Developer Kit 21. Download Maven Use Maven to build your application. If you are using Liberty Tools and the Liberty Maven plug-in to build your app or project, use at least Maven 3.8.6. Download ii. Java installation Download and install the v21 of the Java Developer Kit (JDK) using the vendor link below. URL: https://www.oracle.com/java/technologies/downloads/?er=221886#jdk21-mac It is strongly recommended that you install JDK 21 (or as early as JDK 11) Newer-generation MacOS users will probably want to select the ARM64 DMG Installer Follow the prompts of the installation wizard and complete the installation before continuing to Step 2 INCOMPATIBILITY WITH JDK 24 Note that the Full stack modernization module in Application Modernization - WebSphere to Liberty will encounter compatibility errors with JDK 24 drivers when attempting to Explain or Modernize the source application. This is owing to a deprecation of sun.misc.Unsafe method as of March 2025. Additional details may be found here. As a result, participants in this lab should ensure they are running JDK 21 (or as early as JDK 11), but specifically not JDK 24. If you are running JDK 24, you should uninstall the JDK from your machine and reinstall with the links provided in Configure the enterprise Java environment . With your preferred Java distribution installed locally, you now need to set the appropriate environment variables. Find the Java installation path on your local machine using the instruction set that corresponds to your local operating system. macOS: Open a Terminal and execute: /usr/libexec/java_home The output should resemble something like: /Library/Java/JavaVirtualMachines/jdk-21.jdk/Contents/Home Record this path to a notepad for reference in Step 3 Windows: Open a Command Prompt and execute: echo %JAVA_HOME% If the JAVA_HOME variable has not yet been set, the Java installations are typically located in the C:\\Program Files\\Java\\jdk-XX.X.X directory Record this path to a notepad for reference in Step 3 Set the JAVA_HOME environment variable. Modify the JAVA_HOME path in the export JAVA_HOME=/.../ statements below if the pathway recorded in Step 2 for your machine differs. For example, if using a different Java developer kit version from JDK 24, replace /jdk-24.jdk/ with the version installed on your machine. - macOS: Edit the shell configuration file - Default shell ( zsh ) with Terminal: nano ~/.zshrc - Add the following line to the file: export JAVA_HOME = /Library/Java/JavaVirtualMachines/jdk-21.jdk/Contents/Home export PATH = $JAVA_HOME /bin: $PATH - Save by pressing Ctrl + O and hit Enter to confirm the filename - Exit by pressing Ctrl + X - Windows: - Open the Start menu and search for Environment Variables - Select Edit the system environment variables option - Click the Environment Variables button - Under System Variables , click New - Set the Variable Name = JAVA_HOME and Variable Value = JDK path from Step 1 (e.g. C:\\Program Files\\Java\\jdk-21 ) - Click OK to finalize Apply the changes immediately. macOS : Run the following command with Terminal: source ~/.zshrc If no errors are reported, the variables have been successfully sourced (set) Windows: Close all open command prompts or terminals Open a new Command Prompt to pick up the changes Verify the JAVA_HOME environment variable has been correctly set. macOS: With Terminal, execute: echo $JAVA_HOME The console will return the Java installation path Windows: With Command Prompt, execute: cmd echo %JAVA_HOME% The console will return the Java installation path iii. Maven installation Download and install the latest Maven distribution using either the MacOS or Windows instruction sets below. macOS: The simplest method is using Homebrew to install and deploy Maven locally. To install Homebrew, execute the following with Terminal: /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" With Terminal, execute: brew install maven Follow the prompts (confirming with yes if asked to confirm the install) After the install process has concluded, test with Terminal: mvn --version Windows: Visit the official Maven website: https://maven.apache.org/download.cgi Under Files , click on the binary zip archive link (for example, apache-maven-x.x.x-bin.zip ) Extract the zip file to a location on your local machine (for example, C:\\Apache\\maven\\ ) Replace <path-to-folder> with your machine's installation path and then execute the following with Command Prompt: MAVEN_HOME= <path-to-folder>\\maven\\apache-maven-3.9.9-bin\\apache-maven-3.9.9 Replace <path-to-folder> with your machine's installation path and then execute the following with Command Prompt: <path-to-folder>\\maven\\apache-maven-3.9.9-bin\\apache-maven-3.9.9\\bin Maven is now successfully installed and configured iv. Determine the JDK For Visual Studio (VS) Code and WCA Standard Plans, watsonx Code Assistant needs to determine which Java developer kit (JDK) to use, in the following order of precedence (with 1 being the highest priority): Order of precedence Description 1 Globally-configured Java developer kit for automatic building in the Red Hat extension, which is java.configuration.runtimes in the IDE settings.json file 2 java.jdt.ls.java.home or java.home IDE settings if they are present 3 JAVA_HOME system environment variable, or else JDK_HOME 4 The Java developer kit in the system PATH When WCA Standard Plan features are used, such as Java modernization or upgrade, you can verify which Java developer kit is being used: Within the VS Code IDE, click View and then Output In the Output view, use the dropdown menu to select WCA Look for a message such as Using the Java developer kit that is defined in <location> to run watsonx Code Assistant components. The path is: <path> to determine the feature currently in use v. Set the logging level To adjust logging for the VS Code extension for WCA: From the Extensions panel of VS Code, locate the WCA extension and right-click to pull down a list of available options Select the Extension Settings option Scroll down (or search) for WCA: Log level You may adjust this field from the default INFO setting to alternative options (like WARN ) to cycle between various logging levels vi. Next steps In the following modules, participants will prepare the WCA extensions and plug-ins for Visual Studio Code and Eclipse IDE, respectively.","title":"3. Configure for enterprise Java"},{"location":"saas/3/#configure-the-enterprise-java-environmentibm-cloud-saas-configuration","text":"","title":"Configure the enterprise Java environmentIBM Cloud (SaaS) Configuration"},{"location":"saas/3/#i-objectives-and-rationale","text":"As participants will be working with the IBM watsonx Code Assistant (WCA) Standard Plan and interacting with enterprise Java applications, they will need to perform some additional configuration of their Windows or MacOS machines before setting up the extensions (or plug-ins) to the WCA service. Locally you must install both Java and Apache Maven. Details and download links for the two are summarized in the table below. Java Requirements Distribution Details Resources Java Java SE 11 with Java Developer Kit 21. Download Maven Use Maven to build your application. If you are using Liberty Tools and the Liberty Maven plug-in to build your app or project, use at least Maven 3.8.6. Download","title":"i. Objectives and rationale"},{"location":"saas/3/#ii-java-installation","text":"Download and install the v21 of the Java Developer Kit (JDK) using the vendor link below. URL: https://www.oracle.com/java/technologies/downloads/?er=221886#jdk21-mac It is strongly recommended that you install JDK 21 (or as early as JDK 11) Newer-generation MacOS users will probably want to select the ARM64 DMG Installer Follow the prompts of the installation wizard and complete the installation before continuing to Step 2 INCOMPATIBILITY WITH JDK 24 Note that the Full stack modernization module in Application Modernization - WebSphere to Liberty will encounter compatibility errors with JDK 24 drivers when attempting to Explain or Modernize the source application. This is owing to a deprecation of sun.misc.Unsafe method as of March 2025. Additional details may be found here. As a result, participants in this lab should ensure they are running JDK 21 (or as early as JDK 11), but specifically not JDK 24. If you are running JDK 24, you should uninstall the JDK from your machine and reinstall with the links provided in Configure the enterprise Java environment . With your preferred Java distribution installed locally, you now need to set the appropriate environment variables. Find the Java installation path on your local machine using the instruction set that corresponds to your local operating system. macOS: Open a Terminal and execute: /usr/libexec/java_home The output should resemble something like: /Library/Java/JavaVirtualMachines/jdk-21.jdk/Contents/Home Record this path to a notepad for reference in Step 3 Windows: Open a Command Prompt and execute: echo %JAVA_HOME% If the JAVA_HOME variable has not yet been set, the Java installations are typically located in the C:\\Program Files\\Java\\jdk-XX.X.X directory Record this path to a notepad for reference in Step 3 Set the JAVA_HOME environment variable. Modify the JAVA_HOME path in the export JAVA_HOME=/.../ statements below if the pathway recorded in Step 2 for your machine differs. For example, if using a different Java developer kit version from JDK 24, replace /jdk-24.jdk/ with the version installed on your machine. - macOS: Edit the shell configuration file - Default shell ( zsh ) with Terminal: nano ~/.zshrc - Add the following line to the file: export JAVA_HOME = /Library/Java/JavaVirtualMachines/jdk-21.jdk/Contents/Home export PATH = $JAVA_HOME /bin: $PATH - Save by pressing Ctrl + O and hit Enter to confirm the filename - Exit by pressing Ctrl + X - Windows: - Open the Start menu and search for Environment Variables - Select Edit the system environment variables option - Click the Environment Variables button - Under System Variables , click New - Set the Variable Name = JAVA_HOME and Variable Value = JDK path from Step 1 (e.g. C:\\Program Files\\Java\\jdk-21 ) - Click OK to finalize Apply the changes immediately. macOS : Run the following command with Terminal: source ~/.zshrc If no errors are reported, the variables have been successfully sourced (set) Windows: Close all open command prompts or terminals Open a new Command Prompt to pick up the changes Verify the JAVA_HOME environment variable has been correctly set. macOS: With Terminal, execute: echo $JAVA_HOME The console will return the Java installation path Windows: With Command Prompt, execute: cmd echo %JAVA_HOME% The console will return the Java installation path","title":"ii. Java installation"},{"location":"saas/3/#iii-maven-installation","text":"Download and install the latest Maven distribution using either the MacOS or Windows instruction sets below. macOS: The simplest method is using Homebrew to install and deploy Maven locally. To install Homebrew, execute the following with Terminal: /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" With Terminal, execute: brew install maven Follow the prompts (confirming with yes if asked to confirm the install) After the install process has concluded, test with Terminal: mvn --version Windows: Visit the official Maven website: https://maven.apache.org/download.cgi Under Files , click on the binary zip archive link (for example, apache-maven-x.x.x-bin.zip ) Extract the zip file to a location on your local machine (for example, C:\\Apache\\maven\\ ) Replace <path-to-folder> with your machine's installation path and then execute the following with Command Prompt: MAVEN_HOME= <path-to-folder>\\maven\\apache-maven-3.9.9-bin\\apache-maven-3.9.9 Replace <path-to-folder> with your machine's installation path and then execute the following with Command Prompt: <path-to-folder>\\maven\\apache-maven-3.9.9-bin\\apache-maven-3.9.9\\bin Maven is now successfully installed and configured","title":"iii. Maven installation"},{"location":"saas/3/#iv-determine-the-jdk","text":"For Visual Studio (VS) Code and WCA Standard Plans, watsonx Code Assistant needs to determine which Java developer kit (JDK) to use, in the following order of precedence (with 1 being the highest priority): Order of precedence Description 1 Globally-configured Java developer kit for automatic building in the Red Hat extension, which is java.configuration.runtimes in the IDE settings.json file 2 java.jdt.ls.java.home or java.home IDE settings if they are present 3 JAVA_HOME system environment variable, or else JDK_HOME 4 The Java developer kit in the system PATH When WCA Standard Plan features are used, such as Java modernization or upgrade, you can verify which Java developer kit is being used: Within the VS Code IDE, click View and then Output In the Output view, use the dropdown menu to select WCA Look for a message such as Using the Java developer kit that is defined in <location> to run watsonx Code Assistant components. The path is: <path> to determine the feature currently in use","title":"iv. Determine the JDK"},{"location":"saas/3/#v-set-the-logging-level","text":"To adjust logging for the VS Code extension for WCA: From the Extensions panel of VS Code, locate the WCA extension and right-click to pull down a list of available options Select the Extension Settings option Scroll down (or search) for WCA: Log level You may adjust this field from the default INFO setting to alternative options (like WARN ) to cycle between various logging levels","title":"v. Set the logging level"},{"location":"saas/3/#vi-next-steps","text":"In the following modules, participants will prepare the WCA extensions and plug-ins for Visual Studio Code and Eclipse IDE, respectively.","title":"vi. Next steps"},{"location":"saas/4/","text":"Install WCA extension for Visual Studio Code IBM Cloud (SaaS) Configuration i. Objectives and rationale With the IBM watsonx Code Assistant (WCA) service component of the Software-as-a-Service (SaaS) architecture now successfully provisioned via the IBM Technology Zone (ITZ), participants will now need to set up the WCA extension within an integrated development environment (IDE). WCA currently supports both Visual Studio Code ( VS Code ) and Eclipse IDE . This module guides participants through the process of installing VS Code on their local machine. Afterwards, the WCA extension (\"plug-in\") can then be easily integrated with the IDE and authorized for use with the ITZ-provisioned WCA service. WHY INSTALL LOCALLY? Be aware that ITZ only allows two environments to be reserved for education and training purposes at any one time. Reservations for client demonstrations and pilots do not count against this limit. The WCA Standard plan on SaaS (this module) requires at least one reservation slot. The on-premises environment already provisioned through ITZ for the previous On-Premises Installation and Deployment modules is occupying the second available slot. Provisioning an ITZ-hosted virtual machine (VM) environment will require a third slot \u2014 exceeding what ITZ supports. Therefore, to accommodate a virtualized desktop, participants would need to retire and deprovision the on-premises environment that they've already gone to great lengths to set up. Let's avoid that scenario, if possible. IBM watsonx Code Assistant works great on locally-installed IDEs via extensions (or plug-ins) built into VS Code and Eclipse IDE, respectively. In fact, it's the de facto way to interact with the service and provides the best impression for users \u2014 with a less cumbersome experience executing the lab guide instructions and much more responsive IDE interactions. ii. Locally install VS Code Before you configure the extension for VS Code, you must first install the application on your machine. Download the latest Stable Build [A] release of VS Code available for your machine's operating system using the link below. Download : https://code.visualstudio.com Follow along with the installer wizard steps and continue with the hands-on lab instructions once VS Code is running on your local machine. Launch the VS Code application and take note of the sidebar along the left-side. Click the Extensions [A] icon to open the marketplace of services and open source technologies that can be integrated with VS Code. iii. Install the extension Search for the watsonx Code Assistant for Enterprise Java Applications extension, which corresponds to the WCA Standard plan. This plug-in supports all the features of the Essentials plan, plus enterprise Java modernization capabilities, enhanced code explanation, and enhanced unit test generation \u2014 all of which will be necessary for the Level 4 curriculum and hands-on training. Into the search bar [A] under the Extensions tab, enter the following text: watsonx Code Assistant for Enterprise Java Applications After locating the extension, click the Install [B] button When prompted, select Trust Publisher & Install [C] to confirm the procedure OTHER EXTENSIONS ARE AVAILABLE Note that Standard plan installation creates two entries in your Visual Studio Code Extensions panel: one for watsonx Code Assistant and one for watsonx Code Assistant for Enterprise Java Applications . The two extensions are dependencies for this installation. Two other plug-ins are available within VS Code for IBM watsonx Code Assistant specifically, and even more for other offerings such as IBM watsonx Code Assistant for Red Hat Ansible Lightspeed and IBM watsonx Code Assistant for Z . For WCA, there are alternative extensions available for Trial Plan and Essential Plan tiers. To open WCA within VS Code, click on the watsonx Code Assistant [A] icon that has appeared along the left-hand side of VS Code. You will be greeted with a Welcome, let's get started! prompt within the IDE. Now let's authorize the extension for use with the WCA service provisioned on IBM Cloud. From the WCA panel, click Log in with your API key [A] to continue. A drop-down menu will open at the top of the VS Code interface. Copy and paste [A] the WCA API Key that was recorded in Step 24 of Module 2 into the prompt. The interface should display a line of text indicating a Valid API Key has been detected Press Enter to confirm the input When prompted with The extension 'watsonx Code Assistant' wants to sign in using WCA API Key , click Allow [B] Confirm that the extension successfully authenticated with the WCA service by looking for an open Chat session 1 with watsonx along the left side of the WCA Extension tab [A] . If this Chat interface is available and operational, that confirms that VS Code extension has been successfully integrated with the WCA service. iv. Next steps At this stage, the WCA Standard Plan extension for VS Code has been successfully installed and configured. The following module will guide participants through the steps of locally configuring Eclipse IDE for use with the WCA extension.","title":"4. Install WCA extension for Visual Studio Code"},{"location":"saas/4/#install-wca-extension-for-visual-studio-codeibm-cloud-saas-configuration","text":"","title":"Install WCA extension for Visual Studio CodeIBM Cloud (SaaS) Configuration"},{"location":"saas/4/#i-objectives-and-rationale","text":"With the IBM watsonx Code Assistant (WCA) service component of the Software-as-a-Service (SaaS) architecture now successfully provisioned via the IBM Technology Zone (ITZ), participants will now need to set up the WCA extension within an integrated development environment (IDE). WCA currently supports both Visual Studio Code ( VS Code ) and Eclipse IDE . This module guides participants through the process of installing VS Code on their local machine. Afterwards, the WCA extension (\"plug-in\") can then be easily integrated with the IDE and authorized for use with the ITZ-provisioned WCA service. WHY INSTALL LOCALLY? Be aware that ITZ only allows two environments to be reserved for education and training purposes at any one time. Reservations for client demonstrations and pilots do not count against this limit. The WCA Standard plan on SaaS (this module) requires at least one reservation slot. The on-premises environment already provisioned through ITZ for the previous On-Premises Installation and Deployment modules is occupying the second available slot. Provisioning an ITZ-hosted virtual machine (VM) environment will require a third slot \u2014 exceeding what ITZ supports. Therefore, to accommodate a virtualized desktop, participants would need to retire and deprovision the on-premises environment that they've already gone to great lengths to set up. Let's avoid that scenario, if possible. IBM watsonx Code Assistant works great on locally-installed IDEs via extensions (or plug-ins) built into VS Code and Eclipse IDE, respectively. In fact, it's the de facto way to interact with the service and provides the best impression for users \u2014 with a less cumbersome experience executing the lab guide instructions and much more responsive IDE interactions.","title":"i. Objectives and rationale"},{"location":"saas/4/#ii-locally-install-vs-code","text":"Before you configure the extension for VS Code, you must first install the application on your machine. Download the latest Stable Build [A] release of VS Code available for your machine's operating system using the link below. Download : https://code.visualstudio.com Follow along with the installer wizard steps and continue with the hands-on lab instructions once VS Code is running on your local machine. Launch the VS Code application and take note of the sidebar along the left-side. Click the Extensions [A] icon to open the marketplace of services and open source technologies that can be integrated with VS Code.","title":"ii. Locally install VS Code"},{"location":"saas/4/#iii-install-the-extension","text":"Search for the watsonx Code Assistant for Enterprise Java Applications extension, which corresponds to the WCA Standard plan. This plug-in supports all the features of the Essentials plan, plus enterprise Java modernization capabilities, enhanced code explanation, and enhanced unit test generation \u2014 all of which will be necessary for the Level 4 curriculum and hands-on training. Into the search bar [A] under the Extensions tab, enter the following text: watsonx Code Assistant for Enterprise Java Applications After locating the extension, click the Install [B] button When prompted, select Trust Publisher & Install [C] to confirm the procedure OTHER EXTENSIONS ARE AVAILABLE Note that Standard plan installation creates two entries in your Visual Studio Code Extensions panel: one for watsonx Code Assistant and one for watsonx Code Assistant for Enterprise Java Applications . The two extensions are dependencies for this installation. Two other plug-ins are available within VS Code for IBM watsonx Code Assistant specifically, and even more for other offerings such as IBM watsonx Code Assistant for Red Hat Ansible Lightspeed and IBM watsonx Code Assistant for Z . For WCA, there are alternative extensions available for Trial Plan and Essential Plan tiers. To open WCA within VS Code, click on the watsonx Code Assistant [A] icon that has appeared along the left-hand side of VS Code. You will be greeted with a Welcome, let's get started! prompt within the IDE. Now let's authorize the extension for use with the WCA service provisioned on IBM Cloud. From the WCA panel, click Log in with your API key [A] to continue. A drop-down menu will open at the top of the VS Code interface. Copy and paste [A] the WCA API Key that was recorded in Step 24 of Module 2 into the prompt. The interface should display a line of text indicating a Valid API Key has been detected Press Enter to confirm the input When prompted with The extension 'watsonx Code Assistant' wants to sign in using WCA API Key , click Allow [B] Confirm that the extension successfully authenticated with the WCA service by looking for an open Chat session 1 with watsonx along the left side of the WCA Extension tab [A] . If this Chat interface is available and operational, that confirms that VS Code extension has been successfully integrated with the WCA service.","title":"iii. Install the extension"},{"location":"saas/4/#iv-next-steps","text":"At this stage, the WCA Standard Plan extension for VS Code has been successfully installed and configured. The following module will guide participants through the steps of locally configuring Eclipse IDE for use with the WCA extension.","title":"iv. Next steps"},{"location":"saas/5/","text":"Install WCA plug-in for Eclipse IDE IBM Cloud (SaaS) Configuration i. Objectives and rationale With the IBM watsonx Code Assistant (WCA) service component of the Software-as-a-Service (SaaS) architecture now successfully provisioned via the IBM Technology Zone (ITZ), participants will now need to set up the WCA extension within an integrated development environment (IDE). WCA currently supports both Visual Studio Code ( VS Code ) and Eclipse IDE . This module guides participants through the process of installing Eclipse IDE on their local machine. Afterwards, the WCA extension (\"plug-in\") can then be easily integrated with the IDE and authorized for use with the ITZ-provisioned WCA service. WHY INSTALL LOCALLY? Be aware that ITZ only allows two environments to be reserved for education and training purposes at any one time. Reservations for client demonstrations and pilots do not count against this limit. The WCA Standard plan on SaaS requires at least one reservation slot. The on-premises environment already provisioned through ITZ for the previous On-Premises Installation and Deployment modules is occupying the second available slot. Provisioning an ITZ-hosted virtual machine (VM) environment will require a third slot \u2014 exceeding what ITZ supports. Therefore, to accommodate a virtualized desktop, participants would need to retire and deprovision the on-premises environment that they've already gone to great lengths to set up. Let's avoid that scenario, if possible. IBM watsonx Code Assistant works great on locally-installed IDEs via extensions built into VS Code and Eclipse IDE. In fact, it's the de facto way to interact with the service and provides the best impression for users by far \u2014 with a less cumbersome experience with the lab guide instructions and much more responsive IDE interactions. ii. Locally install Eclipse IDE With the IBM Cloud credentials set up, the next step will be to install the Eclipse IDE locally and then integrate it with the WCA service via the IDE plug-in. Download the Eclipse IDE from the Eclipse Foundation. Use the Eclipse Installer , recommended at the top of the download page [A] Select the version appropriate to your local machine's operating system URL: https://www.eclipse.org/downloads/packages/ Run the installer on your local machine. Select the Eclipse IDE for Java Developers option [A] Follow along with the remaining prompts until the Eclipse IDE has been installed Once the install process has concluded, click Launch [B] from the installer or manually launch the Eclipse IDE application yourself Upon launching the Eclipse IDE for the first time, users will be prompted to Select a directory as workspace . Choose a directory on your local machine [A] you feel appropriate (or select the one selected by default for you) and then click Launch [B] to continue. iii. Install the plug-in Open the Eclipse Marketplace listing for IBM watsonx Code Assistant for Enterprise Java Applications plug-in, which corresponds to the WCA Standard plan. This plug-in supports all the features of the Essentials plan, plus enterprise Java modernization capabilities, enhanced code explanation, and enhanced unit test generation \u2014 all of which will be necessary for the Level 4 curriculum. Locate the Install button on the Eclipse Marketplace page. The easiest method for installing this plug-in is to click and hold [A] the mouse button down on this Install button, then drag and release [B] on top of the open Eclipse IDE application. An install wizard will open within the Eclipse IDE automatically Confirm Selected Features : verify the two WCA options are selected [C] and Confirm [D] Installation should take about 1 minute to conclude Wait for the Review Licenses panel to load Within the Review Licenses panel, read through all three license agreements [A] and click the I accept the terms of the license agreements [B] option. To progress the installation, click Finish Wait a few moments for the Trust Authorities panel to load Within the Trust Authorities , examine the Authority / Update Site table at the top to load. Select [A] (tick the box) left of the https://public.dhe.ibm.com option field All other fields can remain as their default settings Click the Trust Selected [B] button to continue Wait 1 to 2 minutes for the software to continue installing After a few moments, a Software Updates window will prompt you to restart the Eclipse IDE. Click the Restart Now [A] button to re-launch the application Installation of the WCA plug-in software and dependencies will continue after launching Wait a moment for the installation to conclude iv. Validate the plug-in At this stage, the WCA plug-in for Eclipse IDE has been successfully installed on your local machine. Now you must authorize the plug-in for use with the WCA Standard Plan on IBM Cloud. From the Eclipse application, select Window , then Show View , and finally Other [A] to open the plug-ins browser. From the table of option, scroll down and locate watsonx Code Assistant . Double-click on the folder (or click the arrow to the left of it) Select the Chat [A] option and then click Open [B] A new window (among several open tabs) will open at the bottom of the Eclipse IDE [A] . Scroll down within the window to the bottom of the page Click the Log in with your API key [B] button A new Preferences window will open. Within the API Key field [A] , paste the WCA API Key that was recorded in Step 24 of Module 2 into the prompt The remaining settings can remain at the default values Click the Apply and Close [B] button Click No [C] when prompted to create a Secure Storage - Password Hint Needed v. Conclusion The Eclipse IDE plug-in for IBM watsonx Code Assistant has been successfully installed and authorized for use with the WCA Standard (SaaS) plan deployed on IBM Cloud. The environment is now ready for use with the Application Modernization modules of the Level 4 curriculum. Having concluded the IBM Cloud (SaaS) Configuration hands-on modules, complete the corresponding Evaluation quiz and then continue with the remainder of the Level 4 curriculum.","title":"5. Install WCA plug-in for Eclipse IDE"},{"location":"saas/5/#install-wca-plug-in-for-eclipse-ideibm-cloud-saas-configuration","text":"","title":"Install WCA plug-in for Eclipse IDEIBM Cloud (SaaS) Configuration"},{"location":"saas/5/#i-objectives-and-rationale","text":"With the IBM watsonx Code Assistant (WCA) service component of the Software-as-a-Service (SaaS) architecture now successfully provisioned via the IBM Technology Zone (ITZ), participants will now need to set up the WCA extension within an integrated development environment (IDE). WCA currently supports both Visual Studio Code ( VS Code ) and Eclipse IDE . This module guides participants through the process of installing Eclipse IDE on their local machine. Afterwards, the WCA extension (\"plug-in\") can then be easily integrated with the IDE and authorized for use with the ITZ-provisioned WCA service. WHY INSTALL LOCALLY? Be aware that ITZ only allows two environments to be reserved for education and training purposes at any one time. Reservations for client demonstrations and pilots do not count against this limit. The WCA Standard plan on SaaS requires at least one reservation slot. The on-premises environment already provisioned through ITZ for the previous On-Premises Installation and Deployment modules is occupying the second available slot. Provisioning an ITZ-hosted virtual machine (VM) environment will require a third slot \u2014 exceeding what ITZ supports. Therefore, to accommodate a virtualized desktop, participants would need to retire and deprovision the on-premises environment that they've already gone to great lengths to set up. Let's avoid that scenario, if possible. IBM watsonx Code Assistant works great on locally-installed IDEs via extensions built into VS Code and Eclipse IDE. In fact, it's the de facto way to interact with the service and provides the best impression for users by far \u2014 with a less cumbersome experience with the lab guide instructions and much more responsive IDE interactions.","title":"i. Objectives and rationale"},{"location":"saas/5/#ii-locally-install-eclipse-ide","text":"With the IBM Cloud credentials set up, the next step will be to install the Eclipse IDE locally and then integrate it with the WCA service via the IDE plug-in. Download the Eclipse IDE from the Eclipse Foundation. Use the Eclipse Installer , recommended at the top of the download page [A] Select the version appropriate to your local machine's operating system URL: https://www.eclipse.org/downloads/packages/ Run the installer on your local machine. Select the Eclipse IDE for Java Developers option [A] Follow along with the remaining prompts until the Eclipse IDE has been installed Once the install process has concluded, click Launch [B] from the installer or manually launch the Eclipse IDE application yourself Upon launching the Eclipse IDE for the first time, users will be prompted to Select a directory as workspace . Choose a directory on your local machine [A] you feel appropriate (or select the one selected by default for you) and then click Launch [B] to continue.","title":"ii. Locally install Eclipse IDE"},{"location":"saas/5/#iii-install-the-plug-in","text":"Open the Eclipse Marketplace listing for IBM watsonx Code Assistant for Enterprise Java Applications plug-in, which corresponds to the WCA Standard plan. This plug-in supports all the features of the Essentials plan, plus enterprise Java modernization capabilities, enhanced code explanation, and enhanced unit test generation \u2014 all of which will be necessary for the Level 4 curriculum. Locate the Install button on the Eclipse Marketplace page. The easiest method for installing this plug-in is to click and hold [A] the mouse button down on this Install button, then drag and release [B] on top of the open Eclipse IDE application. An install wizard will open within the Eclipse IDE automatically Confirm Selected Features : verify the two WCA options are selected [C] and Confirm [D] Installation should take about 1 minute to conclude Wait for the Review Licenses panel to load Within the Review Licenses panel, read through all three license agreements [A] and click the I accept the terms of the license agreements [B] option. To progress the installation, click Finish Wait a few moments for the Trust Authorities panel to load Within the Trust Authorities , examine the Authority / Update Site table at the top to load. Select [A] (tick the box) left of the https://public.dhe.ibm.com option field All other fields can remain as their default settings Click the Trust Selected [B] button to continue Wait 1 to 2 minutes for the software to continue installing After a few moments, a Software Updates window will prompt you to restart the Eclipse IDE. Click the Restart Now [A] button to re-launch the application Installation of the WCA plug-in software and dependencies will continue after launching Wait a moment for the installation to conclude","title":"iii. Install the plug-in"},{"location":"saas/5/#iv-validate-the-plug-in","text":"At this stage, the WCA plug-in for Eclipse IDE has been successfully installed on your local machine. Now you must authorize the plug-in for use with the WCA Standard Plan on IBM Cloud. From the Eclipse application, select Window , then Show View , and finally Other [A] to open the plug-ins browser. From the table of option, scroll down and locate watsonx Code Assistant . Double-click on the folder (or click the arrow to the left of it) Select the Chat [A] option and then click Open [B] A new window (among several open tabs) will open at the bottom of the Eclipse IDE [A] . Scroll down within the window to the bottom of the page Click the Log in with your API key [B] button A new Preferences window will open. Within the API Key field [A] , paste the WCA API Key that was recorded in Step 24 of Module 2 into the prompt The remaining settings can remain at the default values Click the Apply and Close [B] button Click No [C] when prompted to create a Secure Storage - Password Hint Needed","title":"iv. Validate the plug-in"},{"location":"saas/5/#v-conclusion","text":"The Eclipse IDE plug-in for IBM watsonx Code Assistant has been successfully installed and authorized for use with the WCA Standard (SaaS) plan deployed on IBM Cloud. The environment is now ready for use with the Application Modernization modules of the Level 4 curriculum. Having concluded the IBM Cloud (SaaS) Configuration hands-on modules, complete the corresponding Evaluation quiz and then continue with the remainder of the Level 4 curriculum.","title":"v. Conclusion"}]}